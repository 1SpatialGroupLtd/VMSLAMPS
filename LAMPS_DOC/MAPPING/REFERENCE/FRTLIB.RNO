.!** Qume page format
.LEFT MARGIN  0;.RIGHT MARGIN 80;.PAGE SIZE    60,80
.KEEP
.XLOWER
.FLAGS CAPITALIZE
.FLAGS INDEX
.NOFLAGS BOLD

.!** title page
.FIGURE 14
.CENTRE ;^&Laser-Scan_ Ltd.\& 
.FIGURE 2
.CENTRE ;^&Feature_ Representation_ Library FRTLIB\&
.BLANK
.CENTRE ;^&Programmer_ Reference_ Manual\&
.FIGURE 2
.CENTRE ;^&Issue_ 1.19\&

.FOOT
.FLAGS SUBSTITUTE		.! enable $$year
.NOFILL
Copyright (C) $$year Laser-Scan Ltd
Science Park, Milton Road, Cambridge, England CB4 4FY  tel: +44 (0) 1223 420414

Document "FRTLIB Reference"			Category "REFERENCE"
Document Issue 0.1	Paul Hardy		14-Jun-1983
Document Issue 0.9	Paul Hardy		29-Oct-1984
Document Issue 1.0	Tony J. Ibbs		10-Dec-1984
Document Issue 1.1	Clarke Brunt		 6-Nov-1985
Document Issue 1.2	Ron Russell		 1-Jul-1986
Document Issue 1.3	Clarke Brunt		23-Nov-1986
Document Issue 1.4	R J Hulme		06-Jan-1987
Document Issue 1.5	T J Hartnall		29-Jan-1987
Document Issue 1.6	R J Hulme		09-Feb-1987
Document Issue 1.7	R W Russell		20-Oct-1987
Document Issue 1.8	R W Russell		14-Jan-1988
Document Issue 1.9	R W Russell		17-Jun-1988
Document Issue 1.10	R W Russell		16-Nov-1988
Document Issue 1.11	R W Russell		13-Jun-1989
Document Issue 1.12	Clarke Brunt		27-Jul-1989
Document Issue 1.13	Clarke Brunt		25-Jan-1990
Document Issue 1.14	Clarke Brunt		 8-Mar-1991
Document Issue 1.15	Ron Russell		 5-Mar-1992
Document Issue 1.16	Clarke Brunt		 5-Nov-1992
Document Issue 1.17	Clarke Brunt		13-Sep-1993
Document Issue 1.18	Clarke Brunt		30-Aug-1994
Document Issue 1.19	Clarke Brunt		 9-Jan-1995
.FILL
.NOFLAGS SUBSTITUTE		.! disable $$year
.END FOOT

.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.!      this can be commented out, when no bars required
.!
.! allow for .BEGIN BAR and .END BAR commands
.!ENABLE BAR
.!RIGHT MARGIN 77
.!PAGE SIZE 60,77
.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

.!* and the title to go at the top of each page
.TITLE FRTLIB Reference Manual
.PAGE

.TP 6
.HL 1 ^&INTRODUCTION\&
.INDEX Introduction
.P0
The >Legenda library system has been used in existing LSL graphics
programs (SOL, LITES, and SPM) for some years, but it has limitations
arising from its origins on PDP11 HRD-1 systems.
Recent developments have highlighted requirements for an enhanced system
for high quality cartographic work, and this has resulted in the development
of a new library (FRTLIB) for manipulating feature representations.
.P0
The main differences between LEGLIB and FRTLIB include :-
.LIST "o"
.LE
.INDEX CTG
Legenda files are single binary files needing a special program to
manipulate them (CTG). FRTLIB uses a text file, which can be edited
using a standard text editor, together with one or two IFF files to
contain the coordinate parts of symbol and text representation. These
IFF files can be manipulated using standard LSL IFF utilities (eg
LITES). 
.LE
LEGLIB goes through the same lookup mechanism for all feature types.
FRTLIB can get the attributes of non-patterned lines in a single lookup.
Symbols, and patterned lines may require a second reference, but these
make up a small part of most maps. 
.LE
Symbols in Legendas can only consist of a small number of straight lines.
FRT symbols may contain combinations of lines, curves, and circle arcs of
almost arbitrary complexity.
.LE
The FRT library supports a much wider range of attributes of a feature
in terms of line widths, colours, and sizes.
.LE
LEGLIB has no representation of character fonts, and hence these
previously have had to be statically defined. FRTLIB uses the same
facilities as for symbols to allow text characters to be defined and
manipulated. 
.LE
In LEGLIB, the feature code for a symbol was looked up directly in the
legenda file. This means that if several feature codes have the same
symbol, then the symbol shape must be defined several times. FRTLIB has
two tier lookup, and many feature codes may reference the same symbol
shape. 
.LE
FRTLIB includes routines to plot symbols, texts, and patterned lines,
rather than this being the responsibility of individual programs. This
ensures consistency between different programs which use the library. 
.END LIST



.PG
.TP 6
.HL 1 ^&LIBRARY\&
.INDEX Library
.INDEX Subroutines
.INDEX Feature Code
FRTLIB allows a feature code (FC) to be looked up in a file or 
set of files to obtain the correct graphical representation of a line, 
curve, patterned line, symbol or text feature.
The mechanism involves tables of feature representations, together with
files of symbol and text character definitions.
.P 0;For details of the content and structure of the lookup files used by
FRTLIB see the FRT User Guide. 
.P0
FRTLIB is a library of FORTRAN callable subroutines which communicate
with the user program via subroutine arguments, function return values,
and a series of common blocks. The library is >LSL$LIBRARY:LSLFRTLIB and
should be scanned before >LSLLIB and >IFFLIB which it references.
.P 0
The two latter libraries are also available in shareable image form. To link
with the shareable images, specify LSL$LIBRARY:LSLSHR/OPT and
LSL$LIBRARY:IFFSHR/OPT on the link command lines.
.P 0
FRTLIB itself is also available as a shareable
image. To link with this, specify LSL$LIBRARY:FRTSHR/OPT on the link
command line. If using this, then you must also use the LSLSHR and IFFSHR
images. The FRTLIB shareable image cannot call graphics routines directly,
since the particular routines required are not fixed. Instead, it calls
19 user-supplied routines (see below) whose addresses must be loaded into
an array in common block SRIVEC. The object library, LSLFRTLIB.OLB,
contains standard versions of these routines (which call real GKS routines),
and also a routine FRT__GRAPH__INIT to load the addresses into the common
block. This means that to use graphics with the FRTLIB shareable image,
you must include LSLFRTLIB.OLB in the link, and call FRT__GRAPH__INIT before
any other FRTLIB routines.

.NOTE
The original library >LSL$LIBRARY:FRTLIB that referenced >VIOLIB and 
>CMDLIB has been superceded by the current library LSLFRTLIB that makes 
calls to LSLLIB.
This library should no longer be used - the common blocks supplied with
LSLFRTLIB do not match those used by it.
.P 0; LSLLIB must be initialised with a call of the subroutine
>LSL__INIT (see section 5, below).
.END NOTE
If the plotting routines are used, then graphics routines must be 
supplied. By default, the library references <>GKS
(>Graphical_ ^Kernel_ ^System>) routines. 

.TP 6
.HL 1 ^&GRAPHICS INTERFACE\&
.INDEX Graphics Interface
.P0
FRTLIB includes routines to plot symbols, texts and patterned lines. By
default, the library references the following <>GKS routines - GQLWSC,
GQPLCI, GQLN, GSLWSC, GSPLCI, GSLN and GPL for polylines, GQFAIS, GQFASI,
GQFACI, GSFAIS, GSFASI and GFA for fill areas, GQMCI, GQMK, GSMCI, GSMK and
GPM for symbols drawn by hardware,
GSTXFP, GSTXCI, GSCHH, GSCHUP and GTX for texts drawn by hardware.
GESC, GGDP (for hardware circles and curves), and (LSL routines)
LSG__SET__PATTERN, LSG__BEGIN__AREA, LSG__END__AREA, LSG__STRING__WIDTH,
and LSG__STRING__BOUNDS are also used in a way which is unlikely to be
consistent with arbitrary GKS systems.

.P 0
If a true GKS system is used, then it is the responsibility of the
calling program to set it up correctly before calling FRTLIB. In
particular, GKS must be open, with the desired workstation(s) open and
active.
All aspect source flags should be set to INDIVIDUAL,
and any desired transformations should be set up. 

.P 0
FRTLIB restores the various GKS attributes to their previous values
after plotting,
except the various text attributes (it is expected that FRTLIB will be
entirely responsible for plotting text).
If the workstation supports thick lines, then its
nominal line thickness must be communicated to FRTLIB by a call to
<>SRISLW (q.v.). >Thick lines may be suppressed completely by setting
the logical variable <>FRTHKS in common <>FRTCOM to .TRUE. If the
symbols and texts being plotted include circle arcs, interpolated curves
or fill areas or if PATGPL is used to draw patterned lines then a call
to <>SRIUNI (q.v.) should be made to give FRTLIB information about the
units being used and any rotation that has been applied to coordinates
relative to the GKS window by the calling program. The default values
are appropriate for a drawing scale such that one unit corresponds to
one millimetre. 

.P0
In the present implementation, the graphical characteristics used when
plotting texts or symbols, are taken from the SCT entries for the
individual components of the symbol/character. If these fields are
absent or invalid (usually = 0) then the values in the FRT entry for the
complete feature are used. If these  are also missing or invalid, then
defaults are used. 
.BR
The graphical characteristics that are being referred to are the line
width, cross hatching spacing (for fill areas), hardware line type,
drawing tool and colour. 
.BR
Routine <>SRICOL may be used to specify the symbols and texts are to be
drawn in a particular overriding colour. 

.P0
The GKS routines may be supplied by the user if desired, rather
than using a full GKS system. The calls to GKS are contained within
nineteen routines in FRTLIB, the specification of which follows, and
the user may alternatively replace these.

.P0
It is possible to use FRTLIB to plot on three dimensional devices. This 
is achieved by calls to SRI__SET__Z and use of the Z arguments to
SRIGPL, SRIGFA, SRIGPM, SRIGTX, SRIGDP and PATGPL (see below).

.TP 6
.HL 2 ^&SRIGQP - Inquire polyline attributes\&
.INDEX SRIGQP
.NOFILL

	SUBROUTINE SRIGQP(WIDTH,ICOL)
	Returns REAL	WIDTH - linewidth scale factor
		INTEGER ICOL  - polyline colour index
.FILL
This routine is used to preserve the attributes, so that they may be
reset by a later call to SRIGSP.

.TP 6
.HL 2 ^&SRIGSP - Set polyline attributes\&
.INDEX SRIGSP
.NOFILL

	SUBROUTINE SRIGSP(WIDTH,ICOL)
		REAL	WIDTH - linewidth scale factor
		INTEGER ICOL  - polyline colour index

.FILL
This routine is used to set the polyline attributes. It may be passed
WIDTH=0.0, meaning normal thickness. Zero is an invalid linewidth
scale factor in GKS, and SRIGSP must detect this case.

.TP 6
.HL 2 ^&SRIGPL - polyline\&
.INDEX SRIGPL
.NOFILL

	SUBROUTINE SRIGPL(N,X,Y,Z)
		INTEGER	N     - number of points
		REAL	X(N)  - x coordinates
		REAL	Y(N)  - y coordinates
		REAL	Z(N)  - z coordinates

.FILL
This routine is used to draw lines. It should draw a line connecting
the given points.
.P 0
As supplied in FRTLIB, this makes a call to the GKS routine GPL
and the 4th argument is not required. However, this routine
is designed to be replaced, when required, by any application program,
and when this is done the 4th argument is used to pass the
heights of the points. 

.TP 6
.HL 2 ^&SRIGQA - Inquire fill area attributes\&
.INDEX SRIGQA
.NOFILL

	SUBROUTINE SRIGQA(STYLE,INDEX,COLOUR,WIDSEP)
	Returns INTEGER	STYLE     - fill area internal style
		INTEGER	INDEX     - fill area style index
		INTEGER ICOL      - fill area colour index
		REAL	WIDSEP(2) - line width and separation
				  - for hatching
.FILL
This routine is used to preserve the attributes, so that they may be
reset by a later call to SRIGSA.

.TP 6
.HL 2 ^&SRIGSA - Set fill area attributes\&
.INDEX SRIGSA
.NOFILL

	SUBROUTINE SRIGSA(STYLE,INDEX,COLOUR,WIDSEP)
		INTEGER	STYLE     - fill area interior style
		INTEGER	INDEX     - fill area style index
		INTEGER ICOL      - fill area colour index
		REAL	WIDSEP(2) - line width and separation
				  - for hatching

.FILL
This routine is used to set the fill area attributes.

.TP 6
.HL 2 ^&SRIGFA - fill area\&
.INDEX SRIGFA
.NOFILL

	SUBROUTINE SRIGFA(N,X,Y,Z)
		INTEGER	N     - number of points
		REAL	X(N)  - x coordinates
		REAL	Y(N)  - y coordinates
		REAL	Z(N)  - z coordinates

.FILL
This routine is used to draw fill areas. It should draw the appropriate
area using the fill style and index specified by SRIGSA. If the polygon
is not closed, then this routine should close it. 
.P 0
As supplied in FRTLIB, this makes a call to the GKS routine GFA and the
4th argument is not required. However, this routine is designed
to be replaced, when required, by any application program, and when this
is done the 4th argument is used to pass the heights of the
points. 
.TP 6
.HL 2 ^&SRIGQM - Inquire polymarker attributes\&
.INDEX SRIGQM
.NOFILL

	SUBROUTINE SRIGQM(SYMNO,ANGLE,ICOL)
	Returns	INTEGER	SYMNO 	- symbol
		REAL	ANGLE	- angle to draw it at
		INTEGER	ICOL	- colour to use

.FILL
This routine is used to preserve the attributes, so that they may be
reset by a later call to SRIGSM.

.TP 6
.HL 2 ^&SRIGSM - Set polymarker attributes\&
.INDEX SRIGSM
.NOFILL

	SUBROUTINE SRIGSM(SYMNO,ANGLE,ICOL)
		INTEGER	SYMNO 	- symbol
		REAL	ANGLE	- angle to draw it at
		INTEGER	ICOL	- colour to use

.FILL
This routine is used to set the polymarker attributes.

.TP 6
.HL 2 ^&SRIGPM - polymarker\&
.INDEX SRIGPM
.NOFILL

	SUBROUTINE SRIGPM(N,X,Y,Z)
		INTEGER	N     - number of points
		REAL	X(N)  - x coordinates
		REAL	Y(N)  - y coordinates
		REAL	Z(N)  - z coordinates

.FILL
This routine is used to draw polymarkers. It should draw the current polymarker
at each of the given points.
.P 0
As supplied in FRTLIB, this makes a call to the GKS routine GPM and the
4th argument is not required. However, this routine is designed
to be replaced, when required, by any application program, and when this
is done the 4th argument is used to pass the heights of the
points. 

.TP 6
.HL 2 ^&SRIGST - Set text attributes\&
.INDEX SRIGST
.NOFILL

	SUBROUTINE SRIGST(FONT,COLOUR,SIZE,ANGLE)
		INTEGER	FONT 	- font number
		INTEGER	COLOUR	- colour to use
		REAL	SIZE	- text height in world units
		REAL	ANGLE	- angle to draw it at

.FILL
This routine is used to set the hardware text attributes.

.TP 6
.HL 2 ^&SRI__STRING__WIDTH - Inquire hardware text width\&
.INDEX SRI__STRING__WIDTH
.NOFILL

	LOGICAL FUNCTION SRI__STRING__WIDTH(STRING,FONT,WIDTH)
		CHARACTER_*(_*)	STRING  - character string
		INTEGER		FONT    - font number
		REAL		WIDTH   - returned width

.FILL
This routine is used to get the width of a hardware text string (if drawn
at unit height in the given font). By default it calls LSG__STRING__WIDTH.
It should return .TRUE_. if it cannot obtain the string width.

.TP 6
.HL 2 ^&SRI__STRING__BOUNDS - Inquire hardware text boundary\&
.INDEX SRI__STRING__BOUNDS
.NOFILL

	LOGICAL FUNCTION SRI_STRING_BOUNDS(STRING,FONT,BORDER,ROUTINE)
		CHARACTER_*(_*)	STRING  - character string
		INTEGER		FONT    - font number
		REAL		BORDER  - border round characters
		EXTERNAL	ROUTINE - callback routine

.FILL
This routine is used to get a bounding region for a hardware text string
(if drawn at unit height in the given font). By default it calls
LSG__STRING__BOUNDS. It should return .TRUE_. if it is unable to return
the information. The information is returned be calling
.BR
	ROUTINE(WIDTH,LLX,LLY,URX,URY)
.BR
for each character in the string.

.TP 6
.HL 2 ^&SRIGTX - text\&
.INDEX SRIGTX
.NOFILL

	SUBROUTINE SRIGTX(X,Y,Z,STRING)
		REAL		X  - x coordinates
		REAL		Y  - y coordinates
		REAL		Z  - z coordinates
		CHARACTER_*(_*)	STRING - character string

.FILL
This routine is used to draw hardware text. It should draw the text string
at the given point.
.P 0
As supplied in FRTLIB, this makes a call to the GKS routine GTX and the
3rd argument is not required. However, this routine is designed
to be replaced, when required, by any application program, and when this
is done the 3rd argument is used to pass the height of the
points. 

.TP 6
.HL 2 ^&SRIGQL - Inquire drawing hardware\&
.INDEX SRIGQL
.NOFILL

	SUBROUTINE SRIGQL(LINE_TYPE,HARD_WARE,ANGLE)
	Returns	INTEGER	LINE_TYPE	- line type
		INTEGER	HARD_WARE	- hardware tool to be used for line
		REAL	ANGLE		- angle tool is set at

.FILL
This routine is used to preserve the attributes, so that they may be
reset by a later call to SRIGSL.

.TP 6
.HL 2 ^&SRIGSL - Set drawing hardware\&
.INDEX SRIGSL
.NOFILL

	SUBROUTINE SRIGSL(LINE_TYPE,HARD_WARE,ANGLE)
		INTEGER	LINE_TYPE	- line type
		INTEGER	HARD_WARE	- hardware to be used for line
		REAL	ANGLE		- angle tool is set at

.FILL
This routine is used to set the hardware for drawing.

.TP 6
.HL 2 ^&SRIGDP - generalised drawing primitive\&
.INDEX SRIGSL
.NOFILL

	SUBROUTINE SRIGDP(N,X,Y,Z,ID)
		INTEGER	N		- number of coords
		REAL	X(N)	- x coordinates
		REAL	Y(N)	- y coordinates
		REAL	Z(N)	- z coordinates
		INTEGER	ID	- GDP id.

.FILL
This arguments are passed on to GKS routine GGDP. ID controls what
coordinates are expected.
.NOFILL
	ID = 1 full circle, 2 points, centre, edge
	ID = 2 clockwise arc, 3 points, start, end, centre
	ID = 3 anti-clockwise arc, 3 points, start, end, centre
	ID = 6 interpolated curve connecting the points

.FILL
.P 0
As supplied in FRTLIB, this makes a call to the GKS routine GGDP and the
4th argument is not required. However, this routine is designed
to be replaced, when required, by any application program, and when this
is done the 4th argument is used to pass the heights of the
points. 

.TP 6
.HL 2 ^&SRI__SET__PATTERN - set up hardware pattern\&
.INDEX SRI__SET__PATTERN
.NOFILL

	INTEGER FUNCTION SRI_SET_PATTERN(LEN,MAJ,MIN,MAREP,MIREP,FLG)
		REAL	LEN	- overall length
		REAL	MAJ	- major dash length
		REAL	MIN	- minor dash length
		INTEGER	MAREP	- major repeat count
		INTEGER	MIREP	- minor repeat count
		INTEGER	FLG	- pattern flags

.FILL
The arguments are passed on to LSG__SET__PATTERN. If the specified pattern
can be drawn by hardware, the function returns a number which will
subsequently be passed as the LINE__TYPE argument to GSLN via SRIGSL.
Otherwise return 0.

.TP 6
.HL 2 ^&SRI__BEGIN__AREA - begin a composite area\&
.INDEX SRI__BEGIN__AREA
.NOFILL

	SUBROUTINE SRI__BEGIN__AREA

.FILL
This calls LSG__BEGIN__AREA. Subsequent calls to SRIGFA are to be treated
as part of a composite area, until a call to SRI__END__AREA.

.TP 6
.HL 2 ^&SRI__END__AREA - end a composite area\&
.INDEX SRI__END__AREA
.NOFILL

	SUBROUTINE SRI__END__AREA

.FILL
This calls LSG__END__AREA. It indicates the end of a composite area, which
should now be filled as appropriate.

.TP 6
.HL 1 ^&COMMON BLOCKS\&
.INDEX Common blocks
.P0
The common blocks of the FRT system are held in LSL$CMNFRT:, and can
be included into user programs by using INCLUDE statements. The ones which
may be used by user programs are:-
.P 0
FRTCOM.CMN is the main common block holding the FRT table itself, together
with information about the currently selected Feature Code.
.P 0
FRTPRIO.CMN holds the priority definition table.
.P 0
FRTFIL.CMN holds the area fill pattern definition table.
.P 0
FRTGRP.CMN holds the Feature Code Group definitions.
.P 0
FRTPAT.CMN holds the line pattern definition table.
.P 0
FRTSCT.CMN is similar to FRTCOM.CMN, but holds information about the
Symbol Component Table (SCT).
.P 0
FRTSRI.CMN holds the Symbol Representation Index table (SRI).
.P 0
FRTTRI.CMN is similar to FRTSRI.CMN, but holds the Text Representation Index
table (TRI).
.P 0
TRIEXT.CMN holds character extent with respect to the locating point
.P 0
FRTACD.CMN holds the Attribute Code Definitions.
.P 0
These common blocks contain several variables whose names end with "__LOC".
These contain the addresses of memory obtained at run time containing
arrays of data read from the FRT files. It should not normally be necessary
for programs to reference these arrays, but if they must be accessed, then
one method (in Fortran, and taking FRTINT__LOC as an example) is to pass
_%VAL(FRTINT__LOC) as an argument to a subroutine, and within the subroutine
declare the argument as INTEGER_*2 FRTINT(6,FRTMAX). The array may then
be accessed just as the old FRTINT array was in previous releases of the
library. References to the group command table should now use
_%VAL(GRPCMT__LOC), rather then just GRPCMT as previously. Access to the
group bitmaps should now be made using the routines <>GRPFCT and 
.INDEX GRPFC
GRPFC.

.TP 6
.NOFLAGS COMMENT
.NOFLAGS ACCEPT
.HL 2 ^&FRTCOM\&
.INDEX FRTCOM
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTCOM.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTFIL\&
.INDEX FRTFIL
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTFIL.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTGRP\&
.INDEX FRTGRP
.INDEX Feature Code Groups
.INDEX Groups
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTGRP.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTPAT\&
.INDEX Patterned lines
.INDEX FRTPAT
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTPAT.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTPRIO\&
.INDEX Priority Table
.INDEX FRTPRIO
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTPRIO.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTSCT\&
.INDEX Symbol Component Table
.INDEX SCT
.INDEX FRTSCT
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTSCT.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTSRI\&
.INDEX SRI
.INDEX FRTSRI
.INDEX Symbol Representation IFF file (SRI)
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTSRI.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTTRI\&
.INDEX TRI
.INDEX FRTTRI
.INDEX Text Representation IFF file (TRI)
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTTRI.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&TRIEXT\&
.INDEX TRIEXT
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:TRIEXT.CMN'
.FLAGS UNDERLINE

.TP 6
.HL 2 ^&FRTACD\&
.INDEX FRTACD
.NOFLAGS UNDERLINE
.NOFILL
.REQUIRE 'LSL$CMNFRT:FRTACD.CMN'
.FLAGS UNDERLINE
.FLAGS COMMENT
.FLAGS ACCEPT
.FILL

.PG
.TP 6
.HL 1 ^&SUBROUTINES\&
.INDEX Subroutines
.P0
Most of the routines in the FRT library are defined as FORTRAN logical
functions returning .FALSE. if they succeed, and .TRUE. if they fail.

.P 0; Before any call to FRTLIB subroutines are made, the library
>LSLLIB must be initialised by a call to the subroutine LSL__INIT. 
.INDEX LSL__INIT
Programs that use FRTLIB, but do not otherwise access LSLLIB must
ensure that a call is made to this routine before any calls to FRTLIB 
routines are made. LSL__INIT is in LSLLIB, but its specification is 
included below, as it is necessary for the use of (LSL)FRTLIB.

.P 0; Programs which use the shareable image version of FRTLIB to
perform graphics may call the routine FRT__GRAPH__INIT as a convenient
way of setting up the addresses of the graphics routine in common block
SRIVEC.

.P 0; All programs using the FRT library must either call routine
FRTINI, passing it the name of an FRT file as argument, or if only the
attribute code definition routines and the default attribute code
definitions are required, the routine FRT__ACDINI. If the former case
then the FRT file has been read into the various common blocks, and
routines such as FRTFND can be called to find the representation of a
given Feature Code. In the latter case, the ACD common blocks are filled
with the default attribute code information. The information about
attribute definitions are accessed by the routines ACDFND and
ACDFND__NAME. 
.BL
If symbol and character handling is needed then routines SRIINI and
TRIINI must be called before any other SRI or TRI routines may be used. 

.TP 6
.HL 2 LSL__INIT
.INDEX LSL__INIT
.INDEX Initialisation
.NOFILL

	call LSL__INIT( [timer] )

.FILL
This routine initialises the library LSLLIB. If the argument timer
is true or absent, then an exit handler is set up which will cause 
timing statistics to be output by the program when it exits.

.TP 6
.HL 2 FRT__GRAPH__INIT
.INDEX FRT__GRAPH__INIT
.INDEX Initialisation
.NOFILL

	call FRT__GRAPH__INIT

.FILL
This routine (in LSLFRTLIB.OLB, but not FRTSHR.EXE) may be called as
a convenient method of setting the addresses of the nineteen graphics
routines in common SRIVEC. These must be set before attempting to
perform any graphics. FRT__GRAPH__INIT loads the addresses of a set
of routines with the default names (e.g_. SRIGPL) which are also
contained in LSLFRTLIB.OLB.

.TP 6
.HL 2 ^&FRTINI\&
.INDEX FRTINI
.INDEX Initialisation
.NOFILL

	failed = FRTINI(frtfile)
eg
	IF (FRTINI('LSL$FRT:FRT.FRT')) THEN failed to read file

.FILL
This routine MUST be called before any other FRT library routines.
It opens the given file and obeys the commands within it to set up the
FRT, SCT, priority, pattern, area fill, group and ACD common blocks.
.NOTE
The ACD common block is filled with the LSL default values, even if there
are no ACD entries in the FRT file.
.BL 2
This is similar to having the following ACD commands in the file
.NOFILL

	ACD I  1 Secondary__FC     0           32767      
	ACD I  2 Contour         -2147483647 2147483647

	ACD R  3 Height          -1.0E37     1.0E37
	ACD I  4 LH__boundary       0           32767 
	ACD I  5 RH__boundary       0           32767 
	ACD I  6 Text              0           32767 
	ACD I  7 DFAD__FADT         0           0
	ACD I  8 DFAD__ACC          0           0
	ACD I  9 Parent__FSN        0           65535
	ACD I 10 RELHT__START       0           100
	ACD I 11 RELHT__END         0           100
	ACD R 80 Cliff__left        -1.0E37     +1.0E37
	ACD R 81 Cliff__right       -1.0E37     +1.0E37
	ACD R 82 Polygon__info      -1.0E37     +1.0E37
	ACD R 91 X                 -1.0E37     +1.0E37
	ACD R 92 Y                 -1.0E37     +1.0E37
	ACD R 93 Z                 -1.0E37     +1.0E37
	ACD R 94 ZB                -1.0E37     +1.0E37
	ACD R 95 ZC                -1.0E37     +1.0E37
	ACD R 96 ZD                -1.0E37     +1.0E37
	ACD R 97 Dheight           -1.0E37     +1.0E37
.FILL

.BLANK 2
After a FRT file has been read with this command the variables
PRIO__MAX and PRIO__DEFAULT are set in the common block
LSL$CMNFRT:FRTPRIO.CMN. PRIO__MAX is the highest priority that has
been set with PRIORITY records in the FRT file. It does not include
PRIO__DEFAULT, which is the priority to be associated with all feature
codes that do not occur in PRIORITY records.
.END NOTE

.TP 6
.HL 2 ^&FRTFND\&
.INDEX FRTFND
.NOFILL

	failed = FRTFND(fc,[output__error])
eg
	IF (FRTFND(23)) THEN failed to find Feature Code 23

.FILL
This routine is called to find the representation of a given feature
code. It sets up variables in COMMON/FRTCOM/.  If the
optional argument "output__error" is .FALSE_. then the error
message which would normally be output when "fc" is not found in the FRT
table is suppressed.

.TP 6
.HL 2 ^&PATFND\&
.INDEX PATFND
.NOFILL

	failed = PATFND(patno)
eg
	IF (PATFND(12)) THEN failed to find pattern 12

.FILL
This routine is called to find the definition of a given pattern.
It sets up variables in COMMON/FRTPAT/.

.TP 6
.HL 2 ^&FILFND\&
.INDEX FILFND
.NOFILL

	failed = FILFND(filno)
eg
	IF (FILFND(-4)) THEN failed to find area fill pattern -4

.FILL
This routine is called to find the definition of a given area fill
pattern. It sets up variables in COMMON/FRTFIL/. 

.TP 6
.HL 2 ^&FRTFGT\&
.INDEX FRTFGT
.NOFILL

	failed = FRTFGT(gt,fc)
eg
	IF (FRTFGT(10,FC)) THEN failed to find graphical type 10

.FILL
This routine is called to return in FC the first feature code in the
FRT with graphical type GT.

.TP 6
.HL 2 FRT__ACDINI
.INDEX FRT__ACDINI
.INDEX Initialisation
.NOFILL

	failed = FRT__ACDINI()

eg
	IF (FRT__ACDINI()) THEN failed

.FILL
This routine must be called before any other ACD library routines, if
FRTINI has not been called. It makes the default set of attribute code
definitions (see above) available to ACDFND and ACDFND__NAME. 
.BL
Note that this routine is called by FRTINI, so if it is called after
FRTINI then any ACD definitions contained in the FRT file will be lost. 

.TP 6
.HL 2 ^&ACDFND\&
.INDEX ACDFND
.NOFILL

	failed = ACDFND(code,[output__error])
eg
	IF (ACDFND(23),.TRUE.) THEN failed to find Attribute Code 23

.FILL
This routine is called to find the given code in the attribute code
definition table. It sets up variables in COMMON/FRTACD/. If the
optional argument "output__error" is .TRUE_. (default) then an error
message is output when "code" is not found in the ACD table. 
.BL
If "code" is not found, the common block is filled in with default
values, assuming an integer or real attribute data type, depending on
the result of a call of the IFFLIB routine IS__REAL__AC(code). 
.BR
The following values are set:-
.NOFILL

	ACD__CODE          = -1
	ACD__NAME          = '?'
	ACD__NAME_LEN      =  1

	ACD__DATA__TYPE    = 1 or 2

	ACD__MIN__MAX__xx  is set to the relevant default value

.FILL

.HL 2 ^&ACDFND__NAME\&
.INDEX ACDFND__NAME
.NOFILL

	failed = ACDFND__NAME(name,[ret])

	where ret is an optional integer argument which receives any
	error code returned by LSLLIB. If it is absent then the
	corresponding error message is output; when present ACDFND__NAME
	does not output any error messages.
eg
	IF (ACDFND__NAME(HEIGHT)) THEN failed to find HEIGHT

.FILL
This routine is called to find the representation of a given attribute,
where the name of the attribute is known. 
.BR
If successful, this routine sets up the variables in COMMON/FRTACD/.
.BR
If the routine fails, then the variables in the common block are not
altered.

.TP 6
.HL 2 ^&SRIINI\&
.INDEX SRIINI
.INDEX Initialisation
.NOFILL

	failed = SRIINI(srifile,[hwsym],[hwcir],[hwpat],[hwlns],[hwcur])

	the optional arguments are used if hardware symbols, circles,
	patterns, line styles, and curves respectively are to be used
	by the plotting routines. If required, they should be set to _.TRUE_.
	(or in the case to hwlns to the number of line styles available).

eg
	IF (SRIINI('LSL$FRT:SRI.SRI',.FALSE.)) THEN failed to read file

.FILL
This routine must be called before any other SRI library routines.
It opens the given file and reads it to set up the Symbol Representation Index 
in the FRTSRI common block.

.TP 6
.HL 2 ^&SRIFND\&
.INDEX SRIFND
.NOFILL

	failed = SRIFND(sc)
eg
	IF (SRIFND(23)) THEN failed to find symbol 23

.FILL
This routine is called to find the representation of a given symbol.
It sets up variables in COMMON/FRTSRI/

.TP 6
.HL 2 ^&SRICOL\&
.INDEX SRICOL
.NOFILL

	failed = SRICOL(icol)
eg
	IF (SRICOL(7)) THEN failed to set symbol colour index 7

.FILL
This routine is called to set the colour to be used for all successive symbols
(including texts). This does not affect the current polyline and fill area
colour indices in use by the calling program. If the integer argument, ICOL, is
negative, or if SRICOL is not called at all, then the colours specified in the
FRT or SCT entries will be used in plotting texts and symbols. 


.TP 6
.HL 2 ^&SRIPLT\&
.INDEX SRIPLT
.NOFILL

	failed = SRIPLT(sc,x,y,size,angle,[hwsym],[stretch])

	hwsym is an optional logical argument (default .FALSE.) which
	should be .TRUE. when a symbol from the hardware's library
	is to be plotted, rather than a symbol from the SRI.

	stretch is an optional real argument (default 1.0) which specifies
	a stretching factor in the X direction (before rotation). It is
	mainly intended for internal use within the pattern drawing
	routines.
 
eg
	IF (SRIPLT(23,5.0,9.0,12.0,0.5)) THEN failed to plot symbol 23

.FILL
This routine is called to plot a given symbol at a given X,Y position
at a given size and angle.
.BL
If plotting on a 3 dimensional device, this routine should be preceded
by a call to SRI__SET__Z (q_.v_.)

.TP 6
.HL 2 ^&SRISCN\&
.INDEX SRISCN
.NOFILL

	failed = SRISCN(sc,xmin,xmax,ymin,ymax)
eg
	IF (SRISCN(23,XMIN,XMAX,YMIN,YMAX)) THEN failed to scan symbol 23

.FILL
This routine is called to scan a given symbol and return its maximum
extents from the defining point if plotted at size 1.0.

.TP 6
.HL 2 ^&SRISLW - set line width\&
.INDEX SRISLW
.NOFILL

	failed = SRISLW(width)
eg
	IF (SRISLW(WIDTH)) THEN failed to set width (WIDTH.LE.0.0)

.FILL
This routine is called to inform FRTLIB of the nominal linewidth
of the graphics workstation. It must be used if thick lines are
to be plotted correctly. The real argument, WIDTH, is the number
of width units in the FRT file to correspond to the device
nominal linewidth. WIDTH must be greater than zero.

.TP 6
.HL 2 ^&SRIUNI - pass plotting information to FRTLIB\&
.INDEX SRIUNI
.NOFILL

	failed = SRIUNI(units[,scl][,angle][,enluni])

	where units  - ratio of plotter units (mm) to world units
		       such that world__units * units = plotter__units

	      scl    - ratio between FRT units (mm) and world units
		       such that FRT__units * scl = world__units
		       (default 1)

	      angle  - angle (in radians) that coordinates have been
		       rotated by the calling program, before passing
		       them to FRTLIB

	      enluni - ratio between final plotter units after any enlargement
		       of reduction (mm) and world units such that
		       world__units * enluni = final__plotter__units
		       (default same as units above)

eg
	IF (SRIUNI(UNITS)) THEN failed to set units (UNITS.LE.0.0)

.FILL
This routine should be called after FRTINI and before any plotting is
done. 
.B
The first argument is used to set the correct thickness and spacing of
hatch lines in hatched areas in symbols and texts, and also to adjust
the number of interpolated points per unit in circle arcs and curves unless
overridden by the fourth argument. The default is appropriate for a drawing
scale such that one unit corresponds to one millimetre. If, for
instance, one world unit corresponds to one centimetre on the plot, then
a call to SRIUNI(10.0) should be made.
.B
The second argument is used to convert sizes specified in sheet mm in the FRT
(e_.g_. pattern sizes) to world coordinates.
.B
The third argument is used to ensure that substituted symbols in
patterned lines are drawn at the correct orientation, and also to rotate
the hatch lines in pattern filled areas.
.B
If no enlarging or reducing of the plots is being done, then this is the same
as the first argument, but otherwise it is used to adjust the tolerances for
circles and curves in the final plot.

.TP 6
.HL 2 ^&SRI__BOUND - return the boundary of a symbol\&
.INDEX SRI_BOUND
.NOFILL

 	failed = SRI__BOUND(symno,npts,xy,border,bound_type)

	INTEGER		symno		- the number number
 	INTEGER		npts		- input, size of xy array
					  output, number of points in xy
 	REAL		xy(2,npts)	- output array
 	REAL		border		- border as proportion of height
 	INTEGER         bound__type	- type of bounding polygon
eg
	IF (SRI__BOUND(23,npts,xy,0.35,3)) THEN failed

.FILL
This routine is used to calculate a suitable boundary around a symbol.
It must be passed an array in which to return the points. Three types
of boundary may be specified by argument bound__type.
.BL
1 - a box produced by calling SRISCN. This only looks at the defining points
of the symbol, so might not produce accurate results for symbols which
include circle arcs or curves.
.BL
2 - a box produced by going through the motions of drawing the symbol and
taking the bounding box of the resulting points. This takes proper account
of circle arcs and curves.
.BL
3 - same as 2, but a convex hull around the set of points is calculated.
The convex hull is the shape you would get if you pulled tight a length
of string around the points.

.TP 6
.HL 2 ^&SRI__OFFSET__POLYGON - offset a polygon\&
.INDEX SRI__OFFSET__POLYGON
.NOFILL

 	call SRI__OFFSET__POLYGON( maxpoints, points, npoints, dist )

 	INTEGER		maxpoints	- Max. size of offset polygon
 	REAL	points(2,maxpoints)	- Input polygon/offset polygon
 	INTEGER		npoints		- Actual size offset polygon
 	REAL		dist		- Offset distance

.FILL
This is a convenience routine used to offset a polygon. The polygon
is expected to be anti-clockwise, in which case a positive distance
offsets outwards. The polygon os expected to be open.

.TP 6
.HL 2 ^&SRI__SET__Z - pass height to FRTLIB\&
.INDEX SRI_SET_Z
.NOFILL

	CALL SRI__SET__Z(height)

		REAL   height

.FILL
.BL
This routine should be called before plotting a text or symbol with 
TRITXT, TRIPLT or SRIPLT. Texts and symbols will then be plotted 
horizontally at the specified height.
.BL
It should also be called before plotting a patterned fill area with
FILLGFA. The fill area will then be plotted horizontally at the 
specified height.

.TP 6
.HL 2 ^&TRIINI\&
.INDEX TRIINI
.INDEX Initialisation
.NOFILL

	failed = TRIINI(trifile)
eg
	IF (TRIINI('LSL$FRT:TRI.TRI')) THEN failed to read file

.FILL
This routine must be called before any other TRI library routines.
It opens the given file and reads it to set up the Text Representation Index 
in the FRTTRI common block.

.TP 6
.HL 2 ^&TRIFND\&
.INDEX TRIFND
.NOFILL

	failed = TRIFND(charno,font)
eg
	IF (TRIFND(65,1)) THEN failed to find character 65 ('A')

.FILL
This routine is called to find the representation of a given character.
it sets up variables in COMMON/FRTTRI/

.TP 6
.HL 2 ^&TRIPLT\&
.INDEX TRIPLT
.NOFILL

	failed = TRIPLT(charno,font,x,y,size,angle[,hwtxt])
eg
	IF (TRIPLT(65,1,5.0,9.0,12.0,0.5)) THEN failed to plot character 65

.FILL
This routine is normally called to plot a given character at a given X,Y 
position at a given size and angle.
.B
If the optional hwtxt argument is .TRUE_., then the text will be plotted
using hardware (via routine SRIGTX), and without reference to the TRI table.
.B
If a text graphical type has been set up in FRTCOM, and FRTSC is
negative, then the character will be plotted in italic style. 
.B
The routine can also be used to find the coordinate extent of a
character, instead of plotting it. Additional arguments are passed or
returned via the common block TRIEXT. Operation in this mode can be
switched on by setting the variable GET__EXTENT true, and the extents
are returned in MIN__X__EXT, MAX__X__EXT, MIN__Y__EXT and MAX__Y__EXT.
In order to maintain compatibility with previous versions of the library
and to ensure that subsequent calls to TRIPLT result in plotting,
GET__EXTENT should be reset to false when the required extents have been
obtained. The coordinate extents can be returned in IFF units or TRI
units; for the latter, a suitable call would be 

.NOFILL

	IF (TRIPLT(65,1,0.0,0.0,1.0,0.0)) THEN 
	   failed to find extent of character 65

.FILL
.BL
If plotting on a 3 dimensional device, this routine should be preceded
by a call to SRI__SET__Z (q_.v_.)

.TP 6
.HL 2 ^&TRITXT\&
.INDEX TRITXT
.NOFILL

	failed = TRITXT(charstring,font,x,y,size,angle[,hwtxt])
eg
	IF (TRITXT('Rhubarb and Custard',1,5.0,9.0,12.0,0.5)) THEN failed

.FILL
This routine is called to plot a text string at a given X,Y position at
a given size and angle. It calls TRIPLT for each character, dealing with
escape character sequences such as '$A', and applying variable character
spacing using the widths read from the width AC entries in the TRI file.
.B
If the optional hwtxt argument is .TRUE_., then the text will be plotted
using hardware (via routine SRIGTX), and without reference to the TRI table.
.B
If hwtxt is .FALSE_. (or absent), and handling of composite characters is
enabled (by defining logical name LSL$COMPOSITE__CHARACTERS as 1), then
any composite characters in the string (e.g_. {Zcaron}) will be replaced
by their first character (Z in this case).
.BL
If plotting on a 3 dimensional device, this routine should be preceded
by a call to SRI__SET__Z (q_.v_.)

.TP 6
.HL 2 ^&TRISCN\&
.INDEX TRISCN
.NOFILL

	failed = TRISCN(charstring,font,width[,hwtxt])
eg
	IF (TRISCN('Rhubarb and Custard',1,WIDTH)) THEN failed

.FILL
This routine is called to scan a text string, returning the width of the
string if plotted at size 1.0. It adds the widths of each character
as read from the width AC entries in the TRI file, and deals with escape
character sequences such as '$A'.
.B
If the optional hwtxt argument is .TRUE_., then an attempt will be made to
obtain the proper width of the hardware text (via routine SRI__STRING__WIDTH),
without reference to the TRI table. If SRI__STRING__WIDTH returns .TRUE_., then
the width will be obtained from the TRI file as usual.
.B
If hwtxt is .FALSE_. (or absent), and handling of composite characters is
enabled (by defining logical name LSL$COMPOSITE__CHARACTERS as 1), then
any composite characters in the string (e.g_. {Zcaron}) will be replaced
by their first character (Z in this case) for the purpose of calculating
the width.

.TP 6
.HL 2 ^&TRI__BOUND\&
.INDEX TRI__BOUND
.NOFILL

	failed = TRI__BOUND(charstring,font,ncoord,xycoord,border[,hwtxt])

	CHARACTER*(*)	charstring	- character string
	INTEGER*2	font		- text font
	INTEGER*4	ncoord		- passed as the max. possible number of 
					  coordinates in xycoord, returned as 
					  the actual number forming the border
	REAL		xycoord(ncoord) - x and y coordinates of border
	REAL		border		- proportion of height by which 
					  boundary should be expanded beyond 
					  text limits
	LOGICAL		hwtxt		- use hardware text if possible
eg
	IF (TRI__BOUND('Parker''s Piece',1,n,xy,0.35)) THEN failed

.FILL
This routine is called to find the bounding coordinates of a text string, in 
TRI units with respect to the locating point of the first character.
.B
If the optional hwtxt argument is .TRUE_., then an attempt will be made to
obtain the bounds for hardware text (via routine SRI__STRING__BOUNDS),
without reference to the TRI table. If SRI__STRING__BOUNDS returns .TRUE_., then
the bounds will be obtained from the TRI file.
.B
If hwtxt is .FALSE_. (or absent), then it calls TRIPLT for each character,
dealing with escape character sequences such as '$A', and applying variable
character spacing using the widths read from the width AC entries in the TRI
file. The border argument should be less than 1.0 (the maximum height in TRI
units),  and unexpected results may occur if it is greater than the average
character  width.

.TP 6
.HL 2 ^&PATGPL\&
.INDEX PATGPL
.NOFILL

	SUBROUTINE PATGPL(ncoord,xcoord,ycoord[,zcoord])

		INTEGER ncoord		- number of points
		REAL	xcoord(ncoord)  - x coordinates
		REAL	ycoord(ncoord)	- y coordinates
		REAL	zcoord(ncoord)	- z coordinates
eg
	CALL PATGPL(27,X,Y)

.FILL
This routine draws the line connecting the specified points in the
current >pattern (set by a call of PATSET (q_.v_.)).
.BL
It does this by making calls to SRIPLT and SRIGPL. If the optional
4th argument is present, it precedes calls to SRIPLT by a call to
SRI__SET__Z.
.NOTE ^&IMPORTANT NOTE\&
If PATGPL is called with the optional 4th argument, then a replacement
routine SRIGPL with 4 arguments ^&must\& be supplied. Failure to do this
may cause an access violation within PATGPL. 
.END NOTE
.B
If a substituted symbol fails to plot, then this can be detected by a
call of PATERR (q_.v_.) 

.TP 6
.HL 2 ^&PATSET\&
.INDEX PATSET
.NOFILL

	failed = PATSET(patno,[hwp])

eg
	if (PATSET(12)) THEN failed to find pattern 12

.FILL
This routine sets up the pattern to be used for drawing a linear feature,
after FRTCOM has been set up by a call of FRTFND. The argument passed will 
normally be FRTSC from FRTCOM.
.B
The optional integer argument hwp is used to return a line-type for a
hardware pattern. For a hardware pattern to be used, the hwpat argument
to SRIINI must be .TRUE., the pattern itself must specify the hardware
flag and must not contain substituted symbols, and the hwp argument
must be present. If hwp is returned as non-zero, then it should be
passed on to GKS routine GSLN (set line-type), and the line drawn using
GPL - it will then be patterned using hardware.
.B
It fails if it cannot find the pattern, in which case subsequent calls
of PATGPL will draw the line as a solid line. Failure to find a symbol
to substitute does not constitute a failure, but this state can be detected
by a call of PATERR (q_.v_.)
.B
It should be called whenever a pattern is to be started, i_.e_. before
drawing a new feature (even with the same pattern as the last one) and
after an invisible part of a feature.

.TP 6
.HL 2 ^&PATACT\&
.INDEX PATACT
.NOFILL

	failed = PATACT(onoff)

eg
	if (PATACT(.FALSE.)) THEN failed deactivate pattern output

.FILL
This routine turns on or off subsequent output from PATGPL. It may be used
to turn off pattern output while an invisible section of a feature is drawn.
PATGPL will maintain the phase of the pattern while not producing any output.

.TP 6
.HL 2 ^&PATERR\&
.INDEX PATERR
.NOFILL

	SUBROUTINE PATERR(OK,SYM,PATT)

	returns	LOGICAL OK(2)	- .FALSE. if major/minor symbol
				  has been suppressed
		INTEGER	SYM(2)  - number of major/minor symbol
		INTEGER	PATT	- pattern number

eg
	CALL PATERR(OK,SYM,PATT)

.FILL
This routine is called after calls to PATSET and PATGPL to find out
if there have been problems finding or drawing substituted symbols

.TP 6
.HL 2 ^&FILLGFA\&
.INDEX FILLGFA
.NOFILL

	SUBROUTINE FILLGFA(ncoord,xcoord,ycoord)

		INTEGER ncoord		- number of points
		REAL	xcoord(ncoord)  - x coordinates
		REAL	ycoord(ncoord)	- y coordinates

eg
	CALL FILLGFA(14,X,Y)

.FILL
This routine fills the area defined by the specified points with the
current area fill pattern (set by a call of FILFND (q.v.)). 
.BL
If plotting on a 3 dimensional device, this routine should be preceded
by a call to SRI__SET__Z (q_.v_.)
.BL
If there is a requirement that some segments of the boundary of the area
are not drawn, then routines FRT__BEGIN__FILL and FRT__END__FILL may be
used to bracket a series of calls to FILLGFA. The boundary line (assuming
that the fill specifies a boundary) will only connect the points in each
individual call to FILLGFA. A closing line will be drawn from the last point of
the last call to FILLGFA to the first point of the first. All the points from
all calls to FILLGFA will be used to define the area.

.TP 6
.HL 2 ^&FRT__BEGIN__FILL\&
.INDEX FRT__BEGIN__FILL
.NOFILL

	SUBROUTINE FRT__BEGIN__FILL

eg
	CALL FRT__BEGIN__FILL

.FILL
Specifies the beginning of a composite area (a series of calls to FILLGFA
q.v.). A matching call to FRT__END__FILL must be used after the calls to
FILLGFA to cause the area to be drawn.

.TP 6
.HL 2 ^&FRT__END__FILL\&
.INDEX FRT__END__FILL
.NOFILL

	SUBROUTINE FRT__END__FILL

eg
	CALL FRT__END__FILL

.FILL
Specifies the end of a composite area. The area is filled.

.TP 6
.HL 2 ^&GRPFCT\&
.INDEX GRPFCT
.NOFILL

	GBITS = GRPFCT(i,grpnum)

	INTEGER		i		- element of group bitmap
	INTEGER		grpnum		- group number

eg
	GBITS = GRPFCT(2,5) gets bits for feature codes 32-63 in group 5

.FILL
This routine is used to access the group bitmaps pointed to by the variables in
FRTGRP.CMN. It returns in a 32-bit (INTEGER_*4) variable the bits corresponding
to 32 consecutive feature codes in a given group (group numbers are allocated
starting at 1 for the first group in the FRT). Element 0 contains feature codes
0-31, 2 contains 32-63, up to 1024 which contains 32736-32767. The function can
be used (with certain limitations) as a replacement for the array GRPFCT, which
appeared in previous releases of the library.

.TP 6
.HL 2 ^&GRPFC\&
.INDEX GRPFC
.NOFILL

	ingrp = GRPFC(fc,grpnum)

	INTEGER		fc		- feature code
	INTEGER		grpnum		- group number

eg
	INGRP = GRPFC(2,5) returns _.TRUE._ if FC 2 in in group 5

.FILL
This logical functions returns _.TRUE._ if the specified feature code is
in the given group.


.TP 6
.HL 2 ^&FRTPRIOFND\&
.INDEX FRTPRIOFND
.NOFILL

	failed = FRTPRIOFND(fc)
eg
	IF (FRTPRIOFND(12)) THEN failed to set variables in common block

.FILL
This routine is called to find the way to draw a feature with a
specified feature code if using multi-pass prioritised drawing.

It sets up variables in COMMON/FRTPRIO/ as follows:
.LIST 'o'
.LE;PRIO__SEL is set to the feature code that it was called with
.LE;PRIO__NUMBER is set to the number of priority/representation pairs
that were defined for PRIO__SEL. If none were defined then PRIO__NUMBER
is set to 0, and the feature should be drawn using the representation for
its own feature code at the default priority (PRIO__DEFAULT).
.LE;The first PRIO__NUMBER elements of the array PRIO__PRIO contains the
priorities of the representations defined for PRIO__SEL.
.LE;The first PRIO__NUMBER elements of the array PRIO__REP contains the
representations defined for PRIO__SEL.
.END LIST

.TP 6
.HL 2 ^&PRIOPRIO\&
.INDEX PRIOPRIO
.NOFILL

	exists = PRIOPRIO(priority)

	INTEGER		priority

eg
	exists = PRIOPRIO(2) returns _.TRUE._ if there is a priority
        record that defines a representation  at priority 2.

.FILL
This logical functions returns _.TRUE._ if the specified priority is
defined in the priority table.

.PG
.REQUIRE 'FRTLIB.RNX'
