.!
.! This is the runoff document for the LITES2 user's guide. It is not
.! currently envisaged that any sub-documents will be REQUIREd
.! Use the command file [-]RNO to run this document off
.!

.!** Qume page format
.LEFT MARGIN  0
.RIGHT MARGIN 80
.PAGE SIZE    60,80
.NO AUTOSUBTITLE
.NO PERIOD
.ENABLE INDEXING
.XLOWER
.FLAGS BREAK
.FLAGS CAPITAL
.FLAGS INDEX
.FLAGS BOLD
.KEEP

.!** title page
.FIGURE 14
.CENTRE ;^&Laser-Scan Ltd.\& 
.FIGURE 2
.CENTRE ;^&LITES2\&
.BLANK
.CENTRE ;^&Cartographic Editing System\&
.BLANK
.CENTRE ;^&User's Guide\&
.FIGURE 2
.CENTRE ;^&Issue 3.0 - 06-Mar-1986\&

.FOOT
.FLAGS SUBSTITUTE
.NOFILL
Copyright (C) $$year Laser-Scan Ltd
Science Park, Milton Road, Cambridge, England CB4 4FY  tel: +44 (0) 1223 420414

Document "LITES2 User"				Category "USER"
Document Issue 1.0	R J Hulme		18-Feb-1985
Document Issue 2.0	R J Hulme		07-Mar-1985
Document Issue 3.0	R J Hulme		06-Mar-1986
.FILL
.END FOOT
.NOFLAGS SUBSTITUTE


.!******************** Contents **************
.TITLE LITES2 User's Guide
.SUBTITLE Contents
.DISPLAY NUMBER RL
.PAGE
.REQUIRE	"USER.RNT"


.!******************** Main Body *************
.DISPLAY NUMBER D
.PAGE



.CHAPTER ^&Introduction\&
.TITLE LITES2 User's Guide
.SUBTITLE Introduction

.HL 1 ^^^&Intended Audience\&
.INDEX Audience

.P 0
This manual is intended as the introductory guide to the use of the Laser-Scan
Cartographic Editor LITES2.
It describes the basic operations required to run the program, initialise it, 
read in and draw map data, make some edits, and finally preserve the edited 
data in a new file. 
It is assumed that users are already familiar with general use of the equipment
and the DEC 
.INDEX DEC
(Digital Equipment Corporation) VAX/VMS operating system, and with the 
principles of digital cartography.

.P 0
For a more detailed description of particular commands, and for a description 
of many commands which are not used in a simple editing session, you should 
consult the "LITES2 Reference Manual". 
.INDEX LITES2 Reference Manual
Note that the reference manual assumes 
that you are already familiar with the contents of this document.

.HL 1 ^^^&Use of this Manual\&
.INDEX Use of this manual

.P 0
Chapter 1 is devoted to background information, and introduces users to the 
concepts involved, as well as providing a broad description of some of the 
facilities available. It is advisable to read through this chapter before 
starting a LITES2 editing session.

.P 0
The remaining chapters take you through a simple editing session, and
the easiest way to learn about LITES2 is to follow these instructions 
at a LITES2 workstation. Your site will probably have an example data file, 
which may be used as the input map for this purpose. 

.P 0
In this manual the commands you have to give are printed in bold block
capitals, and are separated from the rest of the text for easy reference. 
Sequences of commands separated by slashes ( / ) mean that any number of those
commands can be used, in any order. 

.HL 1 ^^^&Program Description\&
.INDEX Program description
.INDEX Description of program

.P 0
LITES2,
.INDEX LITES2
the Laser-scan (second generation) InTeractive Editing System,
is an interactive graphical editing program which has been designed to
be particularly suitable for work with cartographic type data.
It can, however, be used on other types of feature-orientated data, and there 
are facilities for reading,
drawing, amending, creating, and deleting features. The program is a 
reimplementation of the previous LSL (Laser-Scan) cartographic 
editor LITES1 
.INDEX LITES1
(also variously known as LITES, 
.INDEX LITES
MADES, 
.INDEX MADES
IGES or 
.INDEX IGES
SOLADI)
.INDEX SOLADI

.HL 1 ^^^&Environment\&
.INDEX Environment

.P 0
LITES2 will run on a DEC VAX 
.INDEX VAX
series computer running under the VMS 
.INDEX VMS
operating system, and can be used without graphic interaction on any 
DEC-compatible terminal. For graphic interaction an LSL-supported GKS 
.INDEX GKS
(Graphical Kernel System) 
workstation configuration is required. A typical example might include an 
alphanumeric terminal, a graphics screen and a digitising table.

.P 0
LITES2 needs to read various files
of information in order to operate, and these, together with its data files
are located by means of standard 'logical names'. These
have to be set up by the system manager, and the operator should not have to
be concerned with them.  They are usually set up in a central standard login 
command file, together with definitions of the command abbreviations required 
to run the program.

.HL 1 ^^^&Input Data\&
.INDEX Input data
.INDEX Map data
.INDEX Digital map data
.INDEX Data

.P 0
LITES2 is used to display and edit map data which is contained in IFF 
(Internal Feature Format) files. 
.INDEX IFF files
(IFF is the standard Laser-Scan format for map data.) Each IFF file contains a
single map, and data within a map may be grouped into layers 
.INDEX Layers
(sometimes known as overlays).
The basic elements of map data are called features, 
.INDEX Features
and the editor deals with
a total of twelve different categories or graphical types of features. For the
purposes of feature identification in LITES2 these are divided into four 
groups, namely lines, circles, texts and symbols. Further details of feature 
representation can be found in the "Introductory Guide to Feature 
Representation on Laser-Scan Display and Plotting Devices",
.INDEX FRT Guide
and in the "FRTLIB Reference Manual".
.INDEX FRTLIB Reference Manual

.HL 1 ^^^&Feature Selection\&
.INDEX Feature selection
.INDEX Selection of features

.P 0
Two fundamental concepts of the editor are those of the found-feature
.INDEX Found-feature
and the feature-in-hand. 
.INDEX Feature-in-hand
The found-feature
is a feature selected by the operator to be the subject of editor operations.
When an editing command is given, any found-feature becomes the
feature-in-hand in order that a second feature
can be found if needed for the editing operation.
The current found-feature, and feature-in-hand, if any, are highlighted
in refresh mode on the display screen.

.HL 1 ^^^&Command States\&
.INDEX Command states
.INDEX States

.P 0
LITES2 always operates in one or other of
a small number of command states. Within each state, a given range of commands
is valid 
.INDEX Commands >validity
and certain commands or operator actions cause the program to move between 
states. 
.INDEX States >entering
Some commands are valid in all states, while others 
are limited to only a few states. The states are listed below -

.LIST "*"
.LE
INITIAL state is entered at the start of a session, and it is in this state 
that things like options, menus, attribute files and data files are specified.

.LE
READY state is the principal operating level of the editor, and the
majority of commands are available in this state

.LE
LINE state is entered when the found-feature is linear

.LE
CIRCLE state is entered when the found-feature is circular

.LE
TEXT state is entered when the found-feature is a text

.LE
SYMBOL state is entered when the found-feature is a symbol

.LE
EDIT state is entered when complex editing operations are performed on linear 
or circular features

.LE
MODIFY state is entered when complex editing operations are performed on text
or symbol features

.LE
ON state is entered by commands which result in the cursor being constrained 
on a linear or circular feature

.LE
CONSTRUCT state is entered when a new linear or circular feature or part 
feature is being digitised

.LE
RECOVER state is entered when the found-feature is a deleted feature

.LE
WINDOW state is entered during definition of an area of map to be enlarged
onto the graphics screen. 

.LE
MACRO state is entered while defining macro commands.

.LE
AC state is entered to allow editing of ancillary coding

.END LIST

.HL 1 ^^^&Command Language\&
.INDEX Commands

.P 0
A primitive command in LITES2 consists of at least a primary command, 
.INDEX Primary commands 
followed in some cases by one of several secondary commands.
.INDEX Secondary commands 
The primary command, with its secondary command if present, may be followed by 
compulsory or optional arguments.
.INDEX Commands >arguments
The number and type of arguments depends on the command, but these 
can be integer numbers, real numbers, text, or a filename.

.P 0
Primary and secondary commands, as well as macros (see below), can be shortened 
to the minimum non-ambiguous 
.INDEX Commands >ambiguity
abbreviation.
.INDEX Commands >abbreviation
They can be given to the program either from the keyboard, 
.INDEX Keyboard commands 
from the menu, 
.INDEX Menu commands
or from any of the digitising table cursor puck buttons.
.INDEX Button commands 
The menu and puck 
buttons are simply quick ways of entering commonly used commands, and you can 
use LITES2 without issuing commands in this way. 

.P 0
Usually commands are terminated by end of line (carriage return), 
.INDEX Commands >terminating
but several commands can be given per line if separated by _# which is treated
as end of line.

.P 0
There are facilities in LITES2 for creating your own commands, called macro
commands,
.INDEX Macro commands
from combinations of primitive commands, @file commands (see below) and other 
macros. Similarly, sequences of frequently used commands can be prepared in 
command files, 
.INDEX Command files
which can be executed by typing @ followed by the filename. 
.INDEX @file command
The commands within the
files can be primitive commands, macros, or @file commands. 

.P 0
It is possible to alter the flow of control within macros or command files by 
means of special commands which allow conditional execution 
.INDEX Commands >conditional execution
and jumps. 
.INDEX Commands >jumps
These commands can be used in conjunction with LITES2 variables, 
.INDEX Variables
which can be either system variables or ones defined by the user.

.P 0
Although it is quite feasible to operate LITES2 using primitive commands alone
(and this is the method employed in this guide), most installations will make 
full use of the facilities provided by the command language which is indeed a 
very powerful editing tool.

.P 0
Full details of the command language facilities are described in the 
"LITES2 Reference Manual"



.CHAPTER ^&Starting a session\&
.TITLE LITES2 User's Guide
.SUBTITLE Starting a Session

.HL 1 ^^^&Running the program\&
.INDEX Running the program

.P 0
In order to run LITES2, you must be logged in to VMS at a terminal. See your 
system manager if you do not have the Username 
.INDEX Username
and Password 
.INDEX Password
required to do this.

.P 0
On systems running on LITES1 workstations, 
.INDEX LITES1 workstation
you may have to run a special
start-up  sequence at the beginning of the day (or after the computer has been 
unavailable). If what you type at the terminal appears on both screens, then 
perform this procedure - it normally requires you to log on as a user "WOSP" 
.INDEX WOSP
or "MADES", 
.INDEX MADES
with no password. This will perform various actions 
(including clearing the graphics screen), and will then log out again.
The system is then ready for your use.

.P 0
At some sites, you will be prompted for what you want to do, and will not have 
to give the actual command to start up LITES2. However, if you are presented 
with the "$" (dollar) prompt, then you can start up the program by typing

.P 10
^*LITES2\*

.P 0
The program will announce itself as 

.P 10
LITES2 V[n] of [hh:mm:ss dd-mmm-yy],

.P 0
where [n] is the version number, and [hh:mm:ss dd-mmm-yy] is the time and 
date of linking of this release. This is followed by a message indicating
the licensed users of this version.

.P 0
There will then be a pause while first stage initialisation is carried out,
normally followed by execution of initialisation command files.
Messages will appear whenever command files are opened or closed, and you
will then be presented with a prompt:

.P 10
_*

.P 0
This is an asterisk by default, but may have been changed during 
initialisation. 

.HL 1 ^^^&Initialisation\&
.INDEX Initialisation

.P 0
INITIAL state is the part of the 
session where you tell the program what maps you want to read in, what
hardware (of that available) you want to use, and generally set up the 
environment within which the rest of the session will be conducted.

.P 0
Some of this work will already have been done for you; each site has 
a standard initialisation command file, which is read in and obeyed by LITES2 
before it gives you that first prompt. This will do things like defining the
commands attached to the puck buttons, setting up the various menus that you 
might use, and specifying options.

.P 0
When you get the first prompt, the program will still be in INITIAL state, and 
you can then give some of your own initialisation commands.
Since you are probably using LITES2 for the first time, try typing the command

.P 10
^*ENABLE LEARNER\*
.INDEX ENABLE command

.P 0
This option causes learner-aid messages 
.INDEX Learner messages
to be output whenever errors occur, in 
addition to the normal error messages. The learner messages usually indicate 
the resulting program action, or give guidance as to what you should do next. 

.P 0
You can cancel options using the DISABLE command.
.INDEX DISABLE command
Try

.P 10
^*DISABLE STATUS\*

.P 0
and

.P 10
^*ENABLE STATUS\*

.P 0
and note what happens to the status line on the terminal screen.

.P 0
Before reading in any data, the program requires the FRT, TRI and SRI files to 
be defined. The necessary commands will probably have been set up for you in a 
command file, so you can simply type

.P 10
^*@EXAMPLE.LCM\*
.INDEX @file command

.P 0
where EXAMPLE.LCM is the command file to be obeyed.

.P 0
The IFF 
.INDEX IFF command
command gives the program the information required for 
reading in the map data. For a single map, simply type

.P 10
^*IFF EXAMPLE.IFF\*

.P 0
where EXAMPLE.IFF is the IFF file. It is possible to read in several maps, and 
to do this you would use the MAPS command
.INDEX MAPS command
followed by an IFF command for each map to be read in. Details can be found in 
the LITES2 Reference Manual.

.HL 1 ^^^&Set Up\&
.INDEX Set up

.P 0
After the last IFF command has been issued, you may be prompted to set up 
your menu(s), map(s), and tracking area, in turn.

.P 0
Whether or not you are prompted to set up menus depends on the number of MENU 
.INDEX MENU command
commands given during initialisation. If a menu is to be set up, you will be 
prompted to digitise each of the four corner points, in the order NW, SW, SE, 
NE.

.P 0
If you have not disabled map setup with the SETUP NONE command, 
.INDEX SETUP command
you will be prompted to digitise the monument 
points on the map or maps attached to the table. 
For example, for a four point setup (SETUP FOUR), 
.INDEX SETUP command
you will be prompted to 
digitise the corner points in the same order as for menus. 
If you have more than one map, you will be prompted to set each one up in the 
order that you requested them.

.P 0
Lastly, you will be prompted to set up a tracking area on the table, if the 
TRACK command 
.INDEX TRACK command
was given during initialisation. Again, the four corner points 
are digitised in the order NW, SW, SE, NE.

.P 0
During set up, the last two buttons on the puck have special meaning.
.INDEX Set up >puck buttons
For example, on a 16 button puck with the following layout:

.LITERAL

	 1	 2	 3	 4

	 5	 6	 7	 8

	 9	10	11	12

	13	14	15	16

.END LITERAL

these would be buttons 15 and 16 (if all 16 buttons are in use as a result 
of the PUCK command).
.INDEX PUCK command

.LIST "*"
.LE
Pressing any button except for the last two (1 to 14 in the example) will 
digitise a corner point or monument point.
.INDEX Set up >digitising

.LE
Pressing the last button (button 16) will abandon the setup of
the current menu, map or tracking area. 
.INDEX Set up >abandoning
This facility is useful if you happen to make a mistake; 
.INDEX Set up >mistakes
the set up can be repeated using the SETUP AGAIN command (see below).
.INDEX SETUP command

.LE
Pressing the last but one button (button 15) will use the values 
(for the current map, menu or tracking area) that were
setup last time LITES2 was run at this workstation. 
.INDEX Set up >repeating
This assumes that

.BLANK
.LIST 0
.LE; the same map, menu or tracking area was used during the last session, 
and was set up
.LE; the map or menu has not been moved since then, and the map 
document has not warped
.END LIST

.P 0
Note that these two items are not checked by LITES2, and rely upon your sense.

.END LIST

.P 0
When the set up has been completed, the map data is read in to the workspace 
files and the graphics are drawn on the screen(s). (The workspace 
files are simply copies of the IFF files.)
A message will appear at the terminal when reading in
has finished, and the program will be in READY state.

.P 0
If you made a major mistake during set up 
.INDEX Set up >mistakes
and abandoned it, you can now repeat the complete set up by typing

.P 10
^*SETUP AGAIN\*
.INDEX SETUP command

.P 0
(which is valid only in READY state). The set up sequence will start again 
from the beginning; remember that you can press button 15 to use the previous 
values for the parts of the set up which were not abandoned.

.P 0
You are now ready to start editing.



.CHAPTER ^&Some Basic Commands\&
.TITLE LITES2 User's Guide
.SUBTITLE Some Basic Commands

.HL 1 ^^^&Command Information\&
.INDEX Commands >information

.P 0
You can get information about commands using the VAX/VMS help facility. 
.INDEX Help facility
Type the command

.P 10
^*HELP\*
.INDEX HELP command

.P 0
to display a list of all of the LITES2 commands. Details of individual
commands can be obtained by typing the HELP command with the command you want 
to know about as a text argument. Try

.P 10
^*HELP ENABLE\*

.P 0
and

.P 10
^*HELP ENABLE STATUS\*

.P 0
In order to find out all the commands available in the current state, type the 
command

.P 10
^*SHOW COMMANDS\*
.INDEX SHOW command

.HL 1 ^^^&Cursor Movement\&
.INDEX Cursor movement
.INDEX Moving the cursor

.P 0
The refresh cursor cross on the screen can be moved in several ways. Type the 
command

.P 10
^*POSITION 100 100\*
.INDEX POSITION command

.P 0
and note the position of the cross. Now move the digitising table cursor puck 
to a new position and press the appropriate button to give the command

.P 10
^*NULL\*
.INDEX NULL command

.P 0
(Although technically incorrect, your cursor button will probably be labelled 
with the command POSITION for this operation; this is for simplicity.)
The screen cross should now appear appear at the corresponding position.

.P 0
The digitising table tracking area corresponds to the area shown on the
screen, although the area defined may be a different size to the screen. If 
you have a tracking area set up, move the cursor puck onto it, and give the 
command

.P 10
^*NULL\*

.P 0
Repeat this on different parts of the tracking area, and note the various 
positions of the cross on the screen.

.HL 1 ^^^&Windowing and Redrawing the Map\&
.INDEX Windowing
.INDEX Redrawing

.P 0
If you wish to scale up a particular part of the map on the screen then the
windowing facility can be used. This is useful if the map is cluttered or
if greater accuracy is required. First
position the cursor over the bottom left hand corner of the 
required window on the digitising table or screen and give the command

.P 10
^*WINDOW\* or ^*WINDOW MAP\*
.INDEX WINDOW command

.P 0
Now position the cursor on the required top right hand corner and give the 
command 

.P 10
^*END\*

.P 0
The scaled up window will then be drawn. 

.P 0
If you wish to scale up part of this window, position the cursor at the bottom
left hand corner of the new window and issue

.P 10
^*WINDOW SCREEN\*
.INDEX WINDOW command

.P 0
Now position the cursor on the top right hand corner, give the command

.P 10
^*END\*

.P 0
and the new window will be drawn. 

.P 0
To redraw the current window after you have done some editing, use the command

.P 10
^*DRAW\* or ^*DRAW SCREEN\*
.INDEX DRAW command

.P 0
If you want the whole map back, use 

.P 10
^*DRAW MAP\*
.INDEX DRAW command



.CHAPTER ^&Simple Feature Operations\&
.TITLE LITES2 User's Guide
.SUBTITLE Simple Feature Operations

.HL 1 ^^^&Identifying a Feature\&
.INDEX Identifying a feature
.INDEX Finding a feature

.P 0
By positioning the refresh cursor cross on a 
feature to be edited and giving the command

.P 10
^*FIND\*
.INDEX FIND command

.P 0
the feature itself is highlighted in refresh. Once a feature has been found in
this manner it is ready to be operated on. If there are many features very 
close together then repeatedly giving the FIND command (without moving
the cursor) will find up to four features in turn. Try finding a few features, 
and note that the editor will move into LINE, 
.INDEX LINE state
CIRCLE, 
.INDEX CIRCLE state
TEXT or 
.INDEX TEXT state
SYMBOL state
.INDEX SYMBOL state
as appropriate.

.HL 1 ^^^&Abandoning an Operation\&
.INDEX Abandoning an operation

.P 0
Find a feature using

.P 10
^*FIND\*

.P 0
then give the command

.P 10
^*ABANDON\*
.INDEX ABANDON command

.P 0
and see what happens.
If you wish to exit from the current state at any time then the ABANDON command
will abort the current operation and return you to READY state.
.INDEX READY state

.HL 1 ^^^&Examining a Feature\&
.INDEX Examining a feature

The various attributes of a feature 
.INDEX Feature attributes
.INDEX Attributes of features
(eg. feature serial number, feature code, size etc) can be examined. First find
a feature using

.P 10
^*FIND\*

.P 0
and then try

.P 10
^*EXAMINE\*

.P 0
This displays a summary of the feature attributes. Note that the program 
remains in the state it was in when the feature was found.

.HL 1 ^^^&Deleting a Feature\&
.INDEX Deleting >line features >whole
.INDEX Deleting >circle features
.INDEX Deleting >text features
.INDEX Deleting >symbol features

.P 0
In order to delete a feature, you first need to find it by positioning the 
cursor over it and giving the command

.P 10
^*FIND\*

.P 0
If the feature is highlighted in refresh then you have 
found it, if not, then you must try again. Now give the command

.P 10
^*DELETE\*
.INDEX DELETE command

.P 0
The feature will be scrubbed out and the editor will return to READY state.

.HL 1 ^^^&Recovering a Feature\&
.INDEX Recovering >line features >whole
.INDEX Recovering >circle features
.INDEX Recovering >text features
.INDEX Recovering >symbol features

.P 0
If you delete a feature by mistake then it is possible to recover it
at any time during the editing session.
First position the cursor over the deleted feature and give the command

.P 10
^*RECOVER\*
.INDEX RECOVER command

.P 0
This command acts in a similar way to FIND, so if the feature does not appear 
refreshed, try again. When you have successfully recovered the feature, the 
program will be in RECOVER state 
.INDEX RECOVER state
and you can give the command

.P 10
^*END\*
.INDEX END command

.P 0
This command is used to complete many types of operation, and in this case it
retrieves the feature, terminates the operation, and takes the program back to 
READY state.

.HL 1 ^^^&Searching for Selected Features\&
.INDEX Identifying a feature
.INDEX Finding a feature
.INDEX Searching for features

.P 0
In addition to FIND, feature identification can be achieved using the
SEARCH command.
.INDEX SEARCH command
SEARCH is like FIND, but is much more powerful in that it can carry out 
global searches rather than the local ones FIND does. Specified features can
be selected for identification, and one of the criteria on 
which identification can be based is the feature code. You will get a list of 
feature codes for various types of feature by giving the command

.P 10
^*SHOW FCS\*
.INDEX SHOW command

.P 0
Now issue the command

.P 10
^*SELECT FCS 49,315\*
.INDEX SELECT command

.P 0
to select all scaled symbols.  You can check these selections using the 
command

.P 10
^*SHOW SELECTIONS\*

.P 0
If you next give the command 

.P 10
^*SEARCH ALL\*
.INDEX SEARCH command

.P 0
the program will start a spiral search from the current cursor position and 
will identify the nearest scaled symbol. Giving the command 

.P 10
^*SEARCH NEXT\*

.P 0
will result in continuation of the spiral search and the next scaled symbol 
will be identified. The SEARCH NEXT command can be repeated 
until all scaled symbols on the map have been identified. To have all features 
selected again, issue

.P 10
^*SELECT ALL\*
.INDEX SELECT command

.P 0
In many of the command sequences in this manual, the FIND command has been 
used to illustrate feature identification; using SEARCH would, of course, be 
equally good. It is also assumed that the appropriate selections have
been made.



.CHAPTER ^&Editing Lines\&
.TITLE LITES2 User's Guide
.SUBTITLE Editing Lines

.HL 1 ^^^&Making Changes to a Feature\&
.INDEX Changing >line features >whole

.P 0
You can change a feature attribute, for example the feature code, by first of
all issuing

.P 10
^*FIND\*

.P 0
on a line feature. The program will now be in LINE state, 
.INDEX LINE state
and you can change the feature code by giving the command

.P 10
^*CHANGE FC n\*
.INDEX CHANGE command

.P 0
where n is the new feature code. After changing the feature code, the program
returns to READY state.
.INDEX READY state
Now find the feature again and use EXAMINE and DRAW to check the changes made.

.P 0
It would become very tedious if you had to 
find the feature every time you wanted to make a change, and so the MODIFY 
command allows multiple changes. First you need to issue

.P 10
^*FIND\*

.P 0
and then give the command

.P 10
^*MODIFY\*
.INDEX MODIFY command

.P 0
Note that the program has entered ON state, 
.INDEX ON state
and also that the cursor is constrained to move only on the feature.
If, for example, you wanted to change the serial number and feature code, you 
would use the commands

.P 10
^*CHANGE FSN n\*
.INDEX CHANGE command
.P 10
^*CHANGE FC n\*

.P 0
where n is the new serial number or feature code. The command

.P 10
^*END\*

.P 0
terminates the operation and takes the editor back to READY state.

.HL 1 ^^^&Moving a Feature\&
.INDEX Moving >line features >whole

.P 0
In order to move a feature to a new position on the map, first give the 
command

.P 10
^*FIND\*

.P 0
followed by the commands

.P 10
^*MODIFY\*
.INDEX MODIFY command
.P 10
^*MOVE\*
.INDEX MOVE command

.P 0
The MOVE command attaches the feature to the cursor, although the feature will
not be drawn in refresh on the screen. The program will now be in  EDIT state,
.INDEX EDIT state
and you can move the feature around before issuing

.P 10
^*END\*

.P 0
to deposit it in its new position. Note that on some displays the feature will
also still be shown in its old position, until the screen is redrawn using 
DRAW. 

.P 0
If the new feature is to have 
different attributes, you can use the CHANGE command as well as MOVE. If, 
however, the CHANGE command is not to be used, as in the sequence above, 
the MODIFY command can be omitted.

.HL 1 ^^^&Copying a Feature\&
.INDEX Copying >line features >whole

.P 0
In order to make a copy of a line feature you must first issue

.P 10
^*FIND\*

.P 0
and then give the command

.P 10
^*COPY\*
.INDEX COPY command

.P 0
This creates a new copy of the feature in its original position. If you want 
to move the copy around, give the command

.P 10
^*MOVE\*
.INDEX MOVE command

.P 0
followed by

.P 10
^*END\*

.P 0
when the feature is in the desired position. The copied feature will then be
drawn in its new position. As with MODIFY, you can use the CHANGE command 
.INDEX CHANGE command
as well as or instead of the MOVE command. In fact, the MODIFY and COPY 
commands are very similar; the former has the effect of 
deleting the original feature, while the latter preserves it.

.HL 1 ^^^&Joining Features\&
.INDEX Joining line features

.P 0
To join two line features together you must first position the cursor over the
end of one of the lines and then issue

.P 10
^*FIND\*

.P 0
You then need to give the command

.P 10
^*JOIN\*
.INDEX JOIN command

.P 0
which puts the program into EDIT state.
.INDEX EDIT state
Now move the cursor to the end of the other feature and issue

.P 10
^*FIND\*

.P 0
again. The cursor will now be attached to the ends of both features, and can 
be moved to the desired position. The operation is terminated by giving the 
command

.P 10
^*END\*

.P 0
By default, only line features with the same feature code can be joined 
together. However, this condition can be altered; if, for example, you want
the feature serial numbers to be the same as well, you can use

.P 10
^*MATCH FSN\*
.INDEX MATCH command

.P 0
before performing the join.

.HL 1 ^^^&Tying Features\&
.INDEX Tying line features
.INDEX Edge matching

.P 0
When edge matching two adjacent maps it is often necessary to tie two ends of
the same feature together (not actually join them but line them up).
This is done by positioning the cursor over one end and giving the command

.P 10
^*FIND\*

.P 0
followed by

.P 10
^*TIE\*
.INDEX TIE command

.P 0
Now position the cursor over the end of the other feature and issue

.P 10
^*FIND\*

.P 0
again. Both ends are now attached to 
the cursor which should be moved to the desired position on the boundary.
The command 

.P 10
^*END\*

.P 0
will record this point and terminate the operation.

.HL 1 ^^^&Closed Loops\&
.INDEX Closed loops

.P 0
Many features need to have their start and end points joined up so as to
form a closed loop. This is done by giving the command

.P 10
^*FIND\*

.P 0
followed by

.P 10
^*LOOP\* or ^*LOOP EXTEND\*
.INDEX LOOP command

.P 0
The former will move the first and last vertices to their mean position, 
and the latter will extend the first and last spans of the feature to a new 
meeting point. The command

.P 10
^*END\*

.P 0
should then be given to deposit the feature.

.HL 1 ^^^&Removing a Data Point\&
.INDEX Removing a data point
.INDEX Data points >removing

.P 0
To remove a single point from within a line feature (eg to smooth out a kink),
first issue

.P 10
^*FIND\*

.P 0
The cursor will jump onto the feature, and you can use the commands

.P 10
^*FIRST\* _/ ^*LAST\* _/ ^*PREVIOUS\* _/ ^*NEXT\* _/ ^*VERTEX n\*
.INDEX FIRST command
.INDEX LAST command
.INDEX PREVIOUS command
.INDEX NEXT command
.INDEX VERTEX command

.P 0
where n is the vertex number,
to put the cursor onto the vertex you want to delete. Now you can delete the 
point using

.P 10
^*REMOVE\*
.INDEX REMOVE command

.P 0
and you will find yourself back in READY state

.HL 1 ^^^&Inserting a Data Point\&
.INDEX Inserting a data point
.INDEX Data Points >inserting

.P 0
To introduce a new point into a line feature you first use

.P 10
^*FIND\*

.P 0
to get the feature into hand. Now you can use the commands

.P 10
^*FIRST\* _/ ^*LAST\* _/ ^*PREVIOUS\* _/ ^*NEXT\* _/ ^*VERTEX n\*

.P 0
to position the cursor onto the vertex next to the new point. Giving the 
commands

.P 10
^*MIDDLE\* _/ ^*FRACTION r\*
.INDEX MIDDLE command
.INDEX FRACTION command

.P 0
where r is he fraction along the span you want the cursor to be,
will position the cursor between vertices. Issuing

.P 10
^*INSERT\*
.INDEX INSERT command

.P 0
creates a new vertex attached to the cursor, which can be moved to the desired 
position. The command

.P 10
^*END\*

.P 0
will terminate the operation and draw the feature with the new point.

.HL 1 ^^^&Editing a Data Point\&
.INDEX Editing a data point
.INDEX Data points >editing

.P 0
In order to reposition a particular point within a line feature you have to
locate the cursor on the point using the command

.P 10
^*FIND\*

.P 0
followed optionally by

.P 10
^*FIRST\* _/ ^*LAST\* _/ ^*PREVIOUS\* _/ ^*NEXT\* _/ ^*VERTEX n\*

.P 0
The command

.P 10
^*EDIT\*
.INDEX EDIT command

.P 0
attaches the current vertex to the cursor, which can be moved around until the 
command

.P 10
^*END\*

.P 0
is given.

.HL 1 ^^^&Deleting Part of a Feature\&
.INDEX Deleting >line features >part

.P 0
In this and the remaining sections of this chapter, the words "position the 
cursor" are highlighted in a similar way to the commands, in order to clarify 
the sequences of operations.

.P 0
In order to delete a section from within a line feature (resulting
in two separate features) you must first issue

.P 10
^*FIND\*

.P 0
Now give the command

.P 10
^*ON\*
.INDEX ON command

.P 0
which constrains the cursor to move only on the feature. Next

.P 10
^*position the cursor\*

.P 0
onto the point at one end of the part to be removed, and give the command

.P 10
^*DELETE PART\*
.INDEX DELETE command

.P 0
Note that the program has entered ON state 
.INDEX ON state
(which is not connected with the ON command). You should now

.P 10
^*position the cursor\*

.P 0
at the other end, and give the command

.P 10
^*END\*

.P 0
to delimit it and 
terminate the operation. The section indicated will be deleted and scrubbed
out. Note that it can be recovered again as for a whole feature,
.INDEX Recovering >line features >part
and will be retrieved as a separate feature.

.HL 1 ^^^&Changing, or Copying and Changing Part of a Feature\&
.INDEX Changing >line features >part
.INDEX Copying >line features >part

.P 0
To change only part of a line feature, find the first end of the part to be 
changed using the sequence of operations

.P 10
^*FIND\*
.P 10
^*ON\*
.P 10
^*position the cursor\*

.P 0
Next issue

.P 10
^*MODIFY PART\* or ^*COPY PART\*
.INDEX MODIFY command
.INDEX COPY command
.P 10
^*CHANGE FSN n\*
.INDEX CHANGE command
.P 10
^*CHANGE FC n\*

.P 0
to make the changes. Now 

.P 10
^*position the cursor\*

.P 0
at the other end of the part to be changed and then issue

.P 10
^*END\*

.P 0
to delimit the part and
terminate the operation. If, having issued MODIFY PART, the CHANGE commands 
were not given,
the effect would simply be to divide the feature into three.

.HL 1 ^^^&Moving, or Copying and Moving Part of a Feature\&
.INDEX Moving >line features >part
.INDEX Copying >line features >part

.P 0
Part of a line feature can be modified or copied and then moved by first 
finding one end of the part to be copied using the sequence of operations

.P 10
^*FIND\*
.P 10
^*ON\*
.P 10
^*position the cursor\*

.P 0
Now issue

.P 10
^*MODIFY PART\* or ^*COPY PART\*
.INDEX MODIFY command
.INDEX COPY command

.P 0
and note that the program is in ON state.
.INDEX ON state
To shift the new feature, first give the command

.P 10
^*MOVE\*
.INDEX MOVE command

.P 0
You then have to 

.P 10
^*position the cursor\*

.P 0
at the other end of the part being modified or
copied, and define the end of the new feature by issuing the command

.P 10
^*END\*

.P 0
The program is now in EDIT state 
.INDEX EDIT state
(as a result of the MOVE command),
the new feature is attached to the cursor, and you can move it to the 
desired position. Giving the command

.P 10
^*END\*

.P 0
a second time will deposit the new feature and terminate the operation. 
As with whole features, you can alter the attributes of the new feature by 
using the CHANGE command along with the MOVE command. When
using MODIFY PART and MOVE, the deleted part of the original feature will 
still be shown on some displays, until the screen is redrawn using DRAW.

.HL 1 ^^^&Extending a Feature\&
.INDEX Extending line features

.P 0
You may wish to extend one end of a line feature in the direction defined
by the last two points. To do this you have to issue

.P 10
^*FIND\*

.P 0
followed optionally by

.P 10
^*FIRST\* _/ ^*LAST\* _/ ^*PREVIOUS\* _/ ^*NEXT\* _/ ^*VERTEX n\*

.P 0
to position the cursor on the end point of the feature. Giving the command

.P 10
^*EXTEND\*
.INDEX EXTEND command

.P 0
will constrain the cursor to move only along the end segment of the feature
and its extensions. The program will now be in EDIT state, 
.INDEX EDIT state
and when the cursor is positioned, the command 

.P 10
^*END\*

.P 0
will terminate the operation.

.HL 1 ^^^&Replacing Part of a Feature\&
.INDEX Replacing part of a line feature

.P 0
It is often necessary
to add a new series of data points to a line and/or remove a series from
a line, without splitting the line into two features. First issue

.P 10
^*FIND\*

.P 0
followed by

.P 10
^*ON\*

.P 0
and then

.P 10
^*position the cursor\*

.P 0
at one end of the section to be changed. Now give the 
command

.P 10
^*BRIDGE\*
.INDEX BRIDGE command

.P 0
and note that the program moves into CONSTRUCT state. 
.INDEX CONSTRUCT state
The command

.P 10
^*START\*
.INDEX START command

.P 0
should then be given for each new point to be inserted, and the new part of the
feature (except for the first segment) will be drawn in refresh. If no new 
points are required, the START command need not be used.
To locate the last point of the section to be changed, use

.P 10
^*FIND\*

.P 0
and then

.P 10
^*position the cursor\*

.P 0
The program remains in CONSTRUCT state until the command

.P 10
^*END\*

.P 0
which terminates the operation, is issued.



.CHAPTER ^&Editing Texts and Symbols\&
.TITLE LITES2 User's Guide
.SUBTITLE Editing Texts and Symbols

.HL 1 ^^^&Making Changes to a Text or Symbol\&
.INDEX Changing >text features
.INDEX Changing >symbol features

.P 0
Attributes of texts and symbols can be changed in a similar way to lines. You 
first have to identify a text or symbol using

.P 10
^*FIND\*

.P 0
Now try

.P 10
^*CHANGE FSN n\*
.INDEX CHANGE command

.P 0
to change the feature serial number. Note that unlike lines, the program 
automatically enters MODIFY state 
.INDEX MODIFY state
after you have issued the command; this happens with all of the text and 
symbol commands.
Now, depending on whether your found-feature is a text or symbol, give either
of the commands

.P 10
^*CHANGE FC 399\* or ^*CHANGE FC 49\*

.P 0
to change the feature code, and note that the editor remains in MODIFY 
state. This is the case for all of the operations on texts and symbols, and so 
several operations can be performed on these features without leaving MODIFY 
state. Editing of the feature is completed by issuing the command

.P 10
^*END\*

.P 0
This deposits the changed feature and returns the program to READY state.

.P 0
For clarity, the FIND command and the last END command will not be illustrated 
in the command sequences for the remaining sections of this chapter. It is 
assumed that you will have an appropriate 
text or symbol feature in hand and be ready to 
try out each command in turn. 

.P 0
Note that there are three types of symbols, i.e.
unoriented, oriented and scaled.

.HL 1 ^^^&Moving a Text or Symbol\&
.INDEX Moving >text features
.INDEX Moving >symbol features

.P 0
Assuming you are in TEXT, SYMBOL or MODIFY state, issue the command

.P 10
^*MOVE\*
.INDEX MOVE command

.P 0
This attaches a refresh copy of the feature to the cursor, and you can move it
to its new position before depositing it by issuing

.P 10
^*END\*
.INDEX END command

.P 0
Unlike lines, this command does not terminate the operation, and you remain in 
MODIFY state to allow for further editing of the feature. Note also that the 
refresh copy of the feature is no longer attached to the cursor.

.HL 1 ^^^&Copying a Text or Symbol\&
.INDEX Copying >text features
.INDEX Copying >symbol features

.P 0
Copying a text or symbol is similar to moving one, but you first have to issue

.P 10
^*COPY\*
.INDEX COPY command

.P 0
followed by

.P 10
^*MOVE\*

.P 0
Now you have a new copy of the feature attached to the cursor, and you can 
move the copied feature to its new position and issue

.P 10
^*END\*

.P 0
to deposit it. Again, you remain in MODIFY state.

.HL 1 ^^^&Changing the Size of a Text or Scaled Symbol\&
.INDEX Enlarging >text features
.INDEX Enlarging >symbol features >scaled
.INDEX Reducing >text features
.INDEX Reducing >symbol features >scaled

.P 0
A text or scaled symbol can be made larger using the command

.P 10
^*LARGER\*
.INDEX LARGER command

.P 0
and smaller using the command

.P 10
^*SMALLER\*
.INDEX SMALLER command

.P 0
For texts with height in point-size units these commands use the next available 
point-size. Otherwise, the text or symbol is increased or decreased in size by 
10%.

.HL 1 ^^^&Rotating a Text, Oriented Symbol or Scaled Symbol\&
.INDEX Rotating >text features
.INDEX Rotating >symbol features >oriented
.INDEX Rotating >symbol features >scaled

.P 0
In order to rotate a text, oriented symbol or scaled symbol you can use the
command

.P 10
^*ROTATE CURSOR\*
.INDEX ROTATE command

.P 0
Movement of the cursor will cause the text or symbol to rotate in that 
direction. When the feature is suitably oriented, the cursor can be 
disconnected by issuing the command

.P 10
^*END\*
.INDEX END command

.P 0
Note that you remain in MODIFY state.

.HL 1 ^^^&Editing a Text String\&
.INDEX Editing text strings

.P 0
Existing text can be completely replaced using the REPLACE command. For 
example, if the current feature in hand is a text and you want the text to be 
'Trinity Street', issue the command

.P 10
^*REPLACE##Trinity#Street\*
.INDEX REPLACE command

.P 0
If you only want to replace part of a text string, you can use the SUBSTITUTE 
command. For instance, to substitute 'Sidney' for 'Trinity' in the above 
example, you would type

.P 10
^*SUBSTITUTE##Trinity##Sidney\*
.INDEX SUBSTITUTE command

.P 0
The text will now be 'Sidney Street'. If the text string contains spaces, it 
must be enclosed in quotes. In the above example, the command

.P 10
^*SUBSTITUTE##"Sidney"##"St.#Andrews"\*

.P 0
results in the text 'St. Andrews Street'

.HL 1 ^^^&Changing the Size and Orientation of a Scaled Symbol\&
.INDEX Orienting >symbol features >scaled
.INDEX Enlarging >symbol features >scaled
.INDEX Reducing >symbol features >scaled

.P 0
You can use the cursor to define the size and orientation of a scaled symbol. 
Give the command 

.P 10
^*ALIGN\*
.INDEX ALIGN command

.P 0
Now move the cursor to align the symbol; the distance between the symbol and 
the cursor is proportional to the symbol size, and the symbol is aligned along 
an imaginary line joining the symbol and cursor. When the symbol is suitably 
aligned, the cursor can be disconnected with the command

.P 10
^*END\*

.P 0
If you simply want to change the size of a scaled symbol, use the command

.P 10
^*STRETCH\*
.INDEX STRETCH command

.P 0
The cursor will be constrained to lie on the symbol orientation line, and you 
can change the symbol size by moving the cursor. When the size is 
satisfactory, disconnect the cursor with the command

.P 10
^*END\*



.CHAPTER ^&Creating New Features\&
.TITLE LITES2 User's Guide
.SUBTITLE Creating New Features

.HL 1 ^^^&Creating a Line Feature\&
.INDEX Creating >line features
.INDEX Constructing >line features

.P 0
Before creating a new line feature, you need to set up the feature attributes. 
There are sixteen feature attribute sets to enable construction of various 
line types and symbols, and the attributes used for feature construction are 
contained in the current attribute set.
In order to copy a given attribute set, e.g. 1, into 
the current attribute set, you should give the command

.P 10
^*GET 1\*
.INDEX GET command

.P 0
The attributes can now be modified, and to alter the feature code, for example 
to 30, you need to issue

.P 10
^*SET FC 30\*
.INDEX SET command

.P 0
If the terminal status line is enabled, you will note that it displays the 
construction feature code.
The actual construction can now be started. Position the cursor over the first 
point, and give the command

.P 10
^*START\*
.INDEX START command

.P 0
This puts the editor into CONSTRUCT state, 
.INDEX CONSTRUCT state
and you should repeat the process 
for all the other points until the last point, where the command

.P 10
^*END\*

.P 0
should be given. This terminates the construction. If you now want to save the 
current attribute set, you can copy it into a specified attribute set, e.g. 2, 
by issuing

.P 10
^*PUT 2\*
.INDEX PUT command

.P 0
Note that the current attribute set remains unchanged, and so if the next new
line feature is to have the same attributes, the GET and SET commands need not 
be used before starting the new construction.

.HL 1 ^^^&Closed Loops\&
.INDEX Closed loops

.P 0
If the feature under construction is to be a closed loop, you would construct 
it as above, but just before giving the END command, issue

.P 10
^*CLOSE\* or ^*CLOSE SQUARE\*
.INDEX CLOSE command

.P 0
The former will move the cursor onto the first vertex, so that the first and 
last vertices are in the same position. The latter, however, will
extend the line joining the last digitised point and the current cursor 
position to a new point, such that the line joining the new point to the first 
vertex is a right angle. The cursor will finish up on the first vertex.

.P 0
Note that the CLOSE command is analogous to the LOOP command used in line 
editing.

.HL 1 ^^^&Creating a Text Feature\&
.INDEX Creating >text features
.INDEX Constructing >text features

.P 0
Some of the attributes used in feature construction are global; they do not 
belong to any particular attribute set, and can be set directly. One of these 
is the feature code used for new text features. To set this, for example to 
28, give the command

.P 10
^*SET TEXT 28\*
.INDEX SET command

.P 0
You can now construct a new text, for example 'Bridge Street', by giving the 
command

.P 10
^*TEXT##Bridge#Street\*
.INDEX TEXT command

.P 0
The program will now be in MODIFY state, 
.INDEX MODIFY state
and you can use any of the text editing commands given in Chapter 6. Try

.P 10
^*MOVE\*

.P 0
and move the new text to the desired position. Giving the command

.P 10
^*END\*

.P 0
will deposit the feature, and if the text is the correct size and orientation, 
issue

.P 10
^*END\*

.P 0
again to terminate the operation.

.HL 1 ^^^&Creating a Symbol Feature\&
.INDEX Creating >symbol features
.INDEX Constructing >symbol features

.P 0
Creating a symbol feature is a combination of the operations required for 
lines and texts. If you want to make one of the feature attribute sets, 
e.g. 3, current, issue

.P 10
^*GET 3\*

.P 0
Now (if it is not already set) set the feature code to a symbol, for example
11, by giving the command

.P 10
^*SET FC 11\*
.INDEX SET command

.P 0
The symbol is created by using the command

.P 10
^*START\*
.INDEX START command

.P 0
which takes you into MODIFY state. 
.INDEX MODIFY state
Like texts, you can now use any of the 
symbol editing commands given in Chapter 6. To move your new symbol, issue

.P 10
^*MOVE\*

.P 0
and move it to the desired position. Giving 

.P 10
^*END\*

.P 0
will deposit the symbol, and

.P 10
^*END\*

.P 0
again will terminate the operation. As with lines, you can copy the current 
attribute set into another, e.g. 4, by issuing

.P 10
^*PUT 4\*



.CHAPTER ^&Finishing a Session\&
.TITLE LITES2 User's Guide
.SUBTITLE Finishing a Session

.HL 1 ^^^&Normal Completion\&
.INDEX Exiting a session

.P 0
The normal method of finishing a session is to use the command

.P 10
^*EXIT\*
.INDEX EXIT command

.P 0
which creates new versions of the input IFF files and deletes the workspace 
files. If you have been editing a 
single IFF file and you want the new version to have a different name, for 
example MYMAP.IFF, you would issue

.P 10
^*EXIT MYMAP.IFF\*
.INDEX EXIT command

.P 0
Note that the EXIT command has to be typed in full.

.HL 1 ^^^&Ignoring all Editing\&
.INDEX Quitting a session

.P 0
All editing will be ignored if you use the command 

.P 10
^*QUIT\*
.INDEX QUIT command

.P 0
which again should be typed in full. This does not create any new files and 
leaves the old file unchanged.



.!********************* Index *****************
.NOSUBTITLE
.PAGE

.REQUIRE	"USER.RNX"

