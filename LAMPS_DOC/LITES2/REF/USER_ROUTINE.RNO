.!
.! USER_ROUTINE.RNO
.! This part of the LITES2 Reference manual talks about
.! writing user routines
.!
.REQUIRE "REF.HD"
.!
.INDEX User Routines
.!
.HL 1 ^^^*User Routines\*
.P 0
LITES2 provides the opportunity for users to write their own programs to
implement any operations that they require, that are not provided by the
LITES2 commands, and that cannot be provided by the use of the MACRO
command facility. 
.B
This facility is achieved by the LITES2 USER command, which allows 
access to one such program, and the ROUTINE command which allows
access to another 10.
.B
The programs must be linked as shareable images (see below for details)
and they are accessed by logical names as follows:
.LIST '*'
.INDEX LSL$LITES2ROUTINES
.LE; The "USER" command uses the image pointed to by the logical name
LSL$LITES2ROUTINES
.INDEX LSL$LITES2ROUTINES__n
.LE; The "ROUTINE n" command uses the image pointed to by the logical
name LSL$LITES2ROUTINES__n, where n is an integer either between 
1 and 5 or between 101 and 105.  The routines with numbers greater than 
100 are reserved for user routines supplied by Laser-Scan.
.END LIST
.NOTE
In the rest of this chapter reference is made to the USER command. In
any particular case this can be substituted by the ROUTINE n command.
.END NOTE
.B
Before attempting to provide their own shared image, users should have
an understanding of the concept of features, as used by LITES2; in
particular the various entries that are associated with different
graphical types of features. For further information see Laser-Scan's
documentation on IFFLIB and FRTLIB. 
.!
.HL 2 ^*Calling the User Routines from LITES2\*
When the USER command is given to LITES2 the subroutines that the user
has written and included in the shareable image, are called ^*by
LITES2\*. LITES2 is designed to call up to 10 routines, but note that 
.LIST '*'
.LE; If a particular routine does not exist in the image, then it will
not be called. This means that there is no need for the user to provide
routines he does not require. 
.LE; In some cases there are alternative routines that can be supplied. 
For example there are several different routines that can be supplied to 
get the coordinates of the current feature, depending on the complexity
of the data that is required - only X and Y; X, Y and Z; or X, Y and a 
full set of attributes for each point. In this case LITES2 will call the
most complex routine that exists in the image, and will ignore any other
routines in this group.
.END LIST
The user routine can control the order in which the subroutines are 
called by setting a return code in each routine to say what routine is
to be called next.
.P 0
For example, when the USER command is given to LITES2, the arguments (an
integer and an optional string) are passed to the initialisation routine
(USRINI) along with other pieces of information (see details of the
subroutines below). On completion of the routine, LITES2 examines the
return code that has been set within the routine, and 
.LIST '*'
.LE; If the return code = 0 will abort the USER command 
.LE; If the return code = 1 will call routines to obtain the Coordinates
and the ACs of the current feature 
.LE; If the return code = 2 will call routines to obtain the Coordinates
without the ACs of the current feature 
.LE; If the return code = 3 will call routines to obtain the ACs of the
current feature without the coordinates 
.LE; If the return code = 4 will ignore the coordinates and ACs of the
current feature and call the routine that does any processing required
before constructing a new feature 
.LE; If the return code = 5 will call the completion routine, without any
of the intervening routines 
.LE; If the return code _> 100 will call the routine that obtains, and
optionally writes back, the map header and the map descriptor for the
a particular map (the map is specified as the difference between the
return code and 100, for example is 101 is returned, the data from map 1
is used; 105 allows the data from map 5 to be examined and edited).
.END LIST
.!
The flow of control can be determined on the completion of all the
routines in a similar manner. The following diagram shows the various
possibilities 
.FIG 35
.NOTE Possible order in which routines are called.
Note that the USER command may be aborted after all subroutine calls if 
the return code 0 is returned.
.BL
The loop that runs from "Finish" back to "Do Processing" may be broken 
and the command aborted by pressing CTRL C, as can the loops that run
from "Finish" through "Ancillary" back to "Finish" and the loop that
allows repeated calls of the map header editing routine.
.END NOTE
.!
.HL 2 ^*Accessing particular shared images.\*
The shared images are only mapped when the first USER or ROUTINE n 
command is given. If the appropriate logical name is not set up then
a warning message will be given at this stage.
.TP 15
.!
.HL 2 ^*The Subroutines - general.\*
.!
The subroutines are listed, by functional group, in the order that they
are called  by the USER routine, and appear in the diagram above.
.!
.HL 3 ^^^*Initialise\*
This is the first subroutine to be called, whenever the USER command is
given. 
There is only one routine that can be supplied in this group - USRINI
.Bl
It is used to pass initial data to the shared image.  This initial data 
consists of:-
.LIST "*"
.LE;the integer argument that was given with the USER command.
.BR; This integer is often used to define which of several different
operations is to be carried out by the shared image. 
.LE; the optional string argument that may be given with the USER
command. Any other information that is required by the user routines can
be passed in this argument and subsequently decoded. 
.LE; the current cursor position.
.BR; This is passed in the units that the data is stored in, in the IFF
file(s). If there are multiple maps, any offset relative to the south
western map will have been added. 
.LE; the current state
.LE; a flag to say if there is a found object or not.
.LE; some data about the found object.
.BR; This is information that can be passed in a fixed format.  Data
about the feature that is of variable length (lists of ACs and
coordinates) is dealt with by the routines get ACs and get coordinates
(see below) 
.ELS
.TP 8
Having received this information, the subroutine must set the return
code, to tell LITES2 which subroutine to call next. The possibilities
are:- 
.LS " "
.LE; "0" means that no more subroutines will be called.
.LE; "1" means call routines to get the ACs for the feature, and the
coordinates. 
.LE; "2" means call routines to get coordinates of the feature, but not
the ACs. 
.LE; "3" means call routines to get the ACs for the feature without the
coordinates. 
.LE; "4" means that the next subroutine to be called is to do the 
processing.
.LE; "5" means that the next subroutine to be called is the one that 
completes the command.
.LE; "_> 100" means call the routine that allows the map header and map
descriptor information to be edited.
.ELS
Any other value will cause a fatal error (see routine USRERR below for
details on error handling).
.BR; Entering 1,2 or 3 when there is no found feature will also cause a
fatal error.  Attempting to get ACs from a feature that has none will
cause the routine not to be called, and the next routine called will 
depend on the value of the return code supplied.
.BR; If the routine USRINI is not supplied in the shareable image, or if
the return code is greater than 100, and the routine to get map header
information is not supplied, USRDO will be the next routine that is
called.
.TP 15
.!
.HL 3 ^^^*Getting and writing file header information\*
This routine is used to read and write information that is particular to
the specified map. There is only one routine that can be supplied in this
group - >USRGMH
.BL
This subroutine is used to read any map header (MH) and map descriptor
(MD) entries associated with the specified map. The map is specified by
giving a return code _> 100 - the map is the difference between the
return code and 100.
.BR; It supplies the map header and the map descriptor (as arrays of
16 bit integers - INTEGER_*2 in Fortran) and allows them to be altered
and optionally written back to their files.
.B
.TP 6
The possible return codes are:-
.LS " "
.LE; "0" means that no more subroutines will be called.
.LE; "1" means call routines to get the ACs for the feature, and the
coordinates. 
.LE; "2" means call routines to get coordinates of the feature, but not
the ACs. 
.LE; "3" means call routines to get the ACs for the feature without the
coordinates. 
.LE; "4" means that the next subroutine to be called is to do the 
processing.
.LE; "5" means that the next subroutine to be called is the one that 
completes the command.
.LE; "_> 100" means call this routine again, with the data from the
specified map (see above).
.ELS
.TP 15
.!
.HL 3 ^^^*Getting ACs\*
This subroutine is used to read any AC entries associated with the found
feature. There is only one routine that can be supplied in this group -
>USRGAC 
.BL
This subroutine is used to read any AC entries associated with the found 
feature.
.BR; It reads one AC at a time and returns its type, value and any text 
associated with it.
.B
.TP 6
The possible return codes are:-
.LS " "
.LE; "0" means that no more routines will be called.
.LE; "1" means call USRGAC again, if there are any more ACs, or else
call the routine to get coordinates or to do the processing (depending
on return code supplied by the Initialising routine) 
.LE; "2" means don't call USRGAC again; call the routine to get 
coordinates or the routine to do the processing (depending on 
return code supplied by the Initialising routine)
.LE; "4" means don't call USRGAC again; call the routine to do the 
processing.
.ELS
.TP 6
.NT NOTES
.LS
.LE; TC entries are treated as ACs with a type of -1.
.BR; They have no value associated with them, and a longer maximum text
length. 
.LE; CH entries are treated as ACs with a type of -2.
.BR; They  have no value associated with them, and a longer maximum text
length. 
.ELS
.EN
.!
.TP 15
.HL 3 ^^^*Getting Coordinates\*
This group of subroutines are used to get the coordinates associated
with the found feature. As the number of coordinates varies between
feature and feature these subroutines pass the coordinates a block at a
time.  This means that arbitrarily long features can be processed by the
USER command - although the user's shared image must of course have a
method of dealing with them. 
.B
LITES2 decides how many points to pass to the routine; it will generally
be 200, or the number of points remaining in the feature if that is less,
but for composite texts the points will be passed one at a time. 
.B
The coordinates associated with each point in a feature can be simple
or complex, according to the way in which LITES2 is being used. To avoid 
the user having to deal with unnecessary complexities, when he does not 
require the complex information, there are at several routines that 
may be called at this point. They are :
.LIST
.LE; >USRGCB - this routine passes, in addition to X and Y coordinates,
an array of the attributes that are associated with each point, along
with the arrays of header information for the attributes, that allow
them to be used. This header information consists of a vector array of
the codes used to identify each column of data and similar arrays that
hold the names that are represented by the codes, and their data types. 
.BL
See the FRTLIB users guide for information about these codes and data 
types
.NOTE NOTES
.LIST
.LE;^*Blocks of attribute information passed in repeated calls of this 
routine may not have their columns in the same order.\*
.LE;Attribute values may be null (i_.e_. unset). This may be tested for
by comparing the ABSENT parameter (given in the template routine) with 
the INTEGER version of the required value.
.END LIST
.END NOTE
.LE; >USRGZS - this routine passes the X, Y and Z coordinates of each 
point of the feature.
.LE; >USRGST - this routine is the simplest of the routines and passes 
a simple XY array.
.LE; >USRGPT - this routine is similar to USRGST, but in addition it 
passes information about the text in text features. This can be used for 
simple (i_.e_. non-composite texts) but see below. It is included for 
upwards compatability with user-routines written for versions of LITES2 
prior to version 2.8.
.END LIST
If two (or more) of these routines are included in the shared image,
then the one higher up the list will be used.
.B
In addition to passing the coordinates, the subroutines also pass a
byte array of flags associated with each point. At present, only the
bottom bit is significant, and it indicates whether the vector up to
this point is to be visible (1) or invisible (0).  In general, the flag
for the first point has no significance. 
.TP 6
The possible return codes are:-
.LS " "
.LE; "0" means that no more routines will be called.
.LE; "1" means call the routine again, if there are any more points, or
else call the routine that will do the processing. 
.LE; "4" means don't call the routine again - call the routine that will 
do the processing.
.ELS
.B
If the feature is a text feature, after the relevant routine has been 
called to get the coordinates, the routine >USRGTX is called if it is 
present in the image. This returns data about the (sub)text associated 
with the coordinate information that has just been received. It does not 
require a return code to be supplied. The flow of control depends on the 
return code supplied in the coordinate passing routine.
.B
.!
.TP 15
.HL 3 ^^^*>Processing\*
There is only one routine that can be supplied in this group - >USRDO
.BL
By the time this routine is called, all the information has been passed
from LITES2 to the user routines.  This routine is used to process this
data. Its return code controls the transfer of data back to LITES2. 
.B
The possible return codes are:-
.LS " "
.LE; "0" means that no more user routines will be called.
.LE; "4" means do not pass a feature back to LITES2; call the completion 
routine straight away. 
.LE; "5" means call routines to construct a new feature, keeping any old
one. 
.LE; "6" means call routines to construct a new feature, deleting any
currently found feature. 
.ELS
.TP 6
.NT
It is not possible to construct a new feature while LITES2 is in certain
states. An attempt to do so, by setting the return code of this routine
to 5 or 6, while in these states, will cause a fatal error. The states
involved are:- 
.LS '*'
.LE; Construct State
.LE; Modify State
.LE; AC State
.LE; Edit State
.LE; Initial State
.ELS
.EN
.!
.TP 15
.HL 3 ^^^*Start a New Feature\*
There is only one routine that can be supplied in this group - >USRSTO
.BL
If a new feature is to be constructed (code 5 or 6 returned by the
processing routine), then the routine to start a new feature is called.
This allows the shared image to define the type of feature that is to be
constructed.  Entering -1 as the value of the FSN, FC, MAP, LAYER or
THICK allows default values of these to be used in the construction of
the new feature (set TEXTF true if default text feature code is to be
used), otherwise values can be explicitly set in these variables. 
.B
See IFFLIB documentation for the meaning of the 4 elements of the FC (or
feature status entry) 
.B
The number of coordinated points and the number of ACs in the feature
must be given at this stage. 
.B
The possible return codes are:-
.LS " "
.LE; "0" means that no more user routines are called.
.LE; "1" means that more data about the feature is to be passed; call
either the routines to output an AC (if the number of ACs _> 0), or else
call the routines to output coordinates. 
.LE; "4" means call the completion routine straight away (no new feature
will be constructed). 
.ELS
.TP 7
.NT NOTES
.LS
.LE; Any attempt to construct a feature in a non-existent map or layer,
a read only map, with an non-existent feature code, with an invalid
feature code in the circumstances, or with an inappropriate number of
points will result in a fatal error. 
.LE; The FC entries are truncated to INTEGER_*2 values before they are 
interpreted by LITES2.
.LE; The top two bits of the truncated value of FC(3) will be set by
LITES2, depending on the graphical type of the feature. 
.LE; Invalid values of THICK (when the HEIGHT and POINT options have
been enabled) will cause a non-fatal error.  The value of THICK is
ignored for non-text  features, or when the HEIGHT option is disabled. 
.LE; ROTAT is only meaningful for oriented symbols (and text, if USRPPT
is being used to output a text). It is entered as a value in radians. 
.LE; Orientation of scaled symbols is achieved by entering two points.
.LE; There are OPERATION USER__FEATURE and OPERATION USER__POINT
commands that will allow any ACs and point that are constructed by the
user routine to be automatically updated.
.ELS
.EN
.!
.TP 15
.HL 3 ^^^*Outputting an AC\*
This subroutine is used to output any AC entries to be associated with
the ne construction. There is only one routine that can be supplied in
this group - >USRPAC 
.BL
This routine is called after the routine that started a new feature, if
the return code was set to 1 and there were some ACs to add to the
feature.  As long as its return code is set to 1, it is called NACS (as
returned by the start feature routine) times.
.BL
The possible return codes are:-
.LS " "
.LE; "0" means that no more user routines are called
.LE; "1" means call this again if there are more ACs, otherwise call
a routine to output some coordinates
.LE; "2" means don't call this routine again, call a routine to output 
some coordinates
.LE; "4" means call the completion routine straight away.
.ELS
.TP 8
.NT NOTES
.LS
.LE; Trying to construct an AC, TC or CH entry with a text that is too
long, will result in a non-fatal error and the text being truncated. 
.LE; A return code of 2 calls the relevant coordinate output routine
straight away. 
.BR; ^*Any AC data passed in a call of this routine with a return code
of 2 is ignored by LITES2.\* 
.ELS
.EN
.!
.TP 15
.HL 3 ^^^*Outputting coordinates\*
This group of subroutines are used to output the coordinates of the new 
feature.
.B
The coordinates are passed to LITES2 in blocks, in repeated calls of one
of the output routines, in a similar manner to the way in which
coordinates are passed out of LITES2 by the routines that get
coordinates. The size of each block of coordinates is determined by the
shared image - ^*but it must not be larger than the value that is passed
to the user image in the argument SIZE.\* 
.BL
When constructing non-text features, for efficiency, the largest
possible blocks of data should be supplied to this routine. For texts
however, only one point should be supplied at a time, so that a call 
of USRPTX can be associated with each coordinate
.B
In a manner similar to the routines that get coordinates, depending on 
the amount of data required, there are several routines that 
may be called at this point. They are :
.LIST
.LE; >USRPCB - this routine passes, in addition to X and Y coordinates,
an array of the attributes that are associated with each point, along
with an array of header information for the attributes.
.LE; >USRPZS - this routine passes the X, Y and Z coordinates of each 
point of the feature.
.LE; >USRPST - this routine is the simplest of the routines and passes 
a simple XY array.
.LE; >USRPPT - this routine is similar to USRPST, but in addition it 
passes information about the text in text features. This can be used for 
simple (i_.e_. non-composite texts) but see below. It is included for 
upwards compatability with user-routines written for versions of LITES2 
prior to version 2.8.
.END LIST
If two (or more) of these routines are included in the shared image,
then the one higher up the list will be used.
.B
In addition to passing the coordinates, the subroutines also pass a
byte array of flags associated with each point. At present, only the
bottom bit is significant, and it indicates whether the vector up to
this point is to be visible (1) or invisible (0).  In general, the flag
for the first point has no significance. 
.TP 6
.B
.TP 10
The possible return codes are:-
.LS " "
.LE; "0" means abort the construction of the feature, and don't call any
more routines 
.LE; "1" means write these coordinates, or if LITES2 has already
completed the feature, call the completion routine
.LE; "4" means abandon the construction of the feature, if it is not yet 
completed; call the completion routine.
.ELS
.TP 6
.NT NOTES
.LS
.LE; When one of these routines has been called, LITES2 will ultimately
revert to READY state, either on completion of the feature, or when the
construction is abandoned. 
.LE; Any error in constructing the feature will result in a fatal error,
and the construction will be abandoned. 
.LE; Trying to construct a text with a zero length string will result
in a fatal error 
.LE; Trying to construct a feature with coordinates that fall outside
the limits of the map(s) will also cause a fatal error. 
.LE; Supplying the return code 4, before all the points have been passed
(with calls with return code 1) will result in the construction being
abandoned. 
.ELS
.EN
.B
If the feature is a text feature, after the relevant routine has been 
called to get the coordinates, the routine >USRPTX is called if it is 
present in the image. This provides data about the (sub)text associated 
with the coordinate information that has just been sent. It does not 
require a return code to be supplied. The flow of control depends on the 
return code supplied in the coordinate passing routine.
.!
.TP 15
.HL 3 ^^^*Completing the USER command\*
.INDEX USRRET
.INDEX USRDEF
.INDEX USRANO    
.INDEX USRDRW
There are four routines that can be supplied in this group - USRRET and
the ancillary routines, USRDEF, USRANO and USRDRW.
.BL
USRRET is the last user routine to be called by the USER command. It
allows the condition flag (used for determining the flow of control in
macros) to be set and also allows a LITES2 command string to be entered.
This command string will be obeyed immediately after the current USER
command is completed.
.B
By supplying a suitable return code, LITES2 can be instructed to call an
ancillary completion routine : USRDEF, USRANO or USRDRW. After this
ancillary routine  has completed, USRRET is called again.
.B
.TP 6
The possible return codes to USRRET are:-
.LS " "
.LE; "0" do not set the condition flag or obey the command string
.LE; "1" set the condition flag and obey the command string
.LE; "2" call the processing routine again
.LE; "3" call the ancillary completion routine USRDEF
.LE; "4" call the ancillary completion routine USRANO
.LE; "5" call the ancillary completion routine USRDRW
.ELS
.NOTE
This flow of control, that may cause a (infinite) loop to be set up, if
this routine always sets the return code to be greater than 1, can be
broken and the user routine aborted by entering CTRL C at the keyboard,
or through the abort auxiliary input.
.END NOTE
.TP 6
USRRET must exist if an ancillary routine is to be called.
.BL
There is no return code supplied to these ancillary routines; after they
have completed successfully USRRET is called again. If an error occurs
while carrying out the action required by the routine (for example if a
variable to be set does not exist, or a drawing command is given in an
inappropriate state) the user routine aborts.
.LIST
.LE; USRDEF is used to set the value of LITES2 variables.
.B
It takes arguments of all possible data types, but only the one that
relates to the type of the LITES2 variable that has been specified is
used. 
.LE; USRANO is used to set the characteristics for drawing annotation
from the user routine with the USRDRW routine. Annotation
characteristics thus set are lost when the user routine completes.
.B
It takes as arguments a string, and the length of the string. The
routine should return the required secondary command (and any arguments)
for an ANNOTATION command. The string length, on input is the maximum
length of the string to be returned. If 0 is returned as the string
length then no ANNOTATION action is performed.
.LE; USRDRW is used to draw something on the screen from the user
routine.
.B
It takes as arguments a string, and the length of the string. The
routine should return the required secondary command (and any arguments)
for a DRAW command. The string length, on input is the maximum length of
the string to be returned. If 0 is returned as the string length then no
DRAWing is performed.

.END LIST
.!
.TP 15
.HL 3 ^^^*Error handling\*
.INDEX USRERR
There is only one routine that can be supplied in this group - USRERR.
.BL
.BR; If the FATAL argument is TRUE, then the USER command will be
aborted, as soon as control returns from this routine - abandoning any
feature that is being constructed. 
.BR; If the FATAL argument is FALSE, then the USER command will continue
after outputting a warning message. 
.B
See the details of the routine for the meaning of the error numbers.
.!
.PG
.HL 2 ^*The Subroutines - specifications.\*
There are template files supplied in 
LSL$PUBLIC__ROOT:[LITES2.ROUTINES.TEMPLATE] for all the following
routines 
.!
.HL 3 ^^^*Initialise\*
.HL 4 ^^^*>USRINI\*
.LT
	SUBROUTINE USRINI(ACTION,STRL,STR,CURSOR,CNDFLG,STATE,
     &	                  GOTFO,NCOORD,NACS,FSN,FC,MAP,LAYER,GT,
     &	                  ROTAT,THICK,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
C Arguments
C
	INTEGER*4	ACTION		! action to carry out
	INTEGER*4	STRL		! number of characters in STR
	CHARACTER*(*)	STR		! string passed to USER command
	REAL		CURSOR(2)	! coordinates of cursor
	LOGICAL		CNDFLG		! condition flag.
	CHARACTER*(*)	STATE		! current state
	LOGICAL		GOTFO		! TRUE if there is a found
					! object, FALSE otherwise, when
					! the next 4 arguments are 
					! undefined
	INTEGER*4	NCOORD		! number of coords
	INTEGER*4	NACS		! number of ACS
	INTEGER*4	FSN		! number of feature
	INTEGER*4	FC(4)		! feature status 
	INTEGER*4	MAP		! map
	INTEGER*4	LAYER		! layer
	INTEGER*4	GT		! graphical type
	REAL		ROTAT		! rotation if text or oriented
					! symbol (in radians)
	INTEGER*4	THICK		! size of text
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call 
					!     processing routine
					! = 1 for get coords and ACs
					! = 2 for get coords without ACs
					! = 3 for get ACs without coords
					! = 4 for call processing without
					!     coords or ACs
					! = 5 for call completion 
					!     routine
					! > 100 - call the routine to get
					!  map header information (for map
					!  RETCOD - 100)
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
.EL
.!
.PG
.HL 3 ^^^*Getting file header information\*
.HL 4 ^^^*>USRGMH\*
.LT
	SUBROUTINE USRGMH(MH_LEN,MH,WRITE_MH,MD_LEN,MD,WRITE_MD,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
C Arguments
C
	INTEGER*4	MH_LEN		! input  - length of original MH
					! output - length of updated MH
	INTEGER*2	MH(MH_LEN)	! map header - NOTE INTEGER*2
	LOGICAL*4	WRITE_MH	! input  - TRUE if MH is writable
					! output - TRUE if MH is to be written
	INTEGER*4	MD_LEN		! input  - length of original MD
					! output - length of updated MD
	INTEGER*2	MD(MD_LEN)	! map descriptor - NOTE INTEGER*2
	LOGICAL*4	WRITE_MD	! input  - TRUE if MD is writable
					! output - TRUE if MD is to be written
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call processing
					!     routine
					! = 1 for get coords and ACs
					! = 2 for get coords without ACs
					! = 3 for get ACs without coords
					! = 4 for call processing routine
					!     without
					!     coords or ACs
					! = 5 for call completion routine
					!     without coords or ACs
					! > 100 - call this routine again
C
C	All these arguments may be considered writable but note that
C	the new lengths of the arrays MUST not be longer than the
C	original arrays
C
C	Trying to write a map header or a map descriptor to a file that
C	has been opened for READing only will cause an error.
C
C	Writing a new map header or map descriptor will not affect the
C	idea that LITES2 has of the origin and scale, and the system,
C	variables $MHARR, $MHLEN, $MDARR and $MDLEN although the output
C	file will contain the changes.
C
C	Changes to the projection parts of the map descriptor (ie apart
C	from the origin and scale) require an intimate knowledge of
C	Laser-Scan's projection software. It is recommended that such
C	changes are made using the program ITRANS.
C
.EL
.!
.PG
.HL 3 ^^^*Getting ACs\*
.HL 4 ^^^*>USRGAC\*
.LT
	SUBROUTINE USRGAC(ACTYPE,ACIVAL,ACTXTL,ACTXT,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
C Arguments
C
	INTEGER*4	ACTYPE		! type of AC
	INTEGER*4	ACIVAL		! AC value
					! note: to read a real AC value,
					! a copy of this will have to
					! be equivalenced to a real
	INTEGER*4	ACTXTL		! number of characters in ACTXT
	CHARACTER*(*)	ACTXT		! text (maximum of 80 chars)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call USRDO
					! = 1 for get more ACs if there
					!     are any, or start getting
					!     coords if reqd, or call
					!     USRDO if coords not reqd
					! = 2 stop getting ACs, start
					!     getting coordinates
					! = 4 for call USRDO right away
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
.EL
.!
.PG
.HL 3 ^^^*Getting coordinates\*
.HL 4 ^^^*>USRGCB\*
.LT
	SUBROUTINE USRGCB(SIZE,USERXY,USRFLG,
     &	                 MAX_ATTR,USERNATT,USERATTC,
     &	                 USERDATATYPES,USERNAMELENS,USERNAMES,USERIATTV,
     &	                 USERRATTV,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! number of coords passed
					! with this call
	REAL		USERXY(2,SIZE)	! coordinates
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER		MAX_ATTR	! maximum number of attributes
	INTEGER		USERNATT	! number of attributes present
	INTEGER		USERATTC(MAX_ATTR)	! attribute codes
	INTEGER		USERDATATYPES(MAX_ATTR)	! datatypes of attributes
	INTEGER		USERNAMELENS(MAX_ATTR)	! name lengths
	CHARACTER*(*)	USERNAMES(MAX_ATTR)	! names of attributes
C
C the following two arrays are equivalenced in the calling routine
	INTEGER		USERIATTV(MAX_ATTR,*)	! integer values
	REAL		USERRATTV(MAX_ATTR,*)	! real values
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call 
					!     processing routine
					! = 1 for get more coords
					!     or call processing routine,
					!     if no more
					! = 4 for abort, but call
					!     processing routine
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
C
C	the following parameter is for testing if an attribute value
C	is present for a particular point
C
C	NOTE: this must be tested against an integer, which has
C	been equivalenced onto the real value to be tested
C
	INTEGER*4	IABSENT
	PARAMETER	(IABSENT = '80000000'X)
.EL
.PG
.!
.HL 4 ^^^*>USRGZS\*
.LT
	SUBROUTINE USRGZS(SIZE,USERXYZ,USRFLG,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! number of coords passed
					! with this call
	REAL		USERXYZ(3,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call
					!     processing routine
					! = 1 for get more coords
					!     or call processing routine,
					!     if no more
					! = 4 for abort, but call
					!     processing routine
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
C
C	the following parameter is for testing if a Z coordinate value
C	is present for a particular point
C
C	NOTE: this must be tested against an integer, which has
C	been equivalenced onto the real value to be tested
C
	INTEGER*4	IABSENT
	PARAMETER	(IABSENT = '80000000'X)
.EL
.PG
.!
.HL 4 ^^^*>USRGST\*
.LT
	SUBROUTINE USRGST(SIZE,USERXY,USRFLG,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
					! with this call
	REAL		USERXY(2,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call
					!     processing routine
					! = 1 for get more coords
					!     or call processing routine,
					!     if no more
					! = 4 for abort, but call
					!     processing routine
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
.EL
.PG
.!
.HL 4 ^^^*>USRGPT\*
.LT
	SUBROUTINE USRGPT(SIZE,USERXY,USRFLG,TEXTL,TEXT,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! number of coords passed
					! with this call
	REAL		USERXY(2,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	TEXTL		! number of characters in TEXT
	CHARACTER*(*)	TEXT		! text string, if text feature
	INTEGER*4	RETCOD		! return code
					! = 0 abort, don't call
					!     processing routine
					! = 1 for get more coords
					!     or call processing routine,
					!     if no more
					! = 4 for abort, but call
					!     processing routine
C
C	All these arguments, apart from RETCOD, should be considered
C	as read only
C
.EL
.PG
.!
.HL 4 ^^^*>USRGTX\*
.LT
	SUBROUTINE USRGTX(TEXT,TEXTL,TS,HEIGHT,ROTAT,AUX)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	TEXTL		! number of characters in TEXT
	CHARACTER*(*)	TEXT		! text string, if text feature
	INTEGER*4	TS(4)		! text component status
	REAL		ROTAT		! rotation of text component
	INTEGER*4	HEIGHT		! height of text (in points or
					! 0.01mm)
	REAL*4		AUX(8)		! data about text (in IFF units)
					! AUX(1) = angle (in radians)
					! AUX(2) = cosine of angle
					! AUX(3) = sine of angle
					! AUX(4) = height (in IFF units)
					! AUX(5) = minimum X value 
					!         (rel to locating point)
					! AUX(6) = maximum X value
					! AUX(7) = minimum Y value 
					! AUX(8) = maximum Y value
C
.EL
.!
.PG
.HL 3 ^^^*Processing\*
.HL 4 ^^^*>USRDO\*
.LT
	SUBROUTINE USRDO(RETCOD)
C
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call completion
					!     routine
					! = 4 for abort, call completion
					!     routine
					! = 5 to create a new feature
					!     (and keep old one if there
					!      was one)
					! = 6 to create a new feature
					!     and delete old one
C
.EL
.!
.PG
.HL 3 ^^^*Starting a new feature\*
.HL 4 ^^^*>USRSTO\*
.LT
	SUBROUTINE USRSTO(FSN,FC,MAP,LAYER,TXTF,NOPTS,NAC,
     &	                  ROTAT,THICK,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	FSN		! feature serial number to use
					! (set to -1 for unknown)
	INTEGER*4	FC(4)		! feature status to use
					! (set FC(I) to -1 for unknown)
	INTEGER*4	MAP		! map to put feature in
					! (set to -1 for unknown)
	INTEGER*4	LAYER		! layer to use
					! (set to -1 for unknown)
	LOGICAL		TXTF		! .TRUE. if FC =-1 and want
					! to create a text feature
	INTEGER*4	NOPTS		! number of points in feature
	INTEGER*4	NAC		! number of ACs in feature
	REAL		ROTAT		! rotation if text or oriented
					! symbol (in radians)
	INTEGER*4	THICK		! size of text
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call completion
					!     routine
					! = 1 for ask for data
					! = 4 abort, call completion
					!     routine
C
C all the arguments in this subroutine are writable
C
.EL
.!
.PG
.HL 3 ^^^*Outputting an AC\*
.HL 4 ^^^*>USRPAC\*
.LT
	SUBROUTINE USRPAC(ACTYPE,ACIVAL,ACTXTL,ACTXT,RETCOD)
C
C       Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C	Dummy routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	ACTYPE		! type of AC
	INTEGER*4	ACIVAL		! AC value
					! note: to read a real AC value,
					! a copy of this will have to
					! be equivalenced to a real
	INTEGER*4	ACTXTL		! number of characters in ACTXT
	CHARACTER*(*)	ACTXT		! text (maximum of 255 chars)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, no call completion
					!     routine
					! = 1 for write another AC if
					!     there are any, or else
					!     start writing coords
					! = 2 for start writing coords
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable
C
.EL
.!
.PG
.HL 3 ^^^*Outputting coordinates\*
.!
.HL 4 ^^^*>USRPCB\*
.LT
	SUBROUTINE USRPCB(SIZE,USERXY,USERFLG,
     &	              MAX_ATTR,USERNATT,USERATTC,
     &	              USERIATTV,USERRATTV,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! input:  maximum number of
					!         coords to pass back
					! output: actual number of
					!         coords passed back
					! with this call
	REAL		USERXY(2,SIZE)	! coords
	LOGICAL*1	USERFLG(SIZE)	! flags (visibility only)
	INTEGER		MAX_ATTR	! maximum number of attributes
	INTEGER		USERNATT	! number of attributes present
	INTEGER		USERATTC(MAX_ATTR)	! attribute codes
C
C the following two arrays are equivalenced in the calling routine
	INTEGER		USERIATTV(MAX_ATTR,*)	! integer values
	REAL		USERRATTV(MAX_ATTR,*)	! real values
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call completion
					!     routine
					! = 1 for write more coords, if
					!     there are any, or else
					!     call USRRET
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable.
C
C don't send more than maximum number of attributes -- most important
C ===================================================================
C
.EL
.PG
.!
.HL 4 ^^^*>USRPZS\*
.LT
	SUBROUTINE USRPZS(SIZE,USERXYZ,USRFLG,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! input:  maximum number of
					!         coords to pass back
					! output: actual number of
					!         coords passed back
					! with this call
	REAL		USERXYZ(3,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call 
					!     completion routine
					! = 1 for write more coords, if
					!     there are any, or else
					!     call USRRET
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable.
.EL
.PG
.!
.HL 4 ^^^*>USRPST\*
.LT
	SUBROUTINE USRPST(SIZE,USERXY,USRFLG,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! input:  maximum number of
					!         coords to pass back
					! output: actual number of
					!         coords passed back
					! with this call
	REAL		USERXY(2,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call 
					!     completion routine
					! = 1 for write more coords, if
					!     there are any, or else
					!     call USRRET
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable.
.EL
.PG
.!
.HL 4 ^^^*>USRPZS\*
.LT
	SUBROUTINE USRPZS(SIZE,USERXYZ,USRFLG,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C	Dummy user routine
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! input:  maximum number of
					!         coords to pass back
					! output: actual number of
					!         coords passed back
					! with this call
	REAL		USERXYZ(3,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call 
					!     completion routine
					! = 1 for write more coords, if
					!     there are any, or else
					!     call USRRET
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable.
.EL
.PG
.!
.HL 4 ^^^*>USRPPT\*
.LT
	SUBROUTINE USRPPT(SIZE,USERXY,USRFLG,TEXTL,TEXT,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C
        IMPLICIT NONE
C
C Arguments
C
	INTEGER*4	SIZE		! input:  maximum number of
					!         coords to pass back
					! output: actual number of
					!         coords passed back
					! with this call
	REAL		USERXY(2,SIZE)	! coords
	LOGICAL*1	USRFLG(SIZE)	! flags (visibility only)
	INTEGER*4	TEXTL		!  input: max size of TEXT
					! output: actual size of TEXT
	CHARACTER*(*)	TEXT		! text string, if text feature
	INTEGER*4	RETCOD		! return code
					! = 0 abort, dont call completion
					!     routine
					! = 1 for write more coords, if
					!     there are any, or else
					!     call completion routine
					! = 4 for abort, call completion
					!     routine
C
C	All these arguments are writable.
C
.EL
.PG
.!
.HL 4 ^^^*>USRPTX\*
.LT
	SUBROUTINE USRPTX(TEXT,TEXTL,TS,THICK,ROT)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
C Arguments
C
	CHARACTER*(*)	TEXT		! text string, if text feature
	INTEGER*4	TEXTL		!  input: max size of TEXT
					! output: actual size of TEXT
	INTEGER*4	TS(4)		! feature status for texts
	INTEGER*4	THICK		! height of text
	REAL		ROT		! angle of text
C
C	All these arguments are writable.
C
.EL

.!
.PG
.HL 3 ^^^*Completing the USER command\*

.HL 4 ^^^*>USRRET\*
.LT
	SUBROUTINE USRRET(CNDFLG,RTSTRL,RTSTR,RETCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines.
C
        IMPLICIT NONE
C
C Arguments
C
	LOGICAL		CNDFLG		! LITES2 conditional flag
	INTEGER*4	RTSTRL		!  input: maximum size of RTSTR
					! output: size of RTSTR
	CHARACTER*(*)	RTSTR		! LITES2 command line, to be 
					! executed before any other
					! command
	INTEGER*4	RETCOD		! return code
					! = 0 for abort
					! = 1 for CNDFLG to be set
					!     and command to be executed
					! = 2 for call processing routine
					!     again
					! = 3 for call USRDEF before calling 
					!     this routine again
					! = 4 for call USRANO before calling 
					!     this routine again
					! = 5 for call USRDRW before calling 
					!     this routine again
C
C all these arguments are writable
C
.EL
.PG
.HL 4 ^^^*>USRDEF\*
.LT
	SUBROUTINE USRDEF(VARNAM_LEN,VARNAM,INDEX,INTVAL,REALVAL,
     &	                     DBLVAL,CHARVAL_LEN,CHARVAL)
C
C       Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
C Arguments
	INTEGER		VARNAM_LEN	! input: maximum size of VARNAM
					! output: size of VARNAM
	CHARACTER*(*)	VARNAM		! variable name to set
	INTEGER		INDEX		! element if VARNAM is array
	INTEGER		INTVAL		! integer value to set
	REAL		REALVAL		! real value to set
	REAL*8		DBLVAL		! double value to set
	INTEGER		CHARVAL_LEN	! input: maximum size of CHARVAL
					! output: size of CHARVAL
	CHARACTER*(*)	CHARVAL		! character value to set
C
C all these arguments are writable.	
C
.EL
.!
.PG
.HL 4 ^^^*>USRANO\*
.LT
	SUBROUTINE USRANO(RTSTRL,RTSTR)
C
C       Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
	INTEGER*4	RTSTRL		! input: maximum size of RTSTR
					! output: size of RTSTR
					! if 0 is returned no ANNOTATION
					! command is executed.
	CHARACTER*(*)	RTSTR		! secondary command (with
					! arguments) for the ANNOTATION
					! command
C
C all these arguments are writable.	
C
.EL
.!
.PG
.HL 4 ^^^*>USRDRW\*
.LT
	SUBROUTINE USRDRW(RTSTRL,RTSTR)
C
C       Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
	INTEGER*4	RTSTRL		! input: maximum size of RTSTR
					! output: size of RTSTR
					! if 0 is returned no DRAW command
	CHARACTER*(*)	RTSTR		! secondary command (with
					! arguments) for the DRAW command
C
C all these arguments are writable.	
C
.EL
.!
.PG
.HL 3 ^^^*Error Handling\*
.HL 4 ^^^*>USRERR\*
.LT
	SUBROUTINE USRERR(FATAL,ERRCOD)
C
C       Copyright Laser-Scan Ltd., Cambridge, England.
C
C Description
C
C	LITES2 cartographic editor user command routines .
C
        IMPLICIT NONE
C
C Arguments
C
	LOGICAL		FATAL		! .TRUE. if user routine is
					!        about to be aborted
					! .FALSE. if only a warning
	INTEGER*4	ERRCOD		! error code
C
C  Error numbers passed to USRERR
C  (errors marked with * are fatal)
C
C* trying to get ACs or coordinates when there is no found feature
	PARAMETER	USR_NOFEATURE	=  1
C
C trying to get ACs from feature with none
	PARAMETER	USR_NOACS	=  2
C
C* tried to create a feature, while in an invalid state to do so
	PARAMETER	USR_NONEWCONSTR	=  3
C
C* tried to create a feature in an non-existant map
	PARAMETER	USR_MAPNOTEXIST	=  4
C
C* tried to create a feature in a read only map
	PARAMETER	USR_MAPREADONLY	=  5
C
C* tried to create a feature in an non-existant layer
	PARAMETER	USR_LAYNOTEXIST	=  6
C
C* tried to create a feature with an non-existant feature code
	PARAMETER	USR_BADCODE	=  7
C
C* tried to create a generated feature with an impossible feature code
	PARAMETER	USR_INVALFC	=  8
C
C* tried to create a feature with the wrong number of points
	PARAMETER	USR_WRNGNOPTS	=  9
C
C trying to create text feature with a height of an illegal point size
C (defaulted to 24)
	PARAMETER	USR_UNKPTSIZ	= 10
C
C trying to create an AC that is too long. It has been truncated
	PARAMETER	USR_ACTOOLONG	= 11
C
C* trying to construct a feature with a coordinate outside the limits
C  of the map
	PARAMETER	USR_PTOUTRANGE	= 12
C
C* trying to create a feature with zero length text
	PARAMETER	USR_TEXTTOOSHORT= 13
C
C* other error while constructing feature.
C The feature has been abandoned.
	PARAMETER	USR_FTABANDONED	= 14
C
C* unrecognised return code returned by a USR* routine
	PARAMETER	USR_UNKRETCOD	= 15
C
C  trying to create text feature with an illegal height (in mms). Default
C  value used.
	PARAMETER	USR_UNKHTSIZ	= 16
C
C* error while setting a variable by a call of USRDEF
	PARAMETER	USR_VARIABLEERR	= 17
C
C* error while calling USRGMH
	PARAMETER	USR_MH_MD_ERR   = 18
C
C* error while calling USRANO
	PARAMETER	USR_ANNO_ERR    = 19
C
C* error while calling USRDRW
	PARAMETER	USR_DRAW_ERR    = 20
.END LIT
.!
.PG
.HL 2 ^*Compiling and linking a shared image.\*
.INDEX Linking the user routines
For detailed information about shared images, reference should be made
to the appropriate VAX VMS manuals. 
.BR; This section is intended only as a guide, to allow users to compile
and link their own simple images. 
.B
The required routines should be compiled normally, and then linked into
a shareable image by using the /SHARE qualifier in the link command.
.BL
To allow LITES2 to locate the entry points of the routines that it calls
it is necessary to include an options file that declares the required
routines as UNIVERSAL. (Other routines used within the image should not
be declared UNIVERSAL). 
.BL
If the user routine image contains any common blocks, then they must be 
set to be non-shareable using the PSECT__ATTR linker command.
^*
.NOTE
If this is not done then the error message "Writable shareable images 
must be installed" will be given when the routine is first invoked.\*
.BR
The solution to this error is to set the common blocks non-shareable;
do not try to install the shareable image!
.END NOTE
.B 2
There is an example user image supplied with LITES2 in the directory 
LSL$PUBLIC__ROOT:[LITES2.ROUTINES.EXAMPLE]. This may be built with the
command file EXAMPLE__ROUTINE.COM which calls USRLNK.COM. 
.BR; These illustrate the use of a library, USRLIB, which contains the 
specified user routines and any other subroutines that they call.
They also show how common blocks must be included as non-shareable
PSECTs in the link file.
.!
.B
^^^*EXAMPLE__ROUTINE.COM\*
.B
.LT
$	SET ON
$	ON ERROR THEN GOTO EXIT
$	SET VERIFY
$	LIBR/CREATE USRLIB
$	FORTRAN/NOOPT/DEBUG USRDO,USRERR,USRGAC,USRINI,USRPAC
$	FORTRAN/NOOPT/DEBUG USRRET,USRSTO,USRGCB,USRGTX
$	FORTRAN/NOOPT/DEBUG USRPCB,USRPTX,USRDEF
$	LIBR/REPL USRLIB USRDO,USRERR,USRGAC,USRINI,USRPAC,-
	                 USRRET,USRSTO,USRGCB,USRGTX,USRPCB,USRPTX,USRDEF
$!
$! and link it
$	@USRLNK
$EXIT:
$	PURGE USR*.*
$	SET NOVER
.EL
.TP 12
.B
^^^*>USRLNK.COM\*
.B
.LT
$	LINK/DEBUG/SHARE=EXAMPLE_ROUTINE SYS$INPUT:/OPT
USRLIB/INCLUDE=(USRDO,USRGAC,USRINI,USRPAC,USRRET,-
USRSTO,USRGCB,USRGTX,USRPCB,USRPTX,USRERR,USRDEF)/LIB
UNIVERSAL = USRDO,USRGAC,USRINI,USRPAC,USRRET,USRSTO
UNIVERSAL = USRERR,USRPTX,USRGCB,USRGTX,USRPCB,USRDEF
PSECT_ATTR=USRKEEP,NOSHR
PSECT_ATTR=USRKEEPC,NOSHR
PSECT_ATTR=USRFEAT,NOSHR
PSECT_ATTR=USRFEATC,NOSHR
$!
.EL
.!
.BL
To use this routine the logical name LSL$LITES2ROUTINES__1 should be set 
to point to the shared image. Then the command ROUTINE 1 1 can be given 
from LITES2, which gives instructions on how to use the rest of the 
shared image.

.BL
It should be noted that the above command files link a debugged 
version of this image. It is possible to use the debugger to examine the 
working of the image by giving the LITES2 command DEBUG. To set a break 
point on USRINI, for example, give the commands
.BL
.NOFILL
DBG_> SET IMAGE LSL$LITES2ROUTINES__1
DBG_> SET BREAK USRINI
DBG_> GO
.FILL
.NOTE
This will only be possible after the image has been mapped by at least 
one entry of the LITES2 command ROUTINE 1 x.
.END NOTE
.!

