.!
.! INTRO.RNO
.! This part of the LITES2 Reference manual talks about
.! introduction and general environment
.!

.REQUIRE "REF.HD"

.HL 1 ^^^*>Introduction\*
This manual is the main reference document for the Laser-Scan
Cartographic Editor LITES2. It is intended for any person who
uses LITES2 and it describes the editor environment and use, and each
editor command in detail.

.P 0
LITES2 is an interactive graphical editing program which has been
designed to be particularly suitable for work with cartographic type
data, but can also be used on other types of feature-orientated data. It
has facilities for reading, drawing, amending, creating, and deleting
features. 

.P 0
It is assumed that the user is already familiar with general use of the
VAX/VMS operating system (see the DEC VAX/VMS manuals), and with the
principles of digital cartography. This manual is supplementary to the
"LITES2 User's Guide", which should be read before any use is made of
LITES2, and before referring to this document. 

.P 0
This manual describes the full LITES2 command language, including some
commands which are included for compatibility with future enhancements.
The presence or absence of any facility from this manual does not imply
any future commitment by LSL. See the current version of the LITES2 SPS
(Software Product Specification) for a description of currently
supported facilities. 
.P 0
LITES2 is a reimplementation of the previous LSL cartographic editor
LITES1, (variously referred to as LITES, MADES, IGES, or SOLADI). The
reimplementation has achieved the following major advances over LITES1. 
.LIST '*'
.LE
More performance and greater throughput as LITES2 takes advantage of 32
bit computer architectures and modern software techniques. 
This also gives extended program lifetime and easier maintenance.
.LE
LITES2 is easier to use and without the petty restrictions of LITES1
which arose from its PDP11 and HRD-1 ancestry.
This gives more flexibility and adaptability to changing workloads.
.LE
Command names may be of arbitrary length instead of LITES1's three
characters, and may be abbreviated to minimum non-ambiguous abbreviation.
.LE
Macro commands are supported; users may define a name for a sequence of
commands. The sequence can then be invoked by typing the macro name, or
by assigning it to a menu square or cursor button, which are
user-programmable. 
.LE
All commands may be journalled to file to provide audit trails and error
analysis and recovery.
.LE
Command input from file is supported.  This allows recovery from
system failure using the command journal file, and also use of generated
"guidance files" for training, demonstrations, and semi-automated editing
using information from validation programs.
.LE
The sorted, sectored workspace file concept central to LITES1 has been
removed entirely. It has been replaced by operation directly on an IFF
file copy, giving greater speed, versatility and ease of future
enhancement. This also gives greatly increased compatibility with the
LSL IFF utilities. The speed of finding features within the IFF file is
maintained by keeping sectoring information in arrays in memory. 
.LE
LITES2 uses the Feature Representation Table (FRT) mechanisms instead of
the Legenda used by LITES1 to determine the graphical representation of
features. This means that symbols and text characters can include
arbitrary complexity of lines, curves and circle arcs, and that
patterned lines, fill areas, and user-defined character fonts are
supported. Overall, a screen picture much truer to finished map sheet
can be achieved. 
.LE
LITES2 calls graphics subroutines at the level of the new International
Standards Organisation's Graphical Kernel System (GKS). This defines an
abstract graphics device and greatly aids portability. Use of GKS also
allows easy integration of the new generation of GKS-based graphics
devices as they become available, with consequential increases in
performance. 
.END LIST

.PAGE
.HL 1 ^^^*>Environment\*
.HL 2 ^^^*>Computer\*
LITES2 runs on Digital Equipment Corporation (DEC) >VAX series
computers, running under the >VMS operating system.
Sufficient disc space must
be available to hold input, workspace, and output versions of the IFF
file containing the map being edited, as well as about 5M bytes for
program images and static data files. An appropriate graphics
workstation must also be available (see below) if graphic interaction is
required. 

.P 0
For further details of the VAX computer series, see the DEC documents
'VAX Technical Summary', and the 'VAX Handbooks' (which describe the
Architecture, Hardware, and Software of the machine). 

.P 0
For further details of VAX/VMS, see 'VAX Software handbook', published
by DEC. Other manuals of direct relevance to the user of this manual are
'Introduction to VAX/VMS', and 'VAX/VMS Command Language Reference
Manual'. 
.P 0
Refer to the LITES2 SPS (Software Product Specification) for currently
supported VMS versions and hardware and software prerequisites.

.HL 2 ^^^*Workstation\*
LITES2 can be run without graphic interaction on any DEC-compatible
alphanumeric terminal eg >VT320 >VDU. 
.P 0
For graphic interaction it requires an LSL-supported >GKS workstation
configuration. This can include either one or two graphics screens
(referred to as primary and secondary displays).
Refer to the LITES2 SPS (Software Product Specification) for currently
supported workstation types.

.P 0
.INDEX Refresh
.INDEX Highlight
The refresh capability of the graphical display serves to provide a
positional marker or cursor on the screen, to highlight features
selected on the screen and to provide temporary display within graphical
constructions. 

.PAGE
.HL 1 ^^^*Files used by LITES2\*
.HL 2 ^^^*Input data\*
LITES2 is used to display and edit map data. At
initialisation it reads one or more IFF files of map data and other files
containing information about the graphic representations of features,
layout of menus, tailoring options etc. At the end of a session, new
edited versions of the IFF files are produced.

.P 0
Each IFF file contains a single MAP.
.INDEX Layers
.INDEX Features
Data within a map may be grouped into LAYERS (sometimes known as
OVERLAYS). The basic elements of map data are called FEATURES. The
editor deals with twelve different categories or graphical types of
feature. See the >FRTLIB Reference Manual for details of treatment of
graphical types. The list is: 
.P 0
.NOFILL

         1      line string
         2      clockwise arc 
         3      anticlockwise arc
         4      three point arc
         5      full circle
         6      curve
         7      unoriented symbol
         8      oriented symbol
         9      scaled symbol
        10      text string
        11      symbol string
        12      fill area
.FILL

.HL 2 ^^^*Logical names\*
For LITES2 to run successfully, certain logical names must be set up to
point to directories and files used by the program. These will normally
be set up automatically, but there may be a need to alter them for
special purposes. 
.P 0
Logical name >LSL$LITES2LOCK must be set to the full file specification
of a file containing the LITES2 licence.
.P 0
Logical name >LSL$LITES2WORK must be set to a directory in which LITES2
is to put workspace and dump files. If a LITES2 session is terminated
abnormally (e.g. by computer failure, or CTRL/Y) then the workspace file
will be left in this directory, so the directory should be checked
periodically, and old versions of files deleted.
.P 0
Logical name >LSL$LITES2CMD must be set to a directory in which LITES2
expects to find command files (default extension .LCM). The edgematching
problem file is written to this directory.
.P 0
Logical name >LSL$LITES2JNL must be set to a directory into which LITES2
writes a journal file of commands given during a session (extension
_.LJN). It is advisable either to regularly purge this directory, or to
set a version limit on it (using the DCL command SET
DIRECTORY/VERSION__LIMIT=n), so that journal files do not build up
without limit. 
.P 0
Logical name >LSL$LITES2SETUP must be set to a directory in which LITES2
preserves table setup parameters for use in future sessions (extension
_.SET). It is often convenient to use the same directory as LSL$LITES2JNL
for this. 
.P 0
If the logical name >LSL$LITES2TERMINAL is set to a string, then this
string is used as the terminal name when naming device dependent files.
If LSL$LITES2TERMINAL is not assigned then the logical translation of
SYS$COMMAND is used as the terminal name. 
.P 0
If the logical name >LSL$LITES2ROUTINES is set to the full file
specification of a shareable image containing the LITES2 user routines,
then the LITES2 command USER will execute the code in this image. 
.BR
.INDEX LSL$LITES2ROUTINES__n
Similarly the logical names LSL$LITES2ROUTINES__n  (where n is an
integer in the ranges 1 - 5 or 101 - 105) supply the images to be
executed with the corresponding ROUTINE command. 
.BR
See the chapter on user routines for details of how to create your own
user routines. If these files are not present, then the corresponding
LITES2 commands will not be available. 
.P 0
Logical name >LSL$IF must be set to a directory in which LITES2 expects
to find IFF files (input and output map data). 
.P 0
Logical name >LSL$FRT must be set to a directory in which LITES2 expects
to find FRT, SRI, and TRI files (feature representation files). 
.P 0
Logical name >LSL$DTI must be set to a directory in which LITES2 expects
to find DTI image files.
.P 0
Logical name >LSL$LSI must be set to a directory in which LITES2 expects
to find LSI image files.
.P 0
Logical name >LSL$LSR must be set to a directory in which LITES2 expects
to find LSR image files.
.P 0
Logical name >LSL$HELP must point to the directory containing the LITES2
help library, LITES2.HLB. This may be used outside LITES2 by typing e.g.
$#HELP_/LIBRARY=LSL$HELP_:LITES2.
.P 0
If the logical name >LSL$LITES2INI is set to a file specification, then
the contents of this file will be read as a series of LITES2 commands,
when the program is first invoked (see section 4.3 below).
.P 0
By default the maximum number of user macros that may be declared is
600. This value may be altered by defining the logical name
>LSL$LITES2__MACROMAX to be the appropriate number.
.P 0
By default the maximum number of menu squares and puck buttons that may
be declared is 500. This value may be altered by defining the logical
name >LSL$LITES2__MENUSQUAREMAX to be the appropriate number.
.P 0
By default the maximum number of user variables that may be declared is
1000. This value may be altered by defining the logical name
>LSL$LITES2__VARIABLEMAX to be the appropriate number.
.P 0
As in other Laser-Scan programs which are able to fill areas, the
maximum number of points allowed in a solid filled area may be
controlled by defining the logical name >LSL$FILL__POINTSMAX to be the
required number. The default value is 8192 points, with the minimum
allowed being 100. Exceeding the limit for number of points will result
in fill areas being drawn incorrectly or being drawn as an outline. When
drawing raster images, LITES2 uses the same logical name to control the
maximum number of pixels that can be drawn across an image, so the
message "Buffer too small to draw DTI/LSR - zoom in or increase
LSL$FILL__POINTSMAX" can be
avoided in a future run of LITES2 by increasing the value of this
logical name. Similarly the maximum number of times which a scan line
may cross the boundary of an area may be controlled by defining the
logical name >LSL$FILL__CUTSMAX to be the required number. The default
value is 100 intersections, with the minimum allowed being 10. Exceeding
the limit for intersections will result in messages 'FILL__SIDE - Too
many intersections found - ignored'. Memory has to be allocated in
proportion to these numbers, so unnecessarily large values should be
avoided.
.P 0
If the logical name >LSL$IFF__OUTPUT__REVISION is set to the value 1,
then the IFF files that LITES2 outputs will contain CB entries and edits
made to point attributes will be retained. 
.INDEX CB entries
.INDEX ST entries
.INDEX ZS entries
If, however, LSL$IFF__OUTPUT__REVISION is set to the value 0, or is not
set up at all, the IFF files that LITES2 outputs will contain ST (and ZS
entries). The commands which add other attributes will still appear to
work, but the attributes will not appear in the file.
.P 0
The logical names >LSL$TEXT__ROUTINE and/or >LSL$SYMBOL__ROUTINE may be 
set to point to shared images that can be used to draw texts and symbols
differently from the standard FRT routines used by LITES2. More details
of this facility is available in the chapter on alternative text and 
symbol drawing routines.
.P 0
The logical name >LSL$LITES2__GET__SHEET__ROUTINES may be set to point
to a shared image which can be used to supply a user defined map
indexing system. This image is then called when the system variable
$MAP__SHEET is accessed. This substituted routine may be passed either
the absolute position of the cursor or its geographical position. 
Example source files that contain instructions to build this image are
supplied in LSL$PUBLIC__ROOT:[LITES2.ROUTINES.EXAMPLES] and are called
GET__SHEET__GEOG__EXAMPLE.FOR and GET__SHEET__GRID__EXAMPLE.FOR.
.BL
If this logical name is not set up, the variable $MAP__SHEET will use
the sheet naming  convention specified for the Ordnance Survey of
Great Britain.
.P 0
If the logical name >LSL$OS__MH__TABLE points to a file name, this
file will be opened and read as a translation table to locate the
update flags in OS map headers type 3 and 4 for use with the OPERATION
OS__MH__FLAGS command. If this logical name is not set up prior to
invoking LITES2, it will not be possible to read IFF files with these type
of map headers if an OPERATION OS__MH__FLAGS command has been given, or
it will not be possible to give an OPERATION OS__MH__FLAGS command after
reading IFF files that have these type of map headers. See the CONVERT
package documentation for details of this table and the logical name.
.P 0
The logical name >LSL$LITES2__TERMINATOR__MASK may be used
to control which
characters will be taken as line terminators when typed at
the terminal. It should be defined as a comma-separated list
of ASCII codes and ranges of codes (use quotes if the list
contains commas, otherwise a search-list will result). For
example
.BR;_$#DEFINE LSL$LITES2__TERMINATOR__MASK "13,26,128-159"
.BR;would cause carriage-return (13), Ctrl-Z (26), and also the upper
control characters (128-159) to terminate lines.
.BL
If the logical name is not defined, then it is left to the
VMS terminal driver to decide which characters are terminators.
This is affected by the command
.BR;_$#SET TERM/LINE__EDITING
.BL
The purpose of this is to allow characters which would by
default have terminated the line to be input as characters,
for example into text strings or AC entries. Note that even
if they are set not to terminate the line, most control characters
will not echo as anything sensible at the terminal.
.P 0
Certain functions in LITES2 are supplied as shared images, which are 
only mapped when they are first accessed. This keeps the LITES2 image
smaller, and thus more efficient, for those users who do not require
the extra functionality that these shared images supply. These shared 
images are pointed to by the following logical names:
.LIST
.LE;>LSL$LITES2__GEOG__ROUTINES
This logical name should point to LSL$EXE:LITES2GEOGSHR.EXE, an image
supplied by Laser-Scan that implements grid -_> geographical conversions 
as used by the GEOGRAPHICAL and SHOW GEOGRAPHICAL commands and the 
$LONGITUDE and $LATITUDE system variables.
.LE;>LSL$LITES2__GEOM__ROUTINES
This logical name should point to LSL$EXE:LITES2GEOMSHR.EXE, an image
supplied by Laser-Scan that allows the manipulation of the dynamic
data structures called `geometries'. The GEOMETRY command requires a
suitable licence.
.BR
This shared image itself makes use
of the image LSL$LIBRARY:LSLGOTHICSHR which is pointed at by the 
logical name LSL$LSLGOTHICSHR.
.LE;>LSL$LITES2__VIEW__ROUTINES
This logical name should point to LSL$EXE:LITES2VIEWSHR.EXE, an image 
supplied by Laser-Scan when the licence for the VIEW command is
supplied. This image implements the perspective viewing capability of 
LITES2, as supplied through the VIEW command.
.LE;>LSL$LITES2__KERN__ROUTINES
This logical name should point to an image, supplied by Laser-Scan, that
is used when a photogrammetric restitution instrument is used as a
3-dimensional input device to LITES2. The name of the image will vary depending
on the instrument in use, and whether it is equipped with an image
superimposition system for graphical display from LITES2.
.LE;>LSL$LSLGOTHICSHR
If LSR image files are to be displayed or edited, then this logical name
should point to a shareable image (normally LSL$LIBRARY:LSLGOTHICSHR, in
the LSLSYSTEM package). This will normally be done as part of the system
initialisation.
.END LIST

.HL 2 ^^^*Files created by LITES2\*
.HL 3 ^^^*Workspace files\*
.INDEX Workspace file
Maps read in by the IFF command are copied to a workspace IFF file
LSL$LITES2WORK:filename.WRK. This file is operated on during the editing
session, and is normally deleted at the end, unless the DUMP command is
used, when it is renamed as LSL$LITES2WORK:filename.DMP and may be used
for subsequent input to LITES2. The dump file is a valid IFF file, and
may be used as such by other programs, but as a result of editing it may
contain dead space, and the layers are likely to be fragmented. For this
reason, it is advisable to finally use the EXIT or WRITE command to
cause the workspace file to be tidied into a new version of the IFF
file. 

.HL 3 ^^^*Journal file\*
.INDEX Journal file
During a session, LITES2 writes all commands issued to a file
LSL$LITES2JNL:terminal.LJN (where "terminal" is either the SYS$COMMAND
device, e.g. TTA0, or the name defined by the logical name
LSL$LITES2TERMINAL). Optionally, any macros or command file directives
may be journalled, but preceded by the comment delimiter (_!), so that
the file may be used as command input to LITES2 to recover a session
lost for any reason. (See Recovery.) 

.HL 3 ^^^*Table setup file\*
.INDEX Table setup file
LITES2 saves the information concerning the positions of maps, menus,
and tracking areas in a file LSL$LITES2SETUP:terminal.SET. This enables
the old positions to be re-used in another LITES2 session, without
re-digitising. (See Table Setup.) 

.HL 3 ^^^*Edgematching problem file\*
.INDEX Edgematching
The edgematching routine writes a LITES2 command file
LSL$LITES2CMD:terminalPROB.LCM, usually overwriting any previous version.
If however ENABLE APPEND has been given, the LITES2 commands are added
to any existing version of the file.
.BR
This file is automatically invoked by the >REVIEW command, to guide the
operator through any problems encountered while edgematching. 

.HL 3 ^^^*SAVE MACRO files\*
The SAVE MACRO command causes a file LSL$LITES2CMD:macroname.LCM to be
written for subsequent input to LITES2. 

.HL 3 ^^^*Sector list file\*
The SAVE SECTORS command causes a file LITES2.PRT to be written to the
current directory. This is intended as a program development aid. 

.PAGE
.HL 1 ^^^*Using LITES2\*
.HL 2 ^^^*Running the program\*
In order to run LITES2, you must be logged in to VMS at a terminal. See
your System Manager if you do not have the Username and Password
required to do this. 

.P 0
At some sites, the system manager will have included LITES2 as part of a
captive command procedure so that the user will not have to give the
actual command to start up LITES2. However, if you are presented with
the "$" (dollar) prompt, then you can start up the program by typing 
.BLANK
LITES2

.P 0
The program will announce itself as 
.BLANK
LITES2 ([version]) V[n] of [hh:mm:ss dd-mmm-yy]",
.BLANK
where [version] is the name of the hardware specific version of LITES2 in
user, [n] is the version number, and [hh:mm:ss dd-mmm-yy] is the time and 
date of linking of this release. This is followed by a message
indicating the licensed users of this version. 
.P 0
There will then be a pause while first stage initialisation is carried
out, and normally an initialisation command file containing options and
menu definitions will be read. You will then be presented with a prompt
from LITES2, which is an asterisk by default, but may have been changed
in the initialisation command file eg 
.BLANK
_*
.BLANK
and commands to the program may be given (eg HELP).

.HL 2 ^^^*Command States\*
.INDEX Command States
.INDEX States

.P 0
There is underlying structure to editing operations, which often need to
be performed in a certain sequence or in the correct context. This
structure is reflected in the fact that LITES2 is always in one or other
of a small number of command states. Within each state, a given range of
commands is valid and certain commands or operator actions are used to
move between states. The main command states and their transitions are
shown diagramatically in the figure below. 

.P 0
On starting up, the editor is in INITIAL state in which options and
attribute files can be specified, and which continues until the commands
have been given which specify the map file(s) to be edited. The map is
then read-in to the workspace file, and optionally drawn. The editor
then enters READY state. It is possible to return to INITIAL state by
using EXIT, DUMP, or QUIT commands when DISABLE EXIT is in operation. 
.P 0
The majority of commands are available in READY state, which is the
principal operating level of the editor. LINE state is entered when a
linear feature is identified using the FIND command. TEXT state and
SYMBOL state are the equivalents for text features and symbols. 
.P 0
EDIT state and MODIFY state are both entered as the result of editing
operations which require an END command to terminate. ON state is
entered by commands which require the cursor to be constrained on a
linear feature. CONSTRUCT state is entered during construction of linear
features. 
.P 0
WINDOW state is entered by a WINDOW command to allow specification of an
area of the map to be enlarged onto the graphics screen, or by a REGION WINDOW
command for constructing a rectangular region. MACRO state is
entered while defining macro commands. AC state is entered to allow
editing of ancillary coding (AC/TC/CH entries). SETUP state is entered
while digitising map corners on a raster image on the screen. PAINT state
is entered while editing a raster image using the IMAGE PAINT command.
.P 0
The current program state is displayed by the command SHOW STATE. It is
also displayed in the status line (ENABLE STATUS), and is used as a
prompt if PROMPT STATE is in action. System variable $STATE is set to
the current state. 

.NOFILL
The possible program states are:

INITIAL   - Awaiting specification of input maps (IFF files)
READY     - Ready for an editing command, no operations in progress
LINE      - Line type feature found
CIRCLE    - Circle arc feature found
TEXT      - Text feature found
SYMBOL    - Symbol feature found
EDIT      - Edit operation on line type feature in progress
MODIFY    - Modification of text or symbol feature in progress
ON        - Constrained on line feature during part edit operation
WINDOW    - Defining a window for drawing
CONSTRUCT - Constructing a line type feature, or a BRIDGE
AC        - Editing ancillary codes of a feature or attribute set
DEBUG     - Not used
RECOVER   - Deleted (or 'limbo') feature found
SETUP     - Setting up corners of IFF files on a raster image
PAINT     - Editing a raster image using the IMAGE PAINT command
MACRO     - Defining a macro

.FILL
.TP 30
.LITERAL


                           INIT state
                               |
                          (IFF/READ commands)
                               |
                               V
                           READY state
                               |
        +------------------+---+------------+----------+--------+
        |                  |                |          |        |
        |                  |                |          |        |
(FIND text/symbol)    (FIND line)    (construct line)  |  (WINDOW command)
        |                  |                |          |        |
        V                  V                V          |        V
   TEXT or SYMBOL     LINE state    CONSTRUCT state    |   WINDOW state
      states         /        |                        |
        |           /         |                        |
        |          /          |                        |
        |         /           |                        |
        |        /            |                        |
  (editing command)     (constraining)         (MACRO command)
        |                     |                        |
        |                     |                        |
        V                     V                        V
 EDIT or MODIFY state     ON state                MACRO state

.END LITERAL

.HL 2 ^^^*LITES2 initialisation\*
When started up, LITES2 implicitly obeys the command @LSL$LITES2INI,
thus, if logical name >LSL$LITES2INI is set up to point to a file (with
defaults LSL$LITES2CMD:---.LCM), then this will be executed. This
mechanism is normally used to tailor LITES2 for a particular
application. 
.P 0
Next, LITES2 obtains the device name from the translation of
LSL$LITES2TERMINAL if it exists, or else from SYS$COMMAND. This will
normally be the user's login terminal e.g. TTA0. This is used to gain
access to several files specific to this terminal. The command @terminal
is implicitly obeyed, so that if, for instance, the user is on TTA0, the
file LSL$LITES2CMD:TTA0.LCM will be obeyed if it exists. This mechanism
is normally used to configure LITES2 for the particular hardware
available on each terminal line, or to set up menus and pucks. 
.P 0
Finally LITES2 obeys any commands given on the DCL command line, and is
then ready for interactive input. If LITES2 is to be run
non-interactively, then the commands for the complete session should be
contained in the initialisation files or command line. (These may of
course invoke other command files.) 
.P 0
.INDEX Privileged commands
Certain LITES2 commands ("privileged commands") are only valid if
encountered in initialisation files, so that a degree of control may
be exercised over the use of these by ordinary users.
.P 0
While reading initialisation files, the "Now in state..." messages are
suppressed independently of the setting of ENABLE NOW,
so that the defining of menus or pucks or other macros does not cause
an excess of messages to be output.

.HL 2 ^^^*LITES2 recovery\*
.INDEX Recovery
If a LITES2 session is lost for any reason (e.g. computer failure,
operator error), then there are two possible ways to recover it. The
preferred route is to utilise the journal file, but it may also be
possible to use the workspace file if this still exists. 

.HL 3 ^^^*Recovery from the journal file\*
.INDEX Journal file
Find out the name of the terminal on which the session was run (e.g.
TTA0), possibly using the DCL command SHOW TERMINAL. If
LSL$LITES2TERMINAL was used, then the translation of this will be needed
instead. Look for the journal file, LSL$LITES2JNL:terminal.LJN. If any
sessions have been run at this terminal since, the required journal file
may not be the most recent version, so check the file's creation date. 
.P 0
Check that the file is complete. If the file is LOCKED, then use the DCL
command UNLOCK on it. If part (or all) of the file appears to be missing,
and the number of blocks used is less than the number of blocks allocated
(as shown by the DCL command DIRECTORY), then use the DCL command
SET FILE/END__OF__FILE, and then edit to remove any garbage at the end.
If necessary, edit the file. If for instance the session was lost due to
the operator accidentally typing QUIT, then the QUIT command must be
removed, otherwise it will be executed again. 
.P 0
It is advisable to RENAME or COPY the journal file to a different
filename, to avoid confusion when LITES2 creates another of the same
name. It is convenient to rename the file into LSL$LITES2CMD: with
extension .LCM, so that the directory and extension need not be
specified when it is used e.g. 
.BR
$RENAME LSL$LITES2JNL:terminal.LJN LSL$LITES2CMD:CRASH.LCM
.BR
where CRASH is a name of your choice.
.P 0
Define logical name LSL$LITES2REC as the journal file, e.g.
.BR
$DEFINE LSL$LITES2REC CRASH (if file is LSL$LITES2CMD:CRASH.LCM)
.BR
and run LITES2.
.P 0
The command in the recovery file will be read instead of any
initialisation files. It will be necessary to set up maps on the table
if this was done in the original session. After reading the recovery
file, provided that it does not contain an EXIT, DUMP, or QUIT command,
LITES2 will prompt for interactive input, and editing may be continued. 
.P 0
Finally DEASSIGN logical name LSL$LITES2REC, so that LITES2 does not use
the recovery file for the next session. Delete the recovery file when it
is finished with.
.P 0
While reading a recovery file, LITES2 always continues on error, whether
or not ENABLE CONTINUE has been specified. 

.HL 3 ^^^*Recovery from the workspace file\*
.INDEX Workspace file
It may be possible to use the workspace file to recover a LITES2
session. The workspace file is a valid IFF file, and may be input to
LITES2 as an IFF file in the usual way. It will usually be necessary to
mend the workspace file before use using the IMP utility IMEND (which
replaces the old MIFF and IFT), as it will not have been closed
correctly. It is probable that one block (and possibly more) of the
workspace file will not have been written to disk when LITES2 terminates
abnormally. If the missing block is at the end of the file, then the
result will just be the loss of some data, but if a block in the middle
of the file is missing, then it may be impossible to access the data
after it. 
.P 0
If using the workspace file for input, then great care should be taken to
ensure that data is not lost.

.HL 2 ^^^*Interactive devices\*
.INDEX Interactive devices
.INDEX Digitising table
.INDEX Bitpad
Each version of LITES2 supports a number of interactive devices, such as
digitising tables and bitpads, in addition to a keyboard. For details of
the particular hardware supported by each version, see the appropriate
Workstation Guide. Nevertheless some general principles apply:
.P 0
.INDEX Tracking area
If a digitising table is used, then it will be possible to set up
source documents (maps), menus, and a tracking area on it. The digitising
puck will normally have more than one button on it, and in this case
each button may be programmed to execute a LITES2 command. The lowest
numbered button is usually reserved for tracking the screen cursor around
the map, or tracking area, and may not be programmed to do anything else.
If any other button is pressed while within a map or tracking area, the
cursor will be positioned to the appropriate place before the button's
own command is obeyed, so it is not compulsory to track the cursor to
the correct place first using the lowest numbered button. Some LITES2
commands cause the screen cursor to move to a computed position, for
instance CLOSE and LOOP (which create closed loops), and FIND (which moves
onto a nearby feature). If the next command after one of these is given
from a puck button, then no cursor movement will occur even if within
a map or tracking area. This allows, for instance, an END command to be
given without spoiling the computed cursor position, or having to move
the puck off the map area. Any button (but sometimes not the lowest
numbered button) may be used to access a menu box, but a facility exists
(PRIORITY PUCK) to cause certain buttons to perform their puck functions
even when pressed over a menu.
.P 0
The same comments as for tables apply to bitpads (tablets), but there
are some differences. Source documents may not be set up on bitpads
(they are usually too small and inaccurate). Bitpads are always
connected locally to the workstation, and can perform some sort of
cursor tracking on the screen without the intervention of the computer -
this often leads to LITES2 having two screen cursors - its own position
and the bitpad position. In these cases, the lowest numbered button on
the bitpad puck causes the LITES2 cursor to move to the position of the
bitpad cursor. Because of this local tracking, there is not usually any
reason to set up a tracking area on a bitpad. The other buttons may be
used to access bitpad menu boxes, or be programmed in their own right. 
.P 0
If a screen menu is provided, then it is usually accessed by moving the
bitpad cursor to the required box and pressing the lowest numbered
button. 

.HL 2 ^^^*LITES2 Table Setup\*
.INDEX Table Setup
If a digitiser is in use, then before reading in maps, or when the SETUP
AGAIN command is used, LITES2 will prompt the user to digitise the
positions of maps, menus, and tracking areas. At this point, the user
may digitise the points as requested, but also has the chance to abort
the setup, or to use the setup from a previous LITES2 session if
possible. 
.P 0
The setup of a map, menu, or tracking area may be aborted by pressing
CTRL/C at the keyboard (Control and C keys pressed simultaneously), or
by pressing the highest numbered button on any puck (provided that the puck
has been defined using the PUCK command).
.P 0
The previous setup values may be used by pressing the penultimate button
on any puck (again providing that the puck has been defined).

.HL 2 ^^^*Use of CTRL/C\*
.INDEX CTRL/C
LITES2 has its own CTRL/C handler, so that CTRL/C (pressing Control and
C simultaneously at the keyboard) may be used for several purposes. Note
that which function occurs will depend on what the program is doing at
the time. The functions of CTRL/C are as follows: 
.LIST '*'
.LE
Abort execution of any command files and macros returning to interactive
input. Also terminate RESPOND input. This will occur only when any
currently executing command completes. 
.LE
Terminate reading in of a map and proceed with the next map, if any.
Only the data read in so far is available
for editing and output. This feature may be useful for demonstration
purposes or in cases when the wrong map has been specified. A subsequent
QUIT with DISABLE EXIT in force will return to INITIAL state and allow
the correct map to be given. If reading in of an INSITU map is
prematurely terminated, then unless an EXIT/DUMP/QUIT command is given
immediately, the remaining data will be lost irrevocably. 
.LE
Abort re-drawing of the map. There may be a delay between pressing CTRL/C
and drawing actually stopping. This is useful if the wrong area is being
drawn. Editing may continue even though only part of the picture is drawn
on the screen.
.LE
Abort re-drawing an image, and proceed with the next one, if any.
.LE
Abort the drawing of labels.
.LE
Abort edgematching as soon as possible.
.LE
Pause MEND AUTOMATIC as soon as possible.
.LE
Abort the construction of a region using REGION IMAGE.
.LE
Abort image speckle removal using IMAGE SPECKLE CLEAR_/FILL.
.LE
Abort image editing operations using IMAGE CLEAR_/FILL_/COPY_/MOVE.
.LE
Terminate the output produced by the SHOW MACRO, SHOW MENU, SHOW PUCK,
and SHOW REGION commands.
.LE
Terminate a delay initiated by the WAIT command.
.LE
Abort a user routine that is creating multiple features. Note that
CTRL/C will only abort the user routine between calls of the user
supplied routines; it will not abort while the user supplied routines
are being executed.
.END LIST
If enabled, then CTRL/Y will return to a DCL prompt as usual. If done
by accident, then CONTINUE (or C) will continue with LITES2.

.HL 2 ^^^*Messages and Errors\*
.INDEX Errors
.INDEX Messages
LITES2 has 4 types of messages which can be output to the alphanumeric
terminal, indicating conditions of varying severity.
.P 0
Some messages are purely informational and are sometimes unsolicited, and
sometimes the result of an operator command requesting the information. These
are known as 'INFORM' type messages, and may be suppressed if required
using the DISABLE INFORM command.
.P 0
The sort of operator errors which are expected to occur occasionally,
such as failing to find a feature, or an invalid command, result in the
production of a 'MOAN' type message, which is preceded by '???', and is
usually accompanied by an audible warning. 
.P 0
'NASTY' type messages are preceded by '!!!' and should not normally
occur. They usually indicate that an internal consistency check has
failed, which may lead to catastrophic failure of the program. 
.P 0
The final type of message is 'LEARN' type, which is preceded by '...'.
These are only output if ENABLE LEARN is in operation, and are intended
to provide extra information while learning to use the program. 
.P 0
The occurrence of a 'MOAN' or 'NASTY' error will result in any macros and
command files being abandoned, and LITES2 returning to interactive input,
unless ENABLE CONTINUE is used.

.PAGE
.HL 1 ^^^*Editing Operations\*
.HL 2 ^^^*>Feature >Selection\*
.INDEX Feature-In-Hand
.INDEX Found-Feature
.INDEX Feature Selection
A fundamental concept of the editor is the concept of the FOUND-FEATURE,
and of the FEATURE-IN-HAND. The found-feature is a feature selected by
the operator to be the subject of editor operations. Selection is
normally by positioning the cursor close to the desired feature and
issuing the FINd command, but there are alternative provisions for
finding a feature by global searches. Refer to the FIND, SEARCH, and
LOCATE commands below for more information. 
.P 0
When an editing command is given, any found-feature becomes the
FEATURE-IN-HAND in order that a second feature can be found if needed
for the editing operation. For example, during a complex editing
operation such as JOIn, there will be both a feature-in-hand which is
the line to join from, and also a found-feature, which is the line to
join to. 

.P 0
The current found-feature, and feature-in-hand, if any, are highlighted
in refresh mode on the display screen. For linear, arc, curve and symbol
string features, the string of line segments linking the data points is
highlighted (or a portion of it if the whole cannot be refreshed). 
For symbol features the whole symbol is highlighted.
For text features each character is highlighted, or on some workstations
a highlighted box is drawn around the text,

.HL 2 ^^^*Attributes of Points\*
.INDEX point attribute
.INDEX attributes of points
When carrying out geometrical edits on features which have attributes
associated with their defining points, it is not always possible, or 
meaningful, to retain these attributes.
.P 0
In particular, when linear features are FILTERed, then the whole new
feature will be created with no point attributes. (Note that squaring
and offsetting does retain point attributes) 
.P 0
When new points are created within features (e.g. with the various 
PART operations or with the CLIP, INSERT or BRIDGE commands) then the 
new point created does ^*not\* inherit any of the attributes of 
the points adjacent to it. When JOINing two features together, two 
points are condensed into one; in this case the resulting point inherits 
the attributes of the point that was found when the JOIN command was 
given.
.P 0
.NOTE
With all these editing operations, attributes can be automatically edited
or added by the use of the OPERATION command.
.END NOTE
.PAGE
.HL 1 ^^^*LITES2 command language\*
.INDEX Command Language
This section is not concerned with the functions of LITES2 editing
commands, which are described individually below, but rather with the
use of the command language and programming facilities to set up menus
and pucks, and to combine the primitive operations into more
sophisticated procedures. Where a particular command is mentioned, its
exact syntax and function should be looked up in the individual
descriptions. 

.HL 2 ^^^*Command lines\*
.INDEX Command lines
LITES2 command lines are lines of text, up to 255 characters long, which
may be obtained from the keyboard, or other interactive controls, or
from a command file on disc. (The interactive interface ensures that
button presses and menu probes have the identical effect to typing
commands at the keyboard.) 
.P 0
.INDEX Commands
A command line consists of zero or more ^*commands\*, separated by the
character "_#", followed by an optional comment preceded by the
character "_!". The characters "_#" and "_!" may ^*never\* be used for
any other purpose. 
.P 0
.NOFILL
For example:  FIND _# DELETE _! deletes the nearest feature
.FILL

.HL 2 ^^^*Commands\*
.INDEX Commands
.INDEX Primary command
.INDEX Secondary command
.INDEX Primitive command
.INDEX Labels
.INDEX Command labels
LITES2 commands consist of an optional ^*label\* (beginning with "." and ending
with ":"), optionally followed by a ^*primary command\*. In some
cases, this may form the entire command (eg FIND). Some primary commands
must be followed by one of several ^*secondary commands\* (eg SEARCH
ALL). In some cases a default secondary command is assumed if this is
omitted (eg SEARCH is equivalent to SEARCH NEXT). Both primary and
secondary commands may be shortened to the minimum non-ambiguous
abbreviation. 
.P 0
Commands may be followed by compulsory or
optional ^*arguments\*
.NOFILL

eg TOLERANCE FIND 3.0   (argument is compulsory)
   POSITION 400.0 450.0 (arguments are optional)
   POSITION             (position to centre of screen is assumed)

.FILL
The precise effect of omitting an optional argument is described with
each individual command.

.HL 2 ^^^*Arguments\*
.INDEX Arguments
Command arguments are in general integer numbers, real numbers, or text
strings. An integer number may not have a decimal point. Where a real
number is required, the decimal point may be omitted when an integral
value is desired, and scientific or exponent notation (eg 1.3E-3 =
0.0013) is permitted. Real numbers may also be entered in a 'rational'
format (eg 2/3 for two thirds, or 0.6666667).
.P 0
In the case of text arguments, exactly what is required is described
with the individual commands, but it should be noted that in the case of
commands taking an arbitrary text string (eg for insertion in the map
data, or as a message), any leading spaces or tab characters are
ignored. The text may be enclosed in double quotation marks, within
which a repeated quotation mark may be used to include a quotation mark
in the text. Quotation marks ^*must\* be used if leading spaces or tabs
are to form part of the text. 
.P 0
A few commands that deal with ancillary codes (ACs) or point attributes
.INDEX point attribute
take a special form of argument, consisting of a code, (usually referred 
to as a "type" when referring to ACs), possibly followed by a value.
.P 0
The code is either an integer which identifies the attribute, or a name 
that corresponds to this integer. Laser-Scan has defined some codes and
names that are available to all users, but it is possible for the user 
to define his own in addition. This is done in the ACD (attribute code 
definition) part of the FRT.
.BR
Details of the Laser-Scan standard codes and of how to define further 
codes can be found in the "FRT User Guide".
.P 0
The format of the value part of the argument depends on the data type 
associated with the attribute code. Each of the Laser-Scan standard 
attribute codes has a data type associated with it; user defined 
attribute codes have data types associated with them when they are 
defined in the FRT.
.BL 
The possible data types are:-
.LIST '*'
.NOFILL
.LE;Integer
This is a integer or "whole" number.
An example of valid integer value is
.BL
##########24
.LE;Real
This is a real or "floating point" number.
Examples of valid real values are
.BL
##########3.414
##########366
##########0.123E3
.LE;Character
.FILL
This is a string of 4 characters. It can optionally be surrounded 
by quotation marks when entered as an argument. The string will be padded
with spaces on the right if shorter than 4 characters.
.NOFILL
Examples of valid character values are
.BL
##########"abcd"
###########abcd
##########"###d"
.LE;Date
.FILL
This is the date part of a VAX/VMS date/time string. It consists
of a one or two digit integer representing the day of the month (in the
range 1 - 31), followed by '-', followed by three upper case letters
representing the month (JAN,FEB...DEC), followed by '-', followed by a
four digit integer representing the year (eg 1987). Any part of
the date can be missed out, but not the '-'s. If any part is missing,
then the field is filled in from the current date. In particular the
date '--' is interpreted as 'today'. 
.BR
The valid range of dates is from 17-NOV-1858 to 31-DEC-9999
.NOFILL
Examples of valid dates are
.BL
###########2-JAN-1987
##########31-DEC-1899
##########--########################today's date
.LE;Time
.FILL
This is the time part of a VAX/VMS date/time string. It consists
of a one or two digit integer representing the hour of the day (in the
range 0 - 23), followed by ':', followed by a two digit integer
representing the minute of the hour, followed by ':', followed by a real
number with two digits before the decimal point representing the seconds
of the minute. Any part of the time can be missed out, but not
the ':'s. If any part is missing, then the field is filled in from the
current time. In particular the time '::' is interpreted as 'just now'. 
.BR
The valid range of times is from 00:00:00.00 to 23:59:59.99
.NOFILL
Examples of valid times are
.BL
##########02:23:45.76
##########2:00:00.00
##########::########################just now
.END LIST
.FILL

.HL 2 ^^^*Command files\*
.INDEX Command files
LITES2 commands may be stored in a disk file. Each line of the file is a single
command line as described above. The command file is invoked by the command
@filename, optionally followed by parameters. The commands in the file are then
obeyed until the end of file is reached, when control returns to the command
following the @filename directive. Command files may invoke other command files
up to a certain level of nesting. 
.P 0
The most common use of command files is for LITES2 initialisation, but
their use is not restricted to this. A possibly lengthy and rarely used
sequence of editing commands may be better stored as a command file than
as a macro (see below). A macro could still be set up to invoke the file
rather than having the user type @filename.

.HL 2 ^^^*Macros\*
.INDEX Macros
Macros provide a mechanism for the user to extend the LITES2 command
language by adding new 'commands' which perform sequences of existing
commands. The definition of a macro is begun using the MACRO command,
after which all commands are stored as part of the macro (rather than
being obeyed immediately) until the ENDMACRO command is encountered. Any
calls to other macros, or @filename directives are merely checked for
syntax during macro definition. Once defined, a macro is invoked merely
by giving its name, optionally followed by parameters. It may also be
used in JUMP commands (see below). 
.P 0
It is possible to define a macro with the same name as one of the
LITES2 primitive commands (or whose abbreviation is the same as that of
a primitive command). In these circumstances, the macro will take
precedence. If the primitive command is intended, the command name should
be preceded by the character "_%" which prevents the command being looked
up as a macro.
.P 0
It is good practice to use the "_%" escape character with primitive
commands in macros and command files, so that these will continue to
work even if macros with ambiguous names are defined later. (Command
decoding will also be slightly faster.) 

.HL 2 ^^^*Parameters\*
Parameters may be passed to command files and macros using the commands
@file, JUMP, JTRUE, JFALSE, and the normal macro call invoked by giving
the name of the macro. All these commands may be followed by a line of
parameters, each delimited by one or more spaces or tabs, or enclosed
in double quotes. Within the command file or macro, the values of the
parameters are available in the character system variables $P1, $P2 etc.
The number of parameters is available in $PCOUNT, and the whole line
of parameters in $PLINE.
.P 0
The parameters are only available within the command file or macro
actually called. If this calls another command file or macro, then
a new set of parameters will be available within the inner procedure.
When the flow of control returns to the outer procedure, then the
first set of parameters will be available again.
.P 0
For example:
.BR;_* add__text Red House
.BR;calls a macro passing two parameters. $P1 = "Red", $P2 = "House",
$PCOUNT = 2, and $PLINE = "Red House" (the parameters do not actually
contain the quotes).
.P 0
_* add__text "Red#House"
.BR;This time there is only one parameter, $P1 = "Red#House". $PLINE does
contain the quotes.

.HL 2 ^^^*Pucks and Menus\*
.INDEX Pucks
.INDEX Menus
Programmable menus and pucks are implemented using macros. Once defined,
using a PUCK or MENU command, the macros menuname1 up to menunameN (where
menuname is the name of the menu or puck, and N is the number of boxes or
buttons) are available to be defined using MACRO commands.
.P 0
Spaces between the menu name and the box number are optional. The macros
for unused boxes or buttons should be left undefined - they will then do
nothing. Menu or puck macro commands are normally generated
automatically by the interactive interface when the boxes are probed or
the buttons pressed, but there is nothing to prevent them being used at
the keyboard, or in command files or other macros. 
.HL 3 ^^^*Keyboard function keys\*
.INDEX Function keys
.INDEX Keypad keys
The function keys on DEC VDU terminals may be used as a programmable
puck in LITES2. Use the PUCK command to define a puck on device 0, and
then program the puck macros to execute the desired LITES2 commands.
Buttons 1-49 are used, though not all of these have a corresponding
keyboard key. This facility depends on a key transmitting the
appropriate escape sequence to the computer and cannot utilise any key
definitions using the DCL DEFINE/KEY command. Some terminals may allow
keys to be programmed to send a string of characters to the computer
just as if they had been typed - such a facility may be used instead of
the mechanism described here.
.P 0
F1 through to F5 cannot be used to give LITES2 commands. Which of the
other keys are available depends on the terminal settings using the DCL
commands SET TERM/[NO]LINE__EDITING, and SET TERM /APPLICATION__KEYPAD
or /NUMERIC__KEYPAD. If the terminal is set to perform line editing, then F6
through F14 and the arrow keys will perform their line editing function
and cannot be used to give LITES2 commands. If line editing is disabled,
then these keys may be programmed. The keypad numeric keys, and also '.'
'-' ',' and Enter may only be programmed if APPLICATION__KEYPAD is set,
otherwise they just transmit their own character. The remaining keys
(there are 16 of them) may always be programmed. The DCL SET TERM
commands may be SPAWNed from LITES2, and some settings (particularly
APPLICATION or NUMERIC KEYPAD) may sometimes be set locally on the
terminal.
.P 0
.TP 20
The layout of a VT220 type keyboard is shown below, with the puck button number
shown below each key
.NOFILL

F1 F2 F3 F4 F5  F6 F7 F8 F9 F10  F11 F12 F13 F14  Help Do  F17 F18 F19 F20
 x  x  x  x  x   6  7  8  9  10   11  12  13  14   15  16   17  18  19  20

                                            Fin Ins Rem    PF1 PF2 PF3 PF4
                                             40  41  42     21  22  23  24

                                            Sel Prv Nxt     7   8   9   -
                                             43  44  45    37  38  39  25

                                                Up          4   5   6   ,
                                                46         34  35  36  26

                                          Left Down Right   1   2   3
                                           48   47   49    31  32  33

                                                            0       .  Ent
                                                           30      28   27
.FILL
.HL 2 ^^^*Labels\*
Any command may be preceded by a label. This begins with ".", consists
of letters, numbers, and underline characters, and is terminated by ":".
The case of the letters in a label is not significant. The label may be
used as a target for JUMP, JTRUE, and JFALSE commands (qv), and must be
in the same command line, or macro as the command which refers to it.
These is no need for labels in different macros to be different, but if
duplicate labels occur in the same macro, then the first one will always
be found.

.HL 2 ^^^*Flow of control\*
The command file directive (@filename) and the macro call (macroname),
which have already been introduced, pass execution to the appropriate
command file or macro. Calls may be nested up to a certain limit. 
.P 0
Unless affected by the mechanisms described below, commands are obeyed in
order one by one until the end of a command line is reached. A new line
is then obtained from the current source (command file or interactively).
A macro is treated internally as a single line with multiple commands
separated by "_#". When the current source is exhausted, execution
continues at the command following that which invoked the command file
or macro.
.P 0
One way in which the flow of control can be altered is if a command
causes a MOAN or NASTY type error. Unless ENABLE CONTINUE has been used,
this causes all currently active command files and macros to be
abandoned, and control is returned to interactive. This mechanism (with
DISABLE CONTINUE in force) can be used to terminate a repetitive
sequence (eg when SEARCH NEXT gives an error because there are no more
features), but this method is not recommended since it will fail if
there is no interactive input available (as for instance in a batch
job). 
.P 0
The next method of altering the flow of control is the JUMP command.
This transfers control to a named macro or label. In the case of a JUMP
to a macro, any commands following the JUMP
at the current level (macro or command file) are abandoned and execution
begins at the start of the named macro. This means that is is only
sensible for JUMP to occur as the last command in a command file or
macro, unless the following command has a label which is the target of
a JUMP elsewhere. A label must occur in the same macro or line as the JUMP
command which refers to it.
.P 0
JUMP does ^*not\* use up a level of macro/command file nesting, and the
target of the JUMP ^*can\* be the current macro. This means that simple
repetitive loops can be constructed using macros which repeat until a
error occurs. NB DISABLE CONTINUE ^*must\* be in force, otherwise CTRL/C
must be used to break out of the loop. 
.P 0
More versatile than JUMP are JTRUE, JFALSE, THEN, ELSE, and ABORT. The behaviour
.INDEX condition flag
of these depends on whether the ^*condition flag\* (see below) is TRUE
or FALSE.
.P 0
JTRUE and JFALSE are the same as JUMP, except that the jump is only made
if the conditional flag is TRUE or FALSE respectively. Unlike JUMP,
these therefore can usefully be followed by other commands in a command
file or macro. 
.P 0
THEN and ELSE are followed by a command (possibly itself a macro or
@filename) which is obeyed only if the condition flag is TRUE or FALSE
respectively. These ^*do\* use up a level of command nesting, and also
differ from JUMP in that, whether or not the command is obeyed,
execution continues at the next command. 
.P 0
The ABORT commands may be used just to terminate execution of procedures. ABORT
INPUT terminates all active command files and macros and returns to interactive
input, while ABORT ALWAYS (the ALWAYS secondary command is optional) just skips
the rest of the current line or macro. ABORT TRUE and ABORT FALSE are the same
as ABORT ALWAYS, but depend on the setting of the condition flag. ABORT FILE
skips the rest of the current command file, even if called from within a macro
invoked by the command file.
.P 0
The condition flag used by JTRUE, JFALSE, THEN, ELSE, and ABORT is set using
the commands TEST, OR, and AND. These compare the value of a LITES2
^*variable\* (see below), with an ^*expression\* (see below). 
.P 0
The RESPOND command will pause execution of a macro or command file and
prompt for the user to enter commands interactively. When finished, the
CONTINUE command will return control the the command file or macro,
alternatively CANCEL RESPOND or CTRL/C may be used to abandon all
command files and macros and return to ordinary interactive input.

.HL 2 ^^^*LITES2 Variables\*
.INDEX Variables
LITES2 variables are named entities which may be used to hold a character
or numerical value. Variables may be one of four types:
.NOFILL

CHARACTER: Contains a string of characters
INTEGER:   Contains an integer value in the range -2147483648 to 2147483647
REAL:      Contains a real value value in the range +/- 0.29E-38 to
           1.7E38 with a precision of 7 to 8 decimal digits. Real
           variables are displayed with 8 significant figures (with
           trailing zeros suppressed) but the eighth figure may not be
           completely accurate.
DOUBLE:    Contains a real value value in the range +/- 0.29E-38 to
           1.7E38 with a precision of 15 decimal digits.

.FILL
Variables may be used in several different ways:
.LIST '*'
.LE
Their value may be substituted into commands
.LE
Their value may be tested in TEST, AND, and OR commands
.LE
They may be used to perform arithmetic in LET commands
.LE
They may be used in INQUIRE to obtain a value interactively
.END LIST
.P 0
.INDEX System variables
Some variables always exist within LITES2. These have names which begin
with the character "_$", and are known as ^*system variables\*. They
contain values such as the current cursor position, or the current
point on the found feature, and may not be set by the user. Some system
variables have a compulsory argument (or subscript), e.g. $CUTREGION 2,
and a few have an optional argument, e.g. $CURSINWIN 0.8.
A complete list of available system variables is given below. 
.P 0
User variables must be declared using the DECLARE command before use.
They can then be given values using the LET and INQUIRE commands. 
It is possible to declare array variables by following the name by the
number of elements required.
.P 0
By default the maximum number of user variables that may be declared is
1000. This maximum may be altered by setting the logical name
>LSL$LITES2__VARIABLEMAX to the required value before LITES2 is started.
.P 0
The current value of variables can be displayed using the SHOW VARIABLES
command, and can be tested using the TEST, AND, and OR commands.
.P 0
The value of a variable may be substituted into a command by enclosing
its name in single quotation marks (provided that ENABLE SUBSTITUTION is
set). The trailing quotation mark may usually be omitted, as the variable
name is taken to end at the first character which is not alphabetic or an
underline. The trailing quote therefore must be present if two variables
are to be substituted without any intervening spaces. If present, the
trailing quote must immediately follow the variable name. There is no
restriction on which parts of a command may use a variable. The
substituted value may be a single argument, or (usually for a character
variable) several arguments or even the whole command. 
.P 0
Eg. The command:  SEARCH FSN 'NUMBER' will search for serial number 3 if NUMBER
is an INTEGER variable with value 3. The effect would be identical if NUMBER
were a CHARACTER variable containing the string "3", but note that only
INTEGER, REAL, and DOUBLE variables can be used for arithmetic and to perform
numerical comparisons. 
.P 0
In the case of array variables, another integer variable may be used as
the subscript, thus if FSNS was an integer array containing a list of
feature serial numbers, and I was an integer variable containing the
required subscript, then the command:  SEARCH FSN 'FSNS'I'' could be
used. Both the trailing quotes are optional. A particular subscript
may of course be used explicitly, as in  SEARCH FSN 'FSNS4'.
.P 0
The values of variables are never substituted while a macro is being
defined. The presence of ' in any line in a macro will prevent the line
being checked for syntax as the macro is defined, since the value of the
variable is unknown at this stage. 

.HL 3 ^^^*Expressions\*
Expressions are used in the commands LET, TEST, AND, OR, and INQUIRE to
set and test the values of variables. 
.P 0
For CHARACTER variables, an expression consists simply of a string of
characters. The string may be completely absent (the empty, or
null string), and may optionally be enclosed in double quotation marks.
Within double quotes, the character " is represented by "". The trailing
quotation mark may always be omitted. The case of letters in character
variables matters, so that, for instance a variable containing "A" will
not be considered equal to the expression "a". 
.P 0
For INTEGER, REAL, or DOUBLE variables, an expression consists of one or more
numbers together with the operators + - _* / and _^ (exponentiate), and
functions (SIN, COS, TAN, ASIN, ACOS, ATAN, ABS, LN, LOG - see below). Unary
minus and functions have highest precedence, followed by _^, then _* and
/, then + and -. Operators of equal precedence are evaluated from left
to right. Parentheses ( and ) may be used to force the order of
evaluation. Note that the exponentiation operator may be used to obtain
square roots, e.g. 4_^0.5 is 2. 
.P 0
When setting an INTEGER variable using LET or INQUIRE, an attempt is
made to evaluate the expression using integer arithmetic. If this fails
(due to the presence of a decimal point, an E exponent, or a real valued
function), then real arithmetic is used, with the final result being
truncated to integer. 
.P 0
When setting a REAL or DOUBLE variable, the expression is always evaluated
using real arithmetic.
.P 0
If an INTEGER variable is compared with a real expression in a TEST,
AND, or OR command, then the integer is converted to real before the
comparison. 
.P 0
For example (assuming I is an INTEGER variable, and R is a REAL):
.NOFILL

   LET I=(3+8)/3 + 2/3   sets I to 3 using entirely integer arithmetic
   LET I=(3+8)/3.+ 2/3   sets I to 4 since decimal point forces real arithmetic
   LET R=(3+8)/3 + 2/3   sets R to 4.333333 (real arithmetic always used)

.FILL
.HL 2 ^^^*Logical variables\*
.INDEX Logical variables
Variables may be tested as logicals in a TEST, AND, or OR command. If the
variable name is specified with no inequality or expression, then the
logical result of the test is as follows:
.NOFILL

INTEGER variable   True if low bit is set (value is odd)
REAL variable      True if not equal to 0.0
DOUBLE variable    True if not equal to 0.0
CHARACTER variable True if low bit of first character is set

.FILL
In particular, this means that for INTEGER variables, 0 is false and -1
is true. These values are used for system variables which take a logical
value. For CHARACTER variables, strings beginning with "Y" or "y" are
true, while strings beginning with "N" or "n" are false. The null string
is false. 

.HL 2 ^^^*System variables\*
System variables have names beginning with the character $. The available
system variables can be displayed using the command "SHOW VARIABLES $".
An error results if an attempt is made to use a system variable which is
undefined e.g. $FSN when there is no found feature. A list of available
system variables follows:

.LM +10
.P -10;$ABSX
.BR;DOUBLE  Contains absolute X value of cursor position (IFF units). It
is equivalent to $CURSX + $MDOFFSET1
.P -10;$ABSY
.BR;DOUBLE  Contains absolute Y value of cursor position (IFF units). It
is equivalent to $CURSY + $MDOFFSET2
.P -10;$ACCVALUE
.BR;CHARACTER  Contains the value (as 4 characters) of the current AC of
the feature.
.P -10;$ACDATATYPE
.BR;INTEGER  Contains the data type of the current AC of the feature. The data
type is an integer in the range 1 - 5.
.BL
.NOFILL
1 means interpret the value as an integer
2 means interpret the value as a real number
3 means interpret the value as 4 characters
4 means interpret the value as a date
5 means interpret the value as a time
.FILL
.P -10;$ACIVALUE
.BR;INTEGER  Contains the value (as an integer) of the current AC of the
feature.
.P -10;$ACNAME
.BR;CHARACTER  Contains the name allocated to the type of the current AC
(in either the LSL supplied list of types, or in the current FRT)
.P -10;$ACPRESENT
.BR;INTEGER  -1 if the found feature has any ACs, TCs or CHs, else 0
.P -10;$ACRVALUE
.BR;REAL  Contains the value (as a real) of the current AC of the feature.
.P -10;$ACSVALUE
.BR;CHARACTER  Contains the value (as an character string) of the current
AC of the feature. This string is encoded using an
appropriate format, depending on the data type.
.P -10;$ACTEXT
.BR;CHARACTER  Contains the text of the current AC (or TC or CH) of the feature.
.P -10;$ACTEXTLEN
.BR;INTEGER  Contains the length of the text of the current AC (or TC or CH)
of the feature.
.P -10;$ACTOTAL
.BR;INTEGER  Contains the total number of ACs, TCs and CHs associated with
the feature. 
.P -10;$ACTYPE
.BR;INTEGER  Contains the type of the current AC of the feature.
.BR;Note: TCs are considered to be ACs with a type of -1,
and CHs are considered to be ACs with a type of -2.
.P -10;$ANGLE
.BR;REAL  Contains the angle (anti-clockwise from horizontal) in degrees
of the current feature. For linear features this is the angle
of the current vector.  This variable is not available for circle arcs.
.P -10;$ANNOTATION__JOURNAL__NAME
.BR;CHARACTER  Contains the name of the current annotation journal macro.
.P -10;$ANNOTATION__JOURNAL__STATUS
.BR;INTEGER  Contains the status of annotation journalling. 0 closed,
1 off, 1 on.
.P -10;$AREA
.BR;DOUBLE  Contains the area enclosed by the current feature in square
IFF units. For features that are not closed, the first point is
considered to be joined to the last, by a straight line. For texts and
symbols the area of the bounding box is given.
.BR
 A positive area indicates that the feature has been digitised in a
clockwise direction, negative areas indicate counter clockwise
digitising. Degenerate features (with two or less vertices) give an area
of 0.0 
.P -10;$ASK__CHAR n  Must be followed by an integer in the valid range;
this range is determined by which ASK command has been called.
.BR;CHARACTER Contains character value(s) from the last successful
invocation of an ASK command that returned character values.
.P -10;$ASK__INT n  Must be followed by an integer in the valid range;
this range is determined by which ASK command has been called.
.BR;INTEGER  Contains integer value(s) from the last successful invocation
of an ASK command that returned integer values.
.P -10;$ASK__REAL n Must be followed by an integer in the valid range;
this range is determined by which ASK command has been called.
.BR;REAL     Contains real value(s) from the last successful invocation of
an ASK command that returned real values.
.P -10;$ATTCODE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;INTEGER  Contains the code (as an integer) of the specified attribute of
the point.
.P -10;$ATTCVALUE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;CHARACTER  Contains the value (as 4 characters) of the specified attribute
of the point.
.P -10;$ATTDATATYPE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;INTEGER  Contains the data type of the specified attribute of the point.
The data type is an integer in the range 1 - 5.
.BL
.NOFILL
1 means interpret the value as an integer
2 means interpret the value as a real number
3 means interpret the value as 4 characters
4 means interpret the value as a date
5 means interpret the value as a time
.FILL
.P -10;$ATTIVALUE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;INTEGER  Contains the value (as an integer) of the specified attribute
of the point.
.P -10;$ATTNAME n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;CHARACTER  Contains the name allocated to the type of the specified
attribute of the point (in either the LSL supplied list of
types, or in the current FRT).
.P -10;$ATTRVALUE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;REAL  Contains the value (as a real) of the specified attribute of the
point.
.P -10;$ATTSVALUE n  Must be followed by an integer in the range 1 - $ATTTOTAL.
.BR;CHARACTER  Contains the value (as a character string) of the specified
attribute of the point. This string is encoded using an
appropriate format, depending on the data type.
.P -10;$ATTTOTAL
.BR;INTEGER  Contains the total number of attributes associated with the point.
.P -10;$BEARING
.BR;REAL  Contains the bearing (clockwise from grid north) in degrees
of the current feature. For linear features this is the bearing
of the current vector.  This variable is not available for circle arcs.
.P -10;$BOX n  Must be followed by an integer in the range 1 - 4.
.BR;REAL  Contains the coordinates of the limits of the box surrounding
the current feature. 
.BL
.NOFILL
$BOX 1 is the minimum X coordinate  (IFF units)
$BOX 2 is the maximum X coordinate  (IFF units)
$BOX 3 is the minimum Y coordinate  (IFF units)
$BOX 4 is the maximum Y coordinate  (IFF units)
.FILL
.P -10;$BUTTON
.BR;INTEGER  Contains the button number of the last puck button used.
.P -10;$CATEGORY
.BR;INTEGER  Contains category field for text.
.P -10;$CLOSED
.BR;INTEGER  -1 if the found feature is closed, else 0.
.P -10;$COEFFS n  Must be followed by an integer in the range 1 - 6.
.BR;REAL  Contains the current transformation parameters
.BL
.NOFILL
$COEFFS 1 is the rotation angle (in degrees)
$COEFFS 2 is the scale factor
$COEFFS 3 is the X coordinate of the rotation point (IFF units)
$COEFFS 4 is the Y coordinate of the rotation point (IFF units)
$COEFFS 5 is the translation in the X direction (IFF units)
$COEFFS 6 is the translation in the Y direction (IFF units)
.FILL
.P -10;$COLOUR
.BR;INTEGER  Contains the colour (from the FRT) of the current feature.
.P -10;$CONSTRUCTION__FC
.BR;INTEGER  Contains the feature code to be used when a feature is
constructed
.P -10;$CONSTRUCTION__GT
.BR;INTEGER  Contains the graphical type of the feature code to be used
when a feature is constructed
.P -10;$CONSTRUCTION__LAYER
.BR;INTEGER  Contains the number of the layer that constructed features
go in
.P -10;$CONSTRUCTION__MAP
.BR;INTEGER  Contains the number of the map that constructed features
go in 
.P -10;$CPxzz n  Must be followed by a map number in the range 1 - 100.
.BR;x is either X or Y and zz is one of NW, SW, SE or NE.
.BR;REAL  Contains coordinates of the control points for each map
.BL
.NOFILL
$CPXNW n is the X coordinate of the NW control point for map n
$CPYNW n is the Y coordinate of the NW control point for map n
$CPXSW n is the X coordinate of the SW control point for map n
$CPYSW n is the Y coordinate of the SW control point for map n
$CPXSE n is the X coordinate of the SE control point for map n
$CPYSE n is the Y coordinate of the SE control point for map n
$CPXNE n is the X coordinate of the NE control point for map n
$CPYNE n is the Y coordinate of the NE control point for map n
.FILL
.P -10;$CURSINGEOMETRY n  Must be followed by the number of a defined
area type geometry.
.BR;INTEGER  -1 if the cursor is in the specified geometry, +1 if it
is on the boundary, else 0.
.P -10;$CURSINIMAGE
.BR;INTEGER  The number of the selected image in which the cursor lies, or
0 if the cursor is not in a selected image.
.P -10;$CURSINREGION n    Must be followed by a valid region number.
.BR;INTEGER  -1 if the cursor is in the specified region, +1 if it
is on the boundary, else 0.
.P -10;$CURSINWIN [r]
.BR;INTEGER  -1 if the cursor is in the current window, else 0.
May be followed by a number in the range 0.0 _-_> 1.0, to indicate the
part of the window to be tested. For example, a value of 0.8 indicates
that a window (centred on the centre of the screen) with sides 0.8 that
of the screen will be tested.
.P -10;$CURSX
.BR;REAL  Contains X value of cursor position (IFF units)
.P -10;$CURSY
.BR;REAL  Contains Y value of cursor position (IFF units)
.P -10;$CURSZ
.BR;REAL  Contains Z value of cursor position (IFF units)
.BR
Note the cursor may not have a Z value. The variable $CURSZ__EXIST tells
if this variable is valid 
.P -10;$CURSZ__EXIST
.BR;INTEGER  -1 if the variable $CURSZ contains valid data, else 0
.P -10;$CUTGEOMETRY n  Must be followed by a valid area type geometry number.
.BR;INTEGER  -1 if the found feature cuts the specified area geometry,
else 0
.P -10;$CUTREGION n  Must be followed by a valid region number.
.BR;INTEGER  -1 if the found feature cuts the boundary of given REGION,
else 0. 
.P -10;$DATETIME
.BR;CHARACTER  Contains the current date and time, in VMS format.
.P -10;$DISPLAY
.BR;INTEGER  -1 if there is a graphics display in use on the LITES2
workstation, else 0. 
.P -10;$DISPLAYCOLUMNS
.BR;INTEGER   Contains the number of pixels across the display that has
been selected with the DISPLAY NUMBER command. (Only available on
certain hardware). 
.P -10;$DISPLAYNUMBER
.BR;INTEGER  Contains the current display number (ie the DISPLAY selected
by the DISPLAY NUMBER command) 
.P -10;$DISPLAYROWS
.BR;INTEGER  Contains the number of pixels up and down the display that
has been selected with the DISPLAY NUMBER command. (Only available on
certain hardware). 
.P -10;$DISTANCE
.BR;REAL  Contains the distance in IFF units from the start of the feature
to the current cursor position, measured along the feature. 
.P -10;$ELAPSEDSEC Synonym for $SYSELAPSED
.P -10;$END
.BR;INTEGER  -1 if at first or last point of found feature, else 0
.P -10;$EOF
.BR;INTEGER  -1 if at end of file has been read with the FILE READ
command, else 0 
.P -10;$EXIT__RANGE n  Must be followed by an integer in the range 1 - 4.
.BR;DOUBLE  Contains the range (in absolute coordinates) of the last map
that was output.
.BL
.NOFILL
$EXIT__RANGE 1 is the minimum X coordinate  (IFF units)
$EXIT__RANGE 2 is the maximum X coordinate  (IFF units)
$EXIT__RANGE 3 is the minimum Y coordinate  (IFF units)
$EXIT__RANGE 4 is the maximum Y coordinate  (IFF units)
.FILL
.P -10;$FC
.BR;INTEGER  Contains the feature code of the found feature.
.P -10;$FILELINE
.BR;CHARACTER  Contains the text string read with the latest FILE READ
command. 
.P -10;$FILENAME n  Must be followed by a valid file number
.BR;CHARACTER  Contains the name of the specified file. This will fail
if the specified file is not open.
.P -10;$FILESELECTED
.BR;INTEGER  Contains the number of the file selected by the most recent
FILE command that selects files. If no file is selected, then 0 is returned.
.P -10;$FILESTATUS n  Must be followed by a valid file number
.BR;INTEGER  Contains the status of the specified file
.BL
.NOFILL
0  - file closed
1  - file opened for read
2  - file opened for write
3  - file opened for append
.FILL
.P -10;$FINDTOL
.BR;REAL  Contains the current find radius. If the find radius is
fixed, then the value represents IFF units, and
can be reset at any time by the commands
.NOFILL
   UNITS IFF
   TOLERANCE FIND 'xxxx
.FILL
(where xxxx is a user variable that has been assigned the value in
$FINDTOL). 
.BL
If the find radius is currently being zoomed, then the value
represents screen mm, and it can be reset at any time by the
command
.NOFILL
   TOLERANCE FIND 'xxxx
.FILL
.P -10;$FIND__COUNT
.BR;INTEGER  After a FIND command, contains the number of found features
which repeated use of FIND (without moving the cursor) will
cycle round. 0 if the use of FIND would find new features.
See also $FIND__ITEM.
.P -10;$FIND__ITEM
.BR;INTEGER  After a FIND command, contains the position of the found
feature in the list of nearby features which repeated use
of FIND (without moving the cursor) would cycle round.
It will be 1 after an initial FIND, and range up to
$FIND__COUNT for subsequent FINDs.
.P -10;$FIRST
.BR;INTEGER  -1 if at first point of the found feature, else 0.
.P -10;$FIXEDFIND
.BR;INTEGER  -1 if the find radius is currently fixed, and is not altered
when the picture is zoomed, else 0.
.P -10;$FLY__TRANSFORMATION
.BR;INTEGER  -1 if displaying on a different projection from the data, else 0
.P -10;$FOUND
.BR;INTEGER  -1 if there is a found feature, else 0.
.P -10;$FRT
.BR;CHARACTER  Contains the name of the FRT file currently in use.
.P -10;$FSN
.BR;INTEGER  Contains the feature serial number of the found feature.
Note that $FSN is not necessarily unique. The only way of
uniquely identifying a feature is to save $IFFADDR (and
$MAP if there is more than one map).
.P -10;$GEOG__STRING
.BR;CHARACTER  Contains the latitude and longitude of the current cursor
position, in degrees, minutes and seconds. This variable only exists if
all maps have valid version 2 map descriptors.
.P -10;$GEOMETRY n  Must be followed by a valid geometry number.
.BR;INTEGER   -1 if the specified geometry exists, else 0
.P -10;$GEOMETRY__PARTS n Must be followed by a valid geometry number.
.BR;INTEGER   Contains the number of parts that a geometry consists of.
.P -10;$GEOMETRY__TYPE n Must be followed by a valid geometry number.
.BR;INTEGER   Contains the type of the specified geometry
.BL
.NOFILL
0 - point type geometry
1 - line  type geometry
2 - area  type geometry
.FILL
.P -10;$GROUP
.BR;CHARACTER  Contains a list of the group names, separated by commas,
that the found feature is in.
.P -10;$GROUP__FC n   Must be followed by an integer.
.BR;CHARACTER  Contains a list of the group names, separated by commas,
that the specified feature code is in. If the feature code does not
exist in the FRT, an error occurs
.P -10;$GT
.BR;INTEGER  Contains the graphical type of the found feature.
.P -10;$GT__FC n   Must be followed by an integer.
.BR;INTEGER  Contains the graphical type of the specified feature code. If
the feature code does not exist in the FRT, 0 is returned.
.P -10;$HADSELECT
.BR;INTEGER  -1 if there is any selection in force, else 0
.P -10;$HADSELECT__AC
.BR;INTEGER  -1 if there is any selection by AC in force, else 0
.P -10;$HADSELECT__CATEGORY
.BR;INTEGER  -1 if there is any selection by text category in force,
else 0 
.P -10;$HADSELECT__FC
.BR;INTEGER  -1 if there is any selection by feature code in force,
else 0 
.P -10;$HADSELECT__FLAG
.BR;INTEGER  -1 if there is any selection by edited, unedited or deleted
in force, else 0
.P -10;$HADSELECT__FSN
.BR;INTEGER  -1 if there is any selection by feature serial number in
force, else 0
.P -10;$HADSELECT__GEOMETRY
.BR;INTEGER  -1 if there is any selection by geometry in force, else 0
.P -10;$HADSELECT__LAYER
.BR;INTEGER  -1 if there is any selection by layer in force, else 0
.P -10;$HADSELECT__MAP
.BR;INTEGER  -1 if there is any selection by map in force, else 0
.P -10;$HADSELECT__PRIORITY
.BR;INTEGER  -1 if there is any selection by feature code priority in force,
else 0
.P -10;$HADSELECT__REGION
.BR;INTEGER  -1 if there is any selection by region in force, else 0
.P -10;$HADSELECT__STYLE
.BR;INTEGER  -1 if there is any selection by text style in force, else 0
.P -10;$HEIGHT
.BR;REAL  Contains the height of found text feature (mm).
.P -10;$HWTYPE
.BR;CHARACTER  Contains the type of hardware this version of LITES2 runs
on. 
.P -10;$IFFADDR
.BR;INTEGER  Contains the address in the IFF file of the found feature.
This provides a unique reference (within a map) of the feature.
Note that $FSN is not necessarily unique.
.P -10;$IFF__REVISION n   Must be followed by a valid map number.
.BR;INTEGER  Contains the output revision level (0 or 1) of the specified
input file.
.P -10;$IMAGEASPECT
.BR;REAL  Contains the 'aspect' at the cursor position, derived from an
image file in the same way as $IMAGEVALUE. The aspect is the direction
of the normal to the surface, or the direction of maximum 'downhill'
gradient. It is measured in degrees clockwise from North. 
.P -10;$IMAGECOLUMNS n  Must be followed by an image number in the range
1 - 8. 
.BR;INTEGER  Contains the number of columns in the specified image.
.P -10;$IMAGEGRADIENT
.BR;REAL  Contains the gradient, or slope, at the cursor position,
derived from an image file in the same way as $IMAGEVALUE.
.P -10;$IMAGENAME n  Must be followed by an image number in the range 1 - 8
.BR;CHARACTER  Contains the name of the specified image
.P -10;$IMAGEORIGINX n  Must be followed by an image number in the range
1 - 8 
.BR;DOUBLE  Contains the X value of the origin for the specified image
.P -10;$IMAGEORIGINY n  Must be followed by an image number in the range
1 - 8 
.BR;DOUBLE  Contains the Y value of the origin for the specified image
.P -10;$IMAGEPIXSX n  Must be followed by an image number in the range 1
- 8 
.BR;REAL  Contains the pixel size in X for the specified image
.P -10;$IMAGEPIXSY n  Must be followed by an image number in the range 1
- 8 
.BR;REAL  Contains the pixel size in Y for the specified image
.P -10;$IMAGEROWS n  Must be followed by an image number in the range 1
- 8. 
.BR;INTEGER  Contains the number of rows in the specified image.
.P -10;$IMAGEVALUE
.BR;INTEGER or REAL  Contains the value extracted from the image file
pixel in which the cursor currently lies. An error message is given if
the cursor does not lie within one of the images specified in the most
recent IMAGE SELECT command. In the event of several images overlapping,
the highest numbered image will be used. The image from which the value
is taken need not be currently visible on the screen. 
.P -10;$IMAGE__EXIST n  Must be followed by a valid image number.
.BR;INTEGER  -1 if the specified image exists, else 0.
.P -10;$IMAGE__RANGE__zzzz n  Must be followed by a map number in the range 1 - 100.
.BR;zzzz is one of XMIN, XMAX, YMIN, YMAX, ZMIN or ZMAX
.BR;DOUBLE  Contains the range of each image in absolute units.
.BL
.NOFILL
$IMAGE__RANGE__XMIN n is the minimum X coordinate in image n
$IMAGE__RANGE__XMAX n is the maximum X coordinate in image n
$IMAGE__RANGE__YMIN n is the minimum Y coordinate in image n
$IMAGE__RANGE__YMAX n is the maximum Y coordinate in image n
$IMAGE__RANGE__ZMIN n is the minimum Z coordinate in image n
$IMAGE__RANGE__ZMAX n is the maximum Z coordinate in image n
.FILL
.P -10;$IMAGE__SETUP
.BR;INTEGER  -1 if the vector data has been setup to align with the
image(s), else 0
.P -10;$INGEOMETRY n  Must be followed by a valid area type geometry number.
.BR;INTEGER  -1 if the found feature is entirely inside specified area
geometry, else 0
.P -10;$INREGION n  Must be followed by a valid region number.
.BR;INTEGER  -1 if the found feature is entirely inside given REGION,
else 0. 
.P -10;$INVISIBLE
.BR;INTEGER  -1 if the current vector of the found feature is INVISIBLE,
else 0
.P -10;$LAST
.BR;INTEGER  -1 if at last point of the found feature, else 0.
.P -10;$LATITUDE
.BR;DOUBLE  Contains the latitude of the current cursor position in
decimal degrees. May only be used if all maps have valid version 2
map descriptors.
.P -10;$LAYER
.BR;INTEGER  Contains the layer number of the found feature.
.P -10;$LAYER__EXIST n  Must be followed by a valid layer number.
.BR;INTEGER  -1 if the specified layer exists, else 0.
.P -10;$LENGTH
.BR;REAL  Contains the total length of the found feature in IFF units.
.P -10;$LIMITS n  Must be followed by an integer in the range 1 - 4.
.BR;REAL  Contains the coordinates of the limits of the LITES2 working
area. This is the total range of the maps that were originally
read in, plus 5% all round. Note that the range may have been
altered by subsequent edits.
.BL
.NOFILL
$LIMITS 1 is the minimum X coordinate  (IFF units)
$LIMITS 2 is the maximum X coordinate  (IFF units)
$LIMITS 3 is the minimum Y coordinate  (IFF units)
$LIMITS 4 is the maximum Y coordinate  (IFF units)
.FILL
.P -10;$LINE
.BR;REAL  Contains the length of the current vector of the found feature,
in IFF units. For non-linear features (texts, symbols and
circle arcs) this variable is identical to $LENGTH.
.P -10;$LOCATION
.BR;INTEGER  Contains text location field for text.
.P -10;$LONGITUDE
.BR;DOUBLE  Contains the longitude of the current cursor position in
decimal degrees. May only be used if all maps have valid version 2 map
descriptors. 
.P -10;$MAP
.BR;INTEGER  Contains the map number of the found feature.
.P -10;$MAPNAME n  Must be followed by a map number in the range 1 - 100.
.BR;CHARACTER  Contains the name of the specified source map.
.P -10;$MAPSTATUS n  Must be followed by a valid map number
.BR;INTEGER  Contains the status of the specified map (IFF file)
.BL
.NOFILL
0  - not opened yet
1  - opened with READ command (map is read only)
2  - opened with IFF command
3  - opened with INSITU command
.FILL
.P -10;$MAPTOTAL
.BR;INTEGER  Contains the total number of maps read in, excluding any since
removed using the QUIT n command.
.P -10;$MAP__NUMBER
.BR;INTEGER  Contains the next map number containing the string
specified by an ASK MAP__NUMBER command
.BL
This variable is a synonym for the variable $ASK__INT 1
.P -10;$MAP__SHEET [n] May be followed by an integer representing the scale of
the map sheet whose name is required (eg 1250 or 10560). If this value is not
supplied the sheet scale currently being used by LITES2 is used.
.BL;CHARACTER Contains the name of the map sheet that covers the current
cursor position. By default, the sheet naming convention is that used by
the Ordnance Survey of Great Britain. This provides map names for the
scales 1/1250, 1/2500, 1/10000, 1/10560, 1/25000. In addition a name
will be generated for scales greater than 1/250000.
.BL
This default algorithm can be substituted by a user supplied one which
can be passed either the absolute position of the cursor or its
geographical position. This substitution is achieved by supplying a
shared image pointed at by the logical name
LSL$LITES2__GET__SHEET__ROUTINES. Example source files that contain
instructions to do this are supplied in
LSL$PUBLIC__ROOT:[LITES2.ROUTINES.EXAMPLES] and are called
GET__SHEET__GEOG__EXAMPLE.FOR and GET__SHEET__GRID__EXAMPLE.FOR.
.P -10;$MAXFSN n  Must be followed by a map number in the range 1 - 100.
.BR;INTEGER  Contains the maximum FSN number for the specified map
(excluding features specified by any FIDUCIAL command).
.P -10;$MDOFFSET n  Must be followed by an integer in the range 1 - 2.
.BR;DOUBLE  Contains the coordinate offset for the LITES2 coordinate
system ($MDOFFSET 1 is x value, $MDOFFSET 2 is y value). This value is
to be added to any IFF coordinate, to get the real projection coordinate
of the point.
.P -10;$MDSCALE
.BR;REAL  Contains the scale of the LITES2 working area.  It is the
scale of the first map that is read into LITES2. The value
comes either from the MD entry in the IFF file, or if that
value is less than or equal to 0.0 or DESCRIPTOR has been
disabled, then from the MH entry.
.P -10;$MHARR n  Must be followed by an integer in the range 1 - $MHLEN
.BR;INTEGER  Contains the contents of the MH entry, of the first map
that was read into LITES2, as a series of 32 bit integers.
See IFFLIB documentation for the format of the MH entry.
.P -10;$MHLEN
.BR;INTEGER  Contains the number of 32 bit integers in $MHARR.
.P -10;$MMFACTOR
.BR;REAL  This is the factor to be used to convert from IFF units to
sheet mm. 
.P -10;$MOANED
.BR;INTEGER  -1 if the last command caused an error, else 0.
.P -10;$MODTCC
.BR;INTEGER  Contains the text component code of the current subtext of
the text feature being modified.
.P -10;$MODTEXT
.BR;CHARACTER  Contains the text string for the current subtext of the
feature being modified.
.BR;For composite texts, this is the current text component (i.e. the
component that the cursor is on)
.P -10;$MODTEXTLEN
.BR;INTEGER  Contains the length of the text string of the current
subtext of the feature being modified.
.BR;For composite texts, this is the current text component (i.e. the
component that the cursor is on)
.P -10;$OPTBIG
.BR;INTEGER  -1 if BIG is currently enabled, else 0.
.P -10;$OPTBLIN
.BR;INTEGER  -1 if BLINK is currently enabled, else 0.
.P -10;$OPTCOMP
.BR;INTEGER  -1 if COMPOSITE text is currently enabled, else 0.
.P -10;$OPTCONT
.BR;INTEGER  -1 if CONTINUE is currently enabled, else 0.
.P -10;$OPTENDS
.BR;INTEGER  -1 if ENDS is currently enabled, else 0.
.P -10;$OPTHEIG
.BR;INTEGER  -1 if HEIGHT is currently enabled, else 0.
.P -10;$OPTINFO
.BR;INTEGER  -1 if INFORM is currently enabled, else 0.
.P -10;$OPTLEAR
.BR;INTEGER  -1 if LEARNER is currently enabled, else 0.
.P -10;$OPTPATT
.BR;INTEGER  -1 if PATTERN is currently enabled, else 0.
.P -10;$OPTPSIZE
.BR;INTEGER  -1 if PSIZE is currently enabled, else 0.
.P -10;$OPTSUBS
.BR;INTEGER  -1 if SUBSTITUTE is currently enabled, else 0.
.P -10;$OPTVERI
.BR;INTEGER  -1 if VERIFY is currently enabled, else 0.
.P -10;$OUTGEOMETRY n  Must be followed by a valid area type geometry number.
.BR;INTEGER  -1 if the found feature is entirely outside specified area
geometry, else 0
.P -10;$OUTREGION n  Must be followed by a valid region number.
.BR;INTEGER  -1 if the found feature is entirely outside given REGION
else 0. 
.P -10;$OVERLAY
.BR;INTEGER   Contains the overlay number that the current feature will
be drawn in. It is the lowest numbered overlay that the overlay
selections satisfy for this feature; if no overlay satisfies the overlay
selections, overlay number 0 is returned
.P -10;$OVERLAYNUMBER
.BR;INTEGER  Contains the current overlay number (ie the OVERLAY selected
by the OVERLAY NUMBER command) 
.P -10;$P n
.BR;CHARACTER  Contains the value of the n'th parameter supplied to the current
command file or macro, or a null string if none was supplied.
.P -10;$PATTERN
.BR;INTEGER  Contains the pattern index for linear features.
.P -10;$PC
.BR;INTEGER  Contains the process code of the found feature.
.P -10;$PCOUNT
.BR;INTEGER  Contains the number of parameters supplied to the
current command file or macro.
.P -10;$PI
.BR;DOUBLE   Contains the value of PI, the ratio of the circumference of
a circle to its diameter.
.P -10;$PID
.BR;CHARACTER  Contains the process identification string for the current
process
.P -10;$PLINE
.BR;CHARACTER  Contains the entire line of parameters supplied to the current
command file or macro, or a null string if none was supplied.
.P -10;$POINT
.BR;INTEGER  -1 if at a point of the found feature, else 0.
.P -10;$POINTNO
.BR;INTEGER  Contains the point number of the cursor on the found
feature. 
.P -10;$PRIVPOINT
.BR;INTEGER  -1 if at a point has an attribute with a value specified
by a previous PRIVILEGE POINT command, else 0.
.P -10;$PSIZE
.BR;INTEGER  Contains the point size of found text feature.
.P -10;$RANDOM [n]  May be followed by a integer to be used as a seed
value. 
.BR;REAL  Contains a random number in the range 0.0 - 1.0.
.BR;NOTE: subsequent references to $RANDOM will produce different
values. By using the optional integer a repeatable series of random
numbers can be initiated. 
.P -10;$RANGE__PROBLEM
.BR;INTEGER Reports problems in calculating the sectored area after
reading an IFF file and transforming it to another projection.
.BL
This variable is valid after going from INITIAL to READY state, or when
an IFF file has been read in READY state. It remains set until another
file is read. It is -1 if a point has been detected outside the sectored
area after transformation and 0 if no such point was detected.


.P -10;$RANGE__zzzz n  Must be followed by a map number in the range 1 - 100.
.BR;zzzz is one of XMIN, XMAX, YMIN or YMAX
.BR;REAL  Contains the (original) range for each map.
.BL
.NOFILL
$RANGE__XMIN n is the minimum X coordinate in map n
$RANGE__XMAX n is the maximum X coordinate in map n
$RANGE__YMIN n is the minimum Y coordinate in map n
$RANGE__YMAX n is the maximum Y coordinate in map n
.FILL
.NOTE
The coordinates are in terms of the current LITES2 space, and reflect
the range of the IFF file that was originally read in. They do not take
account of any subsequent edits.
.END NOTE
.P -10;$REFRESH
.BR;INTEGER  Contains the number of points that are refreshed when an
object is found.
.P -10;$REGION n  Must be followed by a valid region number.
.BR;INTEGER  -1 if the specified region exists, else 0.
.P -10;$REGIONAREA n  Must be followed by a valid region number.
.BR;DOUBLE  Contains the area enclosed by the specified region in
square IFF units. 
.BR
A positive area indicates that the region runs in a clockwise direction,
negative areas indicate a counter clockwise direction. 
.P -10;$RESPOND
.BR;INTEGER  -1 if in second level interactive input (ie the RESPOND
command has been given - awaiting a CONTINUE command), else 0.
.P -10;$SCRFACTOR
.BR;REAL  This is the factor to be used to convert from IFF units to
screen mm.
.P -10;$SECONDARY
.BR;INTEGER  Contains the secondary code (from the FRT) for the current
feature. See FRTLIB documentation, for what this represents
for different types of features.
.P -10;$SIZE
.BR;REAL  Contains the size of the currently found symbol.
.P -10;$SIZE__FC n   Must be followed by an integer.
.BR;REAL  Contains the size entry of the specified feature code
in the current FRT file.
.P -10;$SRI
.BR;CHARACTER  Contains the name of the SRI file currently in use.
.P -10;$STATE
.BR;CHARACTER  Contains the current program state. (See HELP STATE)
.P -10;$STYLE
.BR;INTEGER  Contains the style index for the current text feature.
.P -10;$SYSBUFIO
.BR;INTEGER  Contains the number of buffered input/output operations
during this run of LITES2. This includes operations to
terminals on serial lines.
.P -10;$SYSCPU
.BR;REAL  Contains the CPU time elapsed in seconds during this run of
LITES2. 
.P -10;$SYSDIRIO
.BR;INTEGER  Contains the number of direct input/output operations
during this run of LITES2. This includes operations to
disc files (in particular IFF files).
.P -10;$SYSELAPSED
.BR;REAL  Contains the time elapsed in seconds during this run of LITES2.
.P -10;$SYSFAULTS
.BR;INTEGER  Contains the number of page faults incurred during this
run of LITES2. Useful as a performance tool to check whether
LITES2 would benefit from increased memory or working set size.
.P -10;$TABLE
.BR;INTEGER  -1 if there is a digitising table in use on the LITES2
workstation, else 0
.P -10;$TABLEXY n  Must be followed by an integer in the range 1 - 2.
.BR;REAL  Contains the coordinates of the table cursor after the last
successful invocation of the command ASK TABLE. Until the command ASK
TABLE has been executed successfully, contains the lower left coordinate
of the available LITES2 working area. 
.BL
.NOFILL
$TABLEXY 1 is the X coordinate  (IFF units)
$TABLEXY 2 is the Y coordinate  (IFF units)
.FILL
.BL 
This variable is a synonym for the variable $ASK__REAL
.P -10;$TCC
.BR;INTEGER  Contains the text component code of the current subtext of
found text feature.
.P -10;$TEXT
.BR;CHARACTER  Contains the text string for the current text feature.
For composite texts, this is the text component that
the text was found by.
.P -10;$TEXTLEN
.BR;INTEGER  Contains the number of characters in the text string for
the current text feature. For composite texts, this is the text
component that the text was found by. 
.P -10;$TEXTTOTAL
.BR;INTEGER  Contains the number of subtexts in a composite text feature.
.P -10;$TOPFC
.BR;INTEGER  Contains the highest feature code in the FRT table currently
in use.
.P -10;$TOPGEOMETRY
.BR;INTEGER Contains the number of the highest geometry that has been
defined.
.P -10;$TOPMAP
.BR;INTEGER  Contains the highest map number currently in use.
.P -10;$TRI
.BR;CHARACTER  Contains the name of the TRI file currently in use.
.P -10;$UIC
.BR;CHARACTER  Contains the user identification code of the user.
.P -10;$UNIT__DESC
.BR;CHARACTER  Contains the descriptive string specified in the last
UNITS FACTOR command.
.P -10;$UNIT__FACTOR
.BR;REAL  Contains the number specified in the last UNITS FACTOR command.
.P -10;$UNIT__TYPE
.BR;INTEGER  Contains the type of UNITS command currently in force.
0 - none or NORMAL, 1 - IFF, 2 - MMS, 3 - FACTOR.
Contains the number specified in the last UNITS FACTOR command.
.P -10;$USER
.BR;CHARACTER  Contains the user name of the user
.P -10;$VERSION
.BR;CHARACTER  Contains the LITES2 version number.
.P -10;$WARP__COEFFS__IMAGE  Must be followed by an integer in the range
1 - 8 identifying which coefficient is required.
.BR;DOUBLE  Contains the coefficients for transforming an image
coordinate to a map coordinate.
.P -10;$WARP__COEFFS__MAP  Must be followed by an integer in the range
1 - 8 identifying which coefficient is required.
.BR;DOUBLE  Contains the coefficients for transforming a map
coordinate to an image coordinate.
.P -10;$WARP__DIRTY
.BR;INTEGER  -1 if the warp points have been altered since WARP FIT
was performed, otherwise 0.
.P -10;$WARP__FITTED
.BR;INTEGER  -1 if WARP FIT has been performed, and WARP ON will activate
the fit, otherwise 0.
.P -10;$WARP__IMAGE__N
.BR;INTEGER  The number of image control points for warping.
.P -10;$WARP__IMAGE__X  Must be followed by an integer identifying the 
control point.
.BR;REAL  The X coordinate of an image control point.
.P -10;$WARP__IMAGE__Y  Must be followed by an integer identifying the 
control point.
.BR;REAL  The Y coordinate of an image control point.
.P -10;$WARP__MAP__N
.BR;INTEGER  The number of map control points for warping.
.P -10;$WARP__MAP__X  Must be followed by an integer identifying the 
control point.
.BR;REAL  The X coordinate of a map control point.
.P -10;$WARP__MAP__Y  Must be followed by an integer identifying the 
control point.
.BR;REAL  The Y coordinate of a map control point.
.P -10;$WARP__MODE
.BR;INTEGER  The current warp mode. 0 if warping is off, 1 if warping
the image, 2 if warping the map.
.P -10;$WARP__RESIDUAL__X  Must be followed by an integer identifying the 
control point.
.BR;REAL  The X residual at a warp control point (transformed map
coordinate minus image coordinate).
.P -10;$WARP__RESIDUAL__Y  Must be followed by an integer identifying the 
control point.
.BR;REAL  The Y residual at a warp control point (transformed map
coordinate minus image coordinate).
.P -10;$WARP__RMS__X
.BR;REAL  The root mean square X residual at the warp control points
(calculated at the time the warp was fitted).
.P -10;$WARP__RMS__Y
.BR;REAL  The root mean square Y residual at the warp control points
(calculated at the time the warp was fitted).
.P -10;$WARP__TRANSFORM
.BR;CHARACTER  The name of the current warp transform (LINEAR, HELMERT,
AFFINE, EXTENDED, or PROJECTIVE).
.P -10;$WIDTH
.BR;REAL  Contains the line width of the current linear feature.
.P -10;$WINDOW n  Must be followed by an integer in the range 1 - 4.
.BR;REAL  Contains the coordinates of the limits of the current window.
.BL
.NOFILL
$WINDOW 1 is the minimum X coordinate  (IFF units)
$WINDOW 2 is the maximum X coordinate  (IFF units)
$WINDOW 3 is the minimum Y coordinate  (IFF units)
$WINDOW 4 is the maximum Y coordinate  (IFF units)
.FILL
.P -10;$ZOOM
.BR;REAL  Gives the number of times that the current picture on the
screen is magnified from the full map on the screen.
.LM -10
.HL 2 ^^^*Functions\*
.INDEX Functions
Within expressions the following functions may be used. Their argument
may optionally be enclosed in parentheses.
.P 0
SIN COS TAN ASIN ACOS ATAN ABS LN LOG
.P 0
Trigonometric functions deal with angles in degrees, and return a real
value. 
.BL
ABS returns a real or an integer value, depending on the context.
.BL
LN and LOG return the natural (base e) and common (base 10) logarithm
respectively as a real value.
.P 0
For example, the command LET R=SIN30 will set variable R to 0.5, while
the command LET R=COS('ANGLE'+30) will set R to the cosine of ANGLE+30,
assuming that ANGLE is a REAL variable, and that SUBSTITUTION is enabled.
