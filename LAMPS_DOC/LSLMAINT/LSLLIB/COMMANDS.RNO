.!*
.!* CMDLIB stuff - command decoding
.!*

.INDEX ^^Command decoding


.HL 1 ^&^^Introduction\&
.INDEX ^^Command decoding> introduction

.INDEX ^^Command decoding> command tables

.P 0
Some programs expect the user to supply commands specifying the actions they
require. This chapter documents how to define tables of commands, and how to
read commands using such tables as syntax definitions. 

.P 0
.INDEX ^^Command decoding> reading routines> advantages
The command reading routines provide the following advantages:

.LIST
.DISPLAY ELEMENTS RL,")"

.LE; flexible argument decoding; 

.LE; fast table look up (binary chop), with no requirement for special
table ordering (o(nlogn) sorting process if out of order); 
.INDEX ^^Command decoding> command tables
.INDEX ^^Command tables
.LE; command tables (theoretically, at least) extensible, and (in
practice) compilable at run time;
.INDEX ^^Command decoding> abbreviation of commands

.LE; abbreviated command names accepted; ambiguities diagnosed;
.INDEX ^^Command decoding> primary commands
.INDEX ^^Command decoding> secondary commands

.LE; secondary commands available as an alternative to arguments of a
primary command. 

.END LIST
.INDEX ^^LSLMACLIB
.INDEX ^^Command decoding> static command tables
.INDEX ^^Command tables
.P 0
Static command tables are assembled using MACRO-32, using macros
defined in the LaserScan standard macro library, LSL$LIBRARY:LSLMACLIB.MLB.

.INDEX ^^Dynamic command tables
.INDEX ^^Command decoding> dynamic command tables
.INDEX ^^Command tables> dynamic
.INDEX ^^Command tables

.P 0
Dynamic command tables are generated by routines described in this chapter.

.P 0
.INDEX ^^Command decoding> examples
.INDEX ^^Examples
For an example of using the command decoding routines, see the sources of
the IMP utility IPATCH.

.! ***************************************************************************
.PAGE
.HL 1 ^&^^Defining_ Static_ Command_ Tables.\& 

.INDEX ^^Command decoding> static command tables> definition
.INDEX ^^Command decoding> $CMTAB macro
.INDEX ^^Command decoding> $CMEND macro
.INDEX ^^Command decoding> $CMD macro
.INDEX ^^Command tables

.P 0
The command table itself is introduced by a ^*$CMTAB\* macro, and terminated
by a ^*$CMEND\* macro. Each command is defined by a ^*$CMD\* macro. Thus a
command table consists of the sequence ^*$CMTAB|[$CMD_*]|$CMEND\*. The first
and last may not be omitted. 

.INDEX ^^$CMD macro
.INDEX ^^$CMTAB macro
.INDEX ^^$CMEND macro
.INDEX ^^Command decoding> $CMTAB macro
.INDEX ^^Command decoding> $CMEND macro
.INDEX ^^Command decoding> $CMD macro

.HL 2 ^&^^The_ $CMTAB_ macro\& 

.P 0
Takes the form: 

.P 5
^*$CMTAB##name, [controls], [psect] \*
.INDEX ^^Command decoding> RDCOMM
.LM +12
.P -12
^*name\*########is the name of the command table; should be (at
most 6) alphanumeric characters, starting with an alpha. The name is used in
generating the global symbol to be used to label the table - the symbol
generated is ^*name\*__CMD__TABLE. This global symbol name is then passed as 
an argument to RDCOMM when reading commands using the table.
.INDEX ^^Command tables

.P -12
^*controls\*####defines controls to be applied to the table; a sequence
of characters interpreted as: 

.P -3
^*F\*##permit user flags on commands in this table; 
.I -3
^*D\*##digits, and other characters, allowed in command names (note that this
overrides ^*N\* and ^*R\* if they are also present);
.I -3
^*N\*##permit 'numeric' commands in this table; 
.I -3
^*R\*##read 'numeric' commands, read against this table, as reals; 
.I -3
^*S\*##permit secondary commands to commands in this table; 
.I -3
^*U\*##upper case all command name strings before looking them up in this
table; note that this is done in local workspace, so that the original string
is not corrupted. 
.I -3
^*X\*##insist that all command table matches are 'exact' - ie no
ambiguous matches are permitted with commands in the table. (This facility is
used in language preprocessor and suchlike programs.) 


.P -12
^*psect\*#######defines the PSECT (COMMON block) into which
the command table will be assembled. If argument ^*psect\* is absent or blank,
the command table is assembled into (concatenated) PSECT $$CMTAB. 
.INDEX ^^Command tables

.LM -12

.INDEX ^^Command decoding> $CMD macro

.HL 2 ^&^^The_ $CMD_ macro\& 

.INDEX ^^Command decoding> $CMD macro> format

.P 0
Takes the form: 

.P 5
^*$CMD####mnemonic(s), [controls], [user__flags] \*

.INDEX ^^Command decoding> $CMD macro> allow digits
.INDEX ^^Command decoding> $CMD macro> mnemonic field
.LM +12
.P -12
^*mnemonic(s)\*#define(s) the name(s) of the command. By default, each
^*mnemonic\* may consist of alphabetic characters and underlines. If the
^*D\* control was specified in the table header, each ^*mnemonic\* may be
any printing characters except tab and space - it is, however, recommended that
only alphabetic characters, numbers, underlines and hyphens be used. Also note
that angle brackets and semi-colons will not work, since the command tables
are being written using MACRO.

.p0; If uppercasing was specified (with the ^*U\* control) in the
table header, then all mnemonics must be specified with upper case letters -
any mnemonic containing lower case will not be recognised. If uppercasing was
NOT specified in the table header, then upper and lower case versions of
mnemonics are treated as distinct.

.p0; One mnemonic may be expressed on its own, as in 

.I +4
$CMD##FRED 

.BR
but more than one must be enclosed in angle brackets, as in 

.I +4
$CMD##_<JIM,HARRY_> 

.INDEX ^^$CMD macro

.INDEX ^^Command decoding> $CMD macro> controls

.P -12
^*controls\*####defines controls and arguments for this command; a
sequence of characters interpreted as: 

.P -3
^*_.\*##(dot: commas are precluded by MACRO) comma is ignored immediately
after any numeric argument 
.I -3
^*+\*##command has logical argument (+ or - before the command); only one
logical argument per command 
.I -3
^*=\*##expect an '=' or a ':' character between the command name and its
argument(s) (though there is no insistence that the character be there)
.I -3
^*C\*##character argument - effectively a one-character string, though not
enclosed in quotation marks; note that only one string or character argument
per command is permitted 
.I -3
^*F\*##no command argument may be missing, or, if the command has
a secondary command table, the secondary command may not be omitted (note that
there's no complaint about an absent logical argument) 
.INDEX ^^Command tables> secondary
.I -3
^*I\*##one integer argument; one ^*I\* for each such (at most 7) 
.I -3
^*M\*##arguments are 'mnemonic', ie are to be decoded from a secondary
command table named from the first name given for this command in its macro
(eg FRED__CMD__TABLE and JIM__CMD__TABLE in the two examples of the $CMD macro
given above); the ^*M\* flag may be associated only with the ^*F\* flag, and
may only appear in tables for which the ^*S\* flag was given in the $CMTAB
macro 
.I -3
^*Q\*##expect an ine^*Q\*uality between the command name and the
argument to the command 
.I -3
^*R\*##one real argument; one ^*R\* for each such (at most 7) 
.I -3
^*S\*##string argument (enclosed in quotation marks); note that only one
string or character argument per command is permitted 

.P -12
^*user__flags\*##define user flags associated with this command.

.P 0
User flags provide information about what sort of command this is, and
suchlike. They are returned to the user program when the command is found by
the command routines. Each character of the ^*user__flags\* argument defines a
bit of the user flags longword returned; the characters are interpreted as bit
numbers in a 32-bit extension of standard hexadecimal format; characters 0-9
mean bits 0-9 (value H'00000001 to H'00000200), and characters A-V mean bits
10-31 (value H'00000400 to H'80000000). 

.LM -12

.INDEX ^^Command decoding> $CMD macro> checking

.P 0
The ^*$CMD\* macro does check that its invocation doesn't specify anything too
silly (like invalid control characters, repeats of flag controls such as
^*+\*, or too many ^*I\* or ^*R\* specifications). It doesn't, however, check
for 'indirect' sillies like ^*.\* with only one number argument, or ^*=\* or
^*Q\* with no number argument. 

.HL 3 ^&^^Arguments_ and_ secondary_ commands\&
.INDEX ^^Command decoding> arguments and secondary commands 
.INDEX ^^Common blocks> CMDCOM
.P 0
Arguments and secondary commands are decoded, at the same time as the 
command itself, by routine RDCOMM; the result of this decoding always appears 
in /CMDCOM/ (qvi).

.P 0
Only the terminal secondary command of a primary command may have
arguments. There is no reason that a secondary command should not specify
itself as having a secondary command; however, the decoding routines only
record the command number of the terminal secondary command of a chain thus
specified. 

.HL 3 ^&^^A_ common_ mistake\& 

.INDEX ^^Command decoding> common mistakes

.P 0
A common mistake is to get the case of the letters in arguments to the
^*$CMD\* macro wrong. Even if the ^*U\* control was set in the ^*$CMTAB\*
macro, the system is sensitive (one way or another) to the case of every
letter entered. Incorrect case will manifest itself either as unexpected
failure to recognise commands, or as diagnostics from the $CMD macro itself
when assembling the table. 

.INDEX ^^Command decoding> $CMEND macro

.HL 2 ^&^^The_ $CMEND_ macro\&

.P 0
Takes the form: 

.P 5
^*$CMEND##name \*

.LM +12

.P -12
^*name\*########is the same ^*name\* as appeared in the corresponding
^*$CMTAB\* macro. 

.LM -12

.HL 3 ^&^^Another_ common_ mistake\& 

.INDEX ^^Command decoding> common mistakes

.P 0
Another common mistake is to omit, or to mis-spell, the ^*name\* argument to
the ^*$CMEND\* macro. The effect of this is obscure names (of the form
'$$_<proper__name__of__the__table_>__CMCT') appearing unset when the file is
linked. 

.HL 2 ^&^^Command_ Numbers.\& 

.INDEX ^^Command decoding> command numbers

.P 0
Command numbers are defined by the order of commands in the table.  Commands
are allocated numbers 1,2,...; each ^*$CMD\* macro increments a command number
which is set 0 by the ^*$CMTAB\* macro. Thus the aliases of a single command
(which are all specified by the same ^*$CMD\* macro) all get allocated the same
command number.

.! ***************************************************************************
.PAGE

.HL 1 ^&^^RDCOMM_ -_ reading_ commands\& 
.INDEX ^^RDCOMM
.INDEX ^^Command decoding> RDCOMM
.INDEX ^^Command decoding> RDCOMM> reading commands
.P 0
.INDEX ^^Common blocks> TXTC

RDCOMM is the routine that extracts a command (the next command) from the
current input buffer (normally the /TXTC/ common block), looks it up in a
table (the argument to RDCOMM), gets the command's arguments, and produces any
diagnostics that are called for (if the command ain't right!). 

.P 5
^*ret = RDCOMM( table )\*
.INDEX ^^RDCOMM
.LM +30
.P -25
out#-#long#####^*ret\*#######the result of reading the command - zero or the 
command number

.I -25
in##-#external#^*table\*#####the command table - see below
.LM -30
.INDEX ^^Command tables

.INDEX ^^Command decoding> RDCOMM> FORTRAN application 

.P 0
If the command table is static - that is, declared in MACRO and compiled - 
then it is declared by the macros as a global symbol. The Fortran routine 
calling RDCOMM must then declare it EXTERNAL before referencing it - for 
instance
.INDEX ^^Command tables> static

.P 20
INTEGER_*4##^*ret\*
.I 20
INTEGER_*4##RDCOMM

.I 20
#_:_:_:

.I 20
EXTERNAL###FRED__CMD__TABLE

.I 20
#_:_:_:

.I 20
^*ret\*#=#RDCOMM(#FRED__CMD__TABLE#)

.INDEX ^^Command decoding> RDCOMM> return codes

.P 0
The values returned in ^*ret\* are:

.LM +16
.P -3
0##if no command is found, or 
.BR
if the command was bad in some way (in which case a diagnostic message
will have been produced, unless NOMESS was set), or 

.P -4
-1##if numeric command has been found; an integer numeric command
will have appeared in INTARG(1), a real numeric command in REALAR(1) (both in
/CMDCOM/), or 

.P -16
command#number# from the table, if the command was successfully
read, and all its arguments have been neatly stuffed away in the appropriate
slots in /CMDCOM/.
.INDEX ^^Common blocks> CMDCOM
.LM -16

.INDEX ^^Command decoding> allow digits

.p0; By default, commands are read as strings which are terminated by any
non-alphabetic, non-underline character. If the ^*D\* control is specified
for the command table, then commands are read as strings which are terminated
by a space or tab. This means that a command such as LITES2 becomes legal, but
it also means that ZOOM5 must be typed as ZOOM#5.

.INDEX ^^Command decoding> RDCOMM> error handling

.HL 2 ^&^^RDCOMM_ -_ Error_ Handling\& 

.INDEX ^^LSL_PUTMSG
.INDEX ^^Command decoding> error reporting> NOMESS
.P 0
RDCOMM normally generates error messages for itself, by use of the LSL_PUTMSG
routine. Sometimes, it is preferable to generate messages in the calling
program instead; to enable users to do this, a logical variable NOMESS (in
/CMDCOM/) is supplied. If NOMESS is true then RDCOMM suppresses any error
messages that it might otherwise be inclined to produce; NOMESS false (the
normal state) permits RDCOMM to produce the messages that are so close to its
heart.

.INDEX ^^EXCEPTION
.INDEX ^^Common blocks> EXCEPTION
.P 0
The variable ERRNUM (in /EXCEPTION/) signals to the calling
program the state of errors encountered while processing a command. Values
that may be placed in ERRNUM by RDCOMM are fully documented in the chapter 
on errors and exceptions.

.INDEX ^^Common blocks> CMDCOM 
.P 0
If RDCOMM fails (returning ^*ret\* as 0), the contents of /CMDCOM/ are in
general unpredictable (with some specific exceptions - see the description of
/EXCEPTION/ in the relevant chapter, and /CMDCOM/ below).

.HL 3 ^^^&Error_ reporting_ -_ LSL__CMDERR\&

.INDEX ^^Command decoding> error reporting> LSL__CMDERR
.INDEX ^^LSL__CMDERR

.P 5
^*ok = LSL__CMDERR()

.LM +30
.P -25
out#-#long#####^*ok\*########error return
.LM -30

.P 0
LSL__CMDERR can be used to output a CMDLIB error message when NOMESS is true.
It looks up the error in /EXCEPTION/, gathers the appropriate arguments from
/CMDCOM/ and /INEQUAL/, and uses LSL__PUTMSG to output the error message. The
values of ^*ok\* returned are identical to those from LSL__PUTMSG, that is:

.LM +18
.P -18
LSL____NORMAL#####-#the message text was successfully found, EXPANDed
and output
.I -18
LSL____BUFFEROVF##-#the message text was too long to fit into the internal
buffers.
A warning message (SS$__BUFFEROVF) is output, and then the message is truncated
and the truncated version is output
.I -18
LSL____MSGNOTFND##-#the message text cannot be found. The function does
not output anything.
.LM -18

.HL 1 ^&^^RDINEQ_ -_ reading_ an_ inequality\& 
.INDEX ^^RDINEQ
.INDEX ^^Command decoding> RDINEQ
.INDEX ^^Command decoding> inequalities
.P 0
.INDEX ^^Common blocks> TXTC

RDINEQ attempts to read an inequality name from the
current input buffer (normally the /TXTC/ common block).

.P 5
^*failed = RDINEQ( ineq )\*
.INDEX ^^RDINEQ
.LM +30
.P -25
out#-#logical##^*failed\*####false if an inequality was read, else true

.I -25
out#-#byte#####^*ineq\*######inequality number (see below)
.LM -30
.P 0
RDINEQ reads an inequality in the same way that RDCOMM does.
If the routine returns true (failure) then the decoding pointer is
restored to its position when the routine was called. If (as is often the
case) the lack of any inequality is to be treated as '=', then the function
return may be ignored, since ^*ineq\* is set to 0 in the case of failure.
RDINEQ uses RDCOMM to read the inequality names, and may therefore produce
RDCOMM error messages unless NOMESS (in common /CMDCOM/) is set true.
The possible values returned in ^*ineq\* (defined as parameters in
LSL$CMNLSL:INEQ.PAR) are: 

.P 3
INEQ__EQL#(0)#-#'='# or  '_.EQ[L]_.' or no inequality at all 
.I 3
INEQ__GTR#(1)#-#'_>'# or '_.GT[R]_.' 
.I 3
INEQ__GEQ#(2)#-#'_>=' or '_.GE[Q]_.' 
.I 3
INEQ__LSS#(3)#-#'_<'# or '_.LT_.'# or '_.LSS_.' 
.I 3
INEQ__LEQ#(4)#-#'_<=' or '_.LE[Q]_.' 
.I 3
INEQ__NEQ#(5)#-#'_<_>' or '_.NE[Q]_.' 

.! ***************************************************************************
.PAGE

.HL 1 ^&^^Common_ blocks\&

.HL 2 ^^^&The_ CMDCOM_ common block\&

.INDEX ^^Command decoding> CMDCOM common block> FORTRAN application
.INDEX ^^Common blocks> CMDCOM
.ENTRY /CMDCOM/ > see Common blocks

.P 0
The main RDCOMM common block is defined in the file LSL$CMNLSL:CMDCOM.CMN for
FORTRAN programs. 

.P 0
.INDEX ^^Command decoding> CMDCOM common block> MACRO32 application

For MACRO programs, a macro $CMDCOM is defined in the file 
LSL$CMNLSL:CMDCOM.MAR. The common block may be defined by assembling the 
relevant MACRO sources with this file, and invoking the macro $CMDCOM within 
the program. The user should refer to the $CMDCOM source code for the amended 
names defined in the macro.

.NOTE
.INDEX ^^Common blocks> CMDCOM
All ^&logical\& variables in /CMDCOM/ are declared as LOGICAL_*1 or BYTE - 
this should never affect normal use of the variables.
.END NOTE

.P 0
The (Fortran version of the) common block contains the following (presented in 
alphabetical order):

.LM +10
.P -10
out#####-#logical#^*ARGMSG\*
.BR
true if an argument (other than a logical one) was missing from the
command (note that this condition is an error if the command was flagged ^*F\*) 

.P -10
out#####-#long####^*CMDACT\*
.BR
returns the total number of arguments found 
.BR
(ie CMDICT+CMDRCT, or CMDICT+CMDRCT+1 if a string argument is found) 

.P -10
out#####-#long####^*CMDAST(2)\*
.BR
is a 'descriptor' for the 'other' string if command name
ambiguity is found in either a primary or a secondary command table.
.INDEX ^^Command tables> primary
.INDEX ^^Command tables> secondary


.P -10
out#####-#long####^*CMDFLG\*
.BR
returns command flags from the command read; note that, in the 
case of a primary followed by a secondary command, the flags of the primary 
command are not retained, since they consist, perforce, of the ^*M\* flag only

.P -10
out#####-#long####^*CMDFST(2)\*
.BR
is a 'descriptor' for the name of the primary command as it was
to be found in the command table (not what the user typed) 
.INDEX ^^Command tables

.P -10
out#####-#long####^*CMDICT\*
.BR
returns number of integer arguments found 

.P -10
out#####-#logical#^*CMDNEG\*
.BR
returns true if the command had a logical argument '-' ('no logical argument'
and 'logical argument '+'' are not distinguished, and return CMDNEG false) 

.P -10
out#####-#word####^*CMDNLE\*
.BR
word length part of CMDNST 'descriptor' - equivalenced onto CMDNST(1)

.P -10
out#####-#long####^*CMDNST(2)\*
.BR
returns 'descriptor' for the command name (as actually typed by the user)

.P -10
out#####-#long####^*CMDNUM\*
.BR
returns a copy of the primary command number - which is what
RDCOMM's ^*ret\* is made up of. CMDNUM is correctly set if RDCOMM returns an
error as a result of an error in reading a secondary command; if an error
occurs during the processing of the primary command, but after its
recognition, CMDNUM returns the negative of the primary command number. 

.P -10
out#####-#long####^*CMDRCT\*
.BR
returns number of real arguments found 

.P -10
out#####-#long####^*CMSFST(2)\*
.BR
as CMDFST, but for secondary command name 

.P -10
in######-#long####^*DEFBASE\*
.BR
set by the caller of RDCOMM; the default base to which integer
arguments are to be read. Default=0 =_> 'unset', ie decimal base that can be
overridden by the user of the program specifying _^_<base letter_> 

.P -10
out#####-#logical#^*HADDOT\*
.BR
set to true if there was(were) real argument(s), and at least one had a '.',
'/', or 'E' in it, thus distinguishing them from integers 

.P -10
out#####-#byte####^*INEQUAL\*
.INDEX ^^Command decoding> inequalities
.BR
returns the inequality encountered in reading the command, if
any. Possible values (defined as parameters in LSL$CMNLSL:INEQ.PAR) are: 

.P 3
INEQ__EQL#(0)#-#'='# or  '_.EQ[L]_.' or no inequality at all 
.I 3
INEQ__GTR#(1)#-#'_>'# or '_.GT[R]_.' 
.I 3
INEQ__GEQ#(2)#-#'_>=' or '_.GE[Q]_.' 
.I 3
INEQ__LSS#(3)#-#'_<'# or '_.LT_.'# or '_.LSS_.' 
.I 3
INEQ__LEQ#(4)#-#'_<=' or '_.LE[Q]_.' 
.I 3
INEQ__NEQ#(5)#-#'_<_>' or '_.NE[Q]_.' 

.P -10
out#####-#long####^*INTARG(1...CMDICT)\*
.BR
returns the CMDICT longword (INTEGER_*4) arguments, in order 

.P -10
in######-#logical#^*NOMESS\*
.BR
set by caller of RDCOMM; if it is true then RDCOMM does not output 
its own error messages. The default value of false allows them to be output

.P -10
out#####-#logical#^*NOUFLG\*
.BR
returns true if user flags were found in the table the last primary
command was looked up in 

.P -10
out#####-#logical#^*NSUFLG\*
.BR
as NOUFLG, but for the secondary table

.P -10
out#####-#real####^*REALAR(1...CMDRCT)\*
.BR
returns the CMDRCT real (REAL_*4) arguments, in order 

.P -10
out#####-#long####^*SECMDN\*
.BR
as CMDNUM, but for secondary command (note that it's always CMDNUM
that gets returned as the 'result' of RDCOMM) 

.P -10
out#####-#word####^*SECNLE\*
.BR
word (INTEGER_*2) length part of SECNST 'descriptor' - equivalenced on SECNST(1)

.P -10
out#####-#long####^*SECNST(2)\*
.BR
as CMDNST, for what the user typed for the secondary command

.P -10
out#####-#long####^*SECTAB\*
.BR
pointer to the table in which the secondary command was looked 
up; may be used (for example) to print the command table by a call such as:
.I 5
CALL###CMDPRT#(#_%VAL(SECTAB)#)

.P -10
out#####-#word####^*STARLE\*
.BR
word (INTEGER_*2) length part of STARST 'descriptor' - equivalenced on STARST(1)

.P -10
out#####-#long####^*STARST(2)\*
.BR
returns 'descriptor' for any string argument 

.P -10
out#####-#long####^*SUFLAG\*
.BR
as UFLAG, but for secondary command 

.P -10
out#####-#long####^*TABFLG\*
.BR
returns table flags from the table argument to RDCOMM 

.P -10
out#####-#long####^*UFLAG\*
.BR
returns user flag bits of primary command looked up 

.P -10
out#####-#byte####^*UNXCHR\*
.BR
returns the character that wasn't expected following
an LSL____UNEXPCH 'Unexpected character' error 

.LM -10

.HL 2 ^^^&The_ INEQUAL_ common_ block\&

.INDEX ^^Command decoding> INEQUAL common block
.INDEX ^^Common blocks> INEQUAL
.ENTRY /INEQUAL/ > see Common blocks

.P 0
The INEQUAL common block is defined in the file LSL$CMNLSL:INEQUAL.CMN,
and is used to store data about the current inequality name. It is not expected
that a user will normally need to refer to it.

.LM +10
.P -10
private#-#parameter#^*INEQ__BUF__LEN\*
.BR
This defines the maximum length which a string being considered as an
inequality name may have. It is currently set at 10.

.P -10
private#-#long####^*INEQ__NAME(2)\*
.BR
This is a 'fake' descriptor for the inequality name. It is initialised by
LSL__INIT.

.P -10
private#-#byte####^*INEQ__BUF(INEQ__BUF__LEN)\*
.BR
This is the buffer part of the 'fake' descriptor.

.LM -10


.! ***************************************************************************
.PAGE

.HL 1 ^&^^Dynamic_ Command_ Table_ Routines.\& 
.INDEX ^^Command tables> dynamic
.INDEX ^^Dynamic command tables
.INDEX ^^Command decoding> dynamic command table routines

.P 0
The library provides a mechanism for command tables to be defined
dynamically during the execution of an image. Routine INITAB sets up a common
block to point to a command table being developed. Routine ADDNAM adds a name
to the table. Routine REMCMD removes a command from the table. The names
added by ADDNAM are stored in dynamically obtained memory, so two arguments
to INITAB which used to supply the space for this are now unused. The
maximum length command name which may be added is 80 characters.

.P 0
Note that there are no routines yet for dynamic definition of secondary
command tables. 

.HL 2 ^&^^Defining_ the_ table\& 

.INDEX ^^Dynamic command tables
.INDEX ^^Command decoding> dynamic command table routines
.INDEX ^^Command tables> defining
.INDEX ^^Command tables> dynamic

.P 0
The table is defined by:

.INDEX ^^INITAB

.P 5
^*call INITAB( table, tabsiz, bytarr, bytsiz,


.I 5
### ####### [argarr, argsiz], [uflarr], [digits] ) \*

.LM +30
.P -25
#in#-#long####^*tabsiz\*#####the size of the ^*table\* array
.I -25
out#-#long####^*table\*######an array ^*tabsiz\* longwords long, to
hold the table of names 
.I -25
#in#-#long####^*bytsiz\*#####unused, pass any integer. This argument
used to be the size of the ^*bytarr\* array
.I -25
out#-#byte####^*bytarr\*#####unused, pass anything. This argument used
to be an array ^*bytsiz\* bytes long, to hold the bytes of names 
.I -25
#in#-#long####^*argsiz\*#####the size of the ^*argarr\* and ^*uflarr\*
arrays
.I -25
out#-#word####^*argarr\*#####an array ^*argsiz\* words long, to hold the
table of argument descriptions
.I -25
out#-#long####^*uflarr\*#####an array ^*argsiz\* longwords long, to
hold the table of command user flags 
.I -25
#in#-#logical#^*digits\*#####allow digits (and other characters) in command
mnemonics
.LM -30

.INDEX ^^ADDNAM

.INDEX ^^Dynamic command tables
.INDEX ^^Command decoding> dynamic command tables> initialisation
.INDEX ^^Command tables> dynamic
.INDEX ^^Command tables> dynamic> initialisation

.P 0
INITAB initialises dynamic table generation. It must be called
before any call to ADDNAM. 

.INDEX ^^Dynamic command tables
.INDEX ^^Command tables> dynamic
.INDEX ^^Command decoding> dynamic command tables> missing arguments
.INDEX ^^Command tables> dynamic> missing arguments
.INDEX ^^Command tables> dynamic> allow digits

.P 0
Commands in the table are assumed not to have arguments if
arguments ^*argarr\* and ^*argsiz\* are missing. User flags are marked
'suppressed' in the table if argument ^*uflarr\* is missing.

.p0; If ^*digits\* is specified as .TRUE_. the effect is as if the ^*D\*
control were specified for a static command table.

.INDEX ^^Command decoding> dynamic command tables> nesting
.INDEX ^^Command tables> dynamic
.INDEX ^^Command tables> dynamic> nesting
.INDEX ^^Dynamic command tables

.P 0
Note that command table definition may not be nested. A call to INITAB
starts definition of a new table, and all subsequent entries made by ADDNAM go
into the new table. If another table is to be defined, and there is a need
later to return to the original table, routines SAVTAB and SELTAB (qvi)
should be used. 

.HL 2 ^&^^Saving_ and_ restoring_ the_ state_ of_ definition_ of_ a_ table\&

.INDEX ^^Command decoding> saving and restoring state of table definition

.P 0
Once a table's definition has been started, its current state may be 
preserved by:

.P 5
^*call SAVTAB( savbuf )\*

.INDEX ^^SAVTAB

.LM +30
.P -25
out#-#long####^*savbuf\*#####a 12 longword buffer to hold the saved 
information
.LM -30

.P 0
When a table's state has been saved by SAVTAB, definition of the table 
may be resumed by:

.P 5
^*call SELTAB( savbuf )\*

.INDEX ^^SELTAB

.LM +30
.P -25
#in#-#long####^*savbuf\*#####must be a buffer loaded by a call to SAVTAB 
- it is thus 12 longwords long
.LM -30

.HL 2 ^&^^Entering_ names_ in_ the_ table\& 

.INDEX ^^Command decoding> entering names in dynamic command tables
.INDEX ^^Command tables> dynamic
.INDEX ^^Command tables> dynamic> entering names in
.INDEX ^^Dynamic command tables
.INDEX ^^INITAB

.P 0
Once the table has been defined by a call to INITAB, names may be 
entered in it by:

.P 5
^*ret = ADDNAM( name, [length], [cmdnum], [argspc], [uflag] )\*

.INDEX ^^ADDNAM

.LM +30
.P -25
out#-#long####^*ret\*########the function result - see below
.I -25
#in#-#char####^*name\*#######the name to be added to the table
.I -25
#in#-#long####^*length\*#####defines the relevant substring of ^*name\* to be
added 
.I -25
#in#-#long####^*cmdnum\*#####defines the command number to be given to
^*name\* in the table 
.I -25
#in#-#word####^*argspc\*#####defines the arguments to ^*name\* (this argument
may be generated by the function ARGSPC) 
.I -25
#in#-#long####^*uflag\*######contains the user flags for ^*name\*
.LM -30

.P 0
Adds the name ^*name\* to the currently-defined table. The command is given
number ^*cmdnum\* (if that argument is present), or the lowest command number
not yet allocated in the table (otherwise). 

.P 0
.INDEX ^^Dynamic command tables
.INDEX ^^Command tables> dynamic
.INDEX ^^Command decoding> entering names in dynamic command tables> caveats
Caveats:
.LIST
.LE; the routine only adds the alphabetic and underline ('__') characters of
^*name\* to the table, so it's quite capable of adding a name of zero length! 
.LE; it makes no check on duplication of names within the table. 
.END LIST

.P 0
Function result is: 

.LM +10

.P -4
_>#0#'index' in the table where name has been put - this is the
value which will be returned by RDCOMM if the name is looked up in the table.
Note that this is the same value as argument _<cmdnum_>, if that argument was
present. 

.I -4
=#0#no room in the table 

.I -4
=-1#cannot obtain memory to store command name (used to be
too many bytes for residue of space in byte array)

.I -4
=-2#command number exceeds _<argsiz_> argument of INITAB (if that was 
present)

.I -4
=-3#_<argspc_> argument was given, but no _<argarr_> argument was given 
to INITAB

.I -4
=-4#_<uflag_> argument was given, but no _<uflarr_> argument was given
to INITAB 

.LM -10

.HL 2 ^&^^Removing_ commands_ from_ the_ table\& 

.INDEX ^^Command decoding> removing commands from dynamic command tables
.INDEX ^^Command tables> dynamic
.INDEX ^^Command tables> dynamic> removing names from
.INDEX ^^Dynamic command tables
.INDEX ^^REMCMD

.P 0
Commands may be removed from a dynamic command table by:

.P 5
^*CALL REMCMD( cmdnum )\*

.INDEX ^^REMCMD

.LM +30
.P -25
#in#-#long####^*cmdnum\*#####defines the command number to be removed from
the table
.LM -30

.P 0
All commands with command number ^*cmdnum\* are removed from the current
dynamic command table. If no commands have the correct number, then
nothing is done. The command numbers of the remaining commands in the table
are unchanged.

.HL 2 ^&^^Evaluating_ argument_ specifications\&
.INDEX ^^Command decoding> dynamic command tables> evaluation of argument specifications
.INDEX ^^Command tables> dynamic> evaluation of arguments
.INDEX ^^Dynamic command tables
.P 0
Argument specification words are tricky objects to generate. In 
recognition of this fact, a near-impossibly complex routine is provided to 
generate the beasts for the the user of ADDNAM. This routine is:

.P 5
.INDEX ^^ARGSPC
^*argspec = ARGSPC( numint, numrea, logarg, strarg, chrarg,
.I 5
####### # ####### argful, prmequ, prmieq, prmcom)\*

.LM +30
.P -25
out#-#word####^*argspec\*####the resultant argument specification
.I -25
#in#-#long####^*numint\*#####($CMD#flag#^*I\*)#the number of integer arguments
(0#to#7)
.I -25
#in#-#long####^*numrea\*#####($CMD#flag#^*R\*)#the number of real arguments
(0#to#7)
.I -25
#in#-#logical#^*logarg\*#####($CMD#flag#^*+\*)#true if a logical argument is
to be recognised 
.I -25
#in#-#logical#^*strarg\*#####($CMD#flag#^*S\*)#true if a string argument is
required 
.I -25
#in#-#logical#^*chrarg\*#####($CMD#flag#^*C\*)#true if a character argument is 
required
.I -25
#in#-#logical#^*argful\*#####($CMD#flag#^*F\*)#true if all arguments (other
than a logical one) must be present 
.I -25
#in#-#logical#^*prmequ\*#####($CMD#flag#^*=\*)#true if to permit '=' or ':'
after a command, before any arguments 
.I -25
#in#-#logical#^*prmieq\*#####($CMD#flag#^*Q\*)#true if to permit inequalities
.I -25
#in#-#logical#^*prmcom\*#####($CMD#flag#^*.\*)#true if to permit a comma
between numeric arguments 
.LM -30

.P 0
The function result is typically to be used as the ^*argspc\* argument to
ADDNAM (indeed it's hard to imagine what else it could be used for!). 

.! ***************************************************************************
.PAGE

.HL 1 ^&^^Additional_ Command_ Table_ Routines.\& 
.INDEX ^^Command tables
.INDEX ^^Command decoding> additional command table routines

.P 0
The routines documented here enable the user to perform some additional
manipulation of command tables.

.HL 2 ^&^^Command_ Table_ Print\& 
.INDEX ^^Command decoding> command tables> printing
.INDEX ^^Command tables> printing

.P 0
A command table, once handed to the command-reading routines, has a
tendency to get sorted, juggled, and otherwise 'improved'. CMDPRT
provides the 'ordinary user' with a means of listing the command names in
a command table. It ensures, as does RDCOMM, that the command table
is in alphabetic order before it starts. 

.P 5
^*CALL CMDPRT( table )\*

.INDEX ^^CMDPRT

.INDEX ^^Command tables
.LM +30
.P -25
in##-#########^*table\*######the command table - which for static command
tables will usually be declared external ^*name\*__CMD__TABLE in the calling
routine, but for dynamic command tables is the table defined by the
subroutine INITAB. 
.LM -30

.P 0
CMDPRT prints out the commands in ^*table\* using TTWSTR.

.HL 2 ^&^^Accessing_ Command_ Tables_ by_ Command_ Number\& 
.INDEX ^^Command decoding> command tables> access by command number
.INDEX ^^Command tables> access by command number

.P 5
^*CALL FIND__CMDNAME( table, cmdnum, cmdnam, cmdlen, context )\*

.LM +30
.P -25
in##-#########^*table\*######the command table - which for static command
tables will usually be declared external ^*name\*__CMD__TABLE in the calling
routine, but for dynamic command tables is the table defined by the
subroutine INITAB. 
.I -25
#in#-#long####^*cmdnum\*#####the number of the command to be found
.I -25
out#-#char####^*cmdnam\*#####the command that was found
.I -25
out#-#long####^*cmdlen\*#####the number of characters in the command name
.I -25
i/o#-#long####^*context\*####see below
.LM -30

.P0
It is sometimes necessary to get the name of a command, from a command table,
when the command number is known.  This process is complicated by the fact 
that different commands may have the same command number (when they are
synonyms). This subroutine therefore uses the ^*context\* argument
to save the current context of the search whenever an occurrence of the 
command number has been found. The subroutine should first be called with 
^*context\* having the value 0. If a command is found, ^*context\* will be
returned as a non-zero value. By calling the subroutine repeatedly with this
new value of ^*context\* any subsequent occurences of the command number in 
the table will be found will be found. If no command is found, ^*context\*
is returned as 0.


.HL 2 ^&^^Command_ Table_ Sort\& 
.INDEX ^^Command decoding> command tables> sorting
.INDEX ^^Command tables> sorting

.P 0
Before use, or after adding new commands, a command table must be sorted
into alphabetical order. This is performed automatically by the LSLLIB
routines, but if the user wishes to write their own code to manipulate
a command table (look at the LSLLIB source code to determine the
command table structure), then LSL__SORTAB may be used to sort the
table.

.P 5
^*CALL LSL__SORTAB( table )\*

.INDEX ^^LSL__SORTAB

.INDEX ^^Command tables
.LM +30
.P -25
in##-#########^*table\*######the command table - which for static command
tables will usually be declared external ^*name\*__CMD__TABLE in the calling
routine, but for dynamic command tables is the table defined by the
subroutine INITAB. 
.LM -30

.P 0
LSL__SORTAB sorts the commands in ^*table\* into alphabetical
order. A flag is set in the table to indicate that it has been sorted, so
that future calls to LSL__SORTAB just return immediately.
