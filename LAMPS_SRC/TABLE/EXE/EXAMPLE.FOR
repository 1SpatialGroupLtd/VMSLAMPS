C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1988-04-14 13:44:32.000000000 +0100
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	LOGICAL FUNCTION DECODE(BUFF,BUFLEN,BUT,X,Y)CC Copyright Laser Scan Laboratories Ltd., Cambridge, England.C	IMPLICIT NONECC Must be linked as a shareable image with universal symbol DECODE.C e.g.C	$ FORTRAN DECODEC	$ LINK/SHARE DECODE,SYS$INPUT:/OPTC	UNIVERSAL=DECODEC	$ ...CC To probe the table directly, a prompt string is required. By defaultC the string 'V' is used (the prompt for an ALTEK 40 controller)CC if another prompt string is required then a second entry point C GET_TABLE_PROMPT should be used. This must also be a universal symbolC in the shared image, and the link instruction should be:CC	$ LINK/SHARE DECODE,SYS$INPUT:/OPTC	UNIVERSAL=DECODE,GET_TABLE_PROMPTC	$ ...CC The command file DECODE.COM in the same directory as the example willC perform this task for you.CC ----------------------------------------------------------------------CC			 Use by programsC			 ---------------C In order to be used by a program, a logical name in either the groupC or system tables must be defined to point to the sharable image. TheC following programs currently use this facility:CC - Table MonitorC   Logical names LSL$TABMON_ROUTINEC	       or LSL$TABMON_ROUTINE_<terminal> (for a named monitor)CC - LITES2C   Logical name LSL$TABMON_ROUTINE_<terminal>CC - DIGSYSC   Logical name LSL$DIGSYS_DECODE<n>C   (where <n> is the same number used in the table name LSL$DIG<n>)CC Laserscan programs expect tables to measure in units of 0.02mm.C LITES2 can accept table output in other units (with the SETUPC TABLE_COUNT command). If this routine is to be used by other programsC then the coordinates should be scaled to units on 0.02mmC ----------------------------------------------------------------------CC return TRUE if fail, FALSE if succeedC	BYTE		BUFF(14)	INTEGER*2	BUFLEN	INTEGER		BUT	INTEGER		X	INTEGER		YC	BYTE		DOLLAR,COMMA	PARAMETER	(DOLLAR = '$')	PARAMETER	(COMMA  = ',')CC function	LOGICAL		GETCRDCC this is an example for the ALTEK table formatC format is '$L,xxxxx,yyyyy, where L can be 0-F or H (when tableC is probed)C	DECODE = .TRUE.			! assume failure	IF (BUFLEN.NE.14) GOTO 9999	! wrong length	IF (BUFF(1).NE.DOLLAR.OR.     &	    BUFF(3).NE.COMMA .OR.     &	    BUFF(9).NE.COMMA) GOTO 9999	IF (GETCRD(X,BUFF(4),5)) GOTO 9999	! get x	IF (GETCRD(Y,BUFF(10),5)) GOTO 9999	! get yCC If these units are not 0.02mm, then they should be scaled.C eg. if the table produces coordinates in 0.001mm then the followingC lines should be uncommentedCCCCC	X = X * 0.05CCCC	Y = Y * 0.05C	IF (BUFF(2).GE.'0'.AND.BUFF(2).LE.'9') THEN	   BUT = BUFF(2) - 48		! a numeral	ELSE	   BUT = BUFF(2) - 55		! a letter	ENDIFCC check value of button (note H is returned when table is interrogated)	IF ((BUT.LT.0.OR.BUT.GT.'F'X).AND.BUT.NE.17) GOTO 9999C9000	DECODE = .FALSE.		! successC9999	RETURN	ENDCC and another subroutine that defines the prompt string, and length toC be used when interrogating the table positionC	SUBROUTINE GET_TABLE_PROMPT(PBUF,PBUFMAX,PBUFL)C	IMPLICIT NONEC	INTEGER		PBUFMAX		! maximum length of buffer	BYTE		PBUF(PBUFMAX)	INTEGER*4	PBUFLC	PBUF(1) = 'V'	PBUFL    = 1C	RETURN	ENDC	LOGICAL FUNCTION GETCRD(C,BUFF,NUM)	IMPLICIT NONE	INTEGER	C	BYTE	BUFF(5)	INTEGER	NUMC	INTEGER	IC	GETCRD = .TRUE.	C = 0	DO 100 I = 1,NUM	   IF (BUFF(I).LT.'0'.OR.BUFF(I).GT.'9') GOTO 9999	   C = C*10 + BUFF(I) - 48100	CONTINUE	GETCRD = .FALSE.9999	RETURN	END