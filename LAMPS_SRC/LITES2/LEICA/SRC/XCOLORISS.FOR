	SUBROUTINE KRISS_GPL(NCOORD,XCOORD,YCOORD,ZCOORD,ORG,COL)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER		NCOORD		! number of coords
	REAL		XCOORD(NCOORD)	! coordinate buffer
	REAL		YCOORD(NCOORD)	! ditto
	REAL		ZCOORD(NCOORD)
	REAL*8		ORG(2)		! origin offset
	INTEGER		COL		! colour
	INTEGER		I
	INTEGER		COLOR
	REAL		X,Y,Z
	IF (KRS_JUST_INIT) THEN
	   KRS_JUST_INIT = .FALSE.
	   CALL SI_BUFFERED_MODE
	ENDIF
	COLOR = COL.AND.7
	IF (COLOR.EQ.0.AND.COL.NE.0) COLOR = 7
	IF (XORMODE.AND..NOT.DIVRF) THEN
	   XORMODE = .FALSE.
	ENDIF
	DO 30 I=1,NCOORD
	   X = XCOORD(I)+ORG(1)
	   Y = YCOORD(I)+ORG(2)
	   Z = ZCOORD(I)
	   IF (DIVRF) THEN
	      IF (NPOINT.EQ.MAXRF) GOTO 999
	      NPOINT = NPOINT+1
	      IF (I.EQ.1) THEN
	         LINE_VIS(NPOINT) = 0	 ! pen up
	      ELSE
	         LINE_VIS(NPOINT) = 1	 ! pen down
	      ENDIF
	      LINE_COORD(1,NPOINT) = X
	      LINE_COORD(2,NPOINT) = Y
	      LINE_COORD(3,NPOINT) = Z
           ELSE
	      IF (I.EQ.1) THEN
	         CALL SI_MOVE(X,Y,Z)
	      ELSE
	         CALL SI_LINE(COLOR,X,Y,Z)
	      ENDIF
	   ENDIF
30	CONTINUE
999	RETURN
	END
	SUBROUTINE KRISS_UPDATE
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	CALL SI_UPDATE
	RETURN
	END
	LOGICAL FUNCTION KRISS_INIT(ON)
	IMPLICIT NONE
	INTEGER*4	MAX_EXPMAX	! maximum possible buffer length
	PARAMETER	(MAX_EXPMAX = 1024)
	INTEGER*4	DEF_EXPMAX	! default buffer length
	PARAMETER	(DEF_EXPMAX = 255)
	INTEGER*2	EXPLEN		! current line length
	BYTE		EXPTYP		! type of fake string
	BYTE		EXPCLA		! class of fake string
	INTEGER*4	EXPPTR		! address of buffer
	INTEGER*2	EXPMAX		! actual buffer length
	INTEGER*4	EXPCTF		! control flags for expansion
	BYTE		EXPBUF(MAX_EXPMAX+1)	! expansion buffer
	INTEGER*4	EXPDSC(2)	! fake string descriptor
	EQUIVALENCE	(EXPDSC,EXPLEN)
	COMMON/LSL_EXPC/EXPLEN,EXPTYP,EXPCLA,EXPPTR,EXPMAX,EXPCTF,EXPBUF
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	LOGICAL	ON	! turn on or off
	INTEGER	SI_INIT
	EXTERNAL KRISS_TMRAST,KRISS_KSRAST
	INTEGER	ERROR
	INTEGER	I
	KRISS_INIT = .TRUE.		! assume failure
	IF (.NOT.ON) THEN
	   GOTO 9990			! that's all for now
	ENDIF
	KRS_JUST_INIT = .TRUE.		! just INITed
	NPOINT = 0			! nothing in drawing buffer
	TMRTIM(1) = -7 500 000		! three quarter second
	TMRTIM(2) = -1
	KSRTIM(1) = -500 000		! one twentieth second
	KSRTIM(2) = -1
	XORMODE = .FALSE.
	DIVRF = .FALSE.			! refresh diversion off
	RFON = .FALSE.			! refresh off
	IF (TMREFN.LE.0) CALL LIB$GET_EF(TMREFN)
	IF (KSREFN.LE.0) CALL LIB$GET_EF(KSREFN)
	TMRADR = %LOC(KRISS_TMRAST)
	KSRADR = %LOC(KRISS_KSRAST)
	ERROR = SI_INIT(.TRUE.)
	IF (ERROR.NE.0) THEN
	   CALL TTWSTR('Failed to initialise SI, check logical LSL$SI')
	   GOTO 9999
	ENDIF
	CALL SI_MENU_COLOR(255,255,255)
	CALL SI_CLEAR_MENU
	CALL SI_MENU_CURSOR(.TRUE.)
	CALL SI_PAN_XY(CURSX,CURSY)
	MBOXX = 0	! not drawn a menu
	MBOXY = 0
	CALL SI_MENU_CURSOR(.FALSE.)
9990	KRISS_INIT = .FALSE.		! success
9999	RETURN
	END
	SUBROUTINE	KRISS_DISMOD(N)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER		N		! 0->stored, else refresh
	IF (N.EQ.0) THEN
	   DIVRF = .FALSE.		! unset diversion
	ELSE
	   NPOINT = 0			! nothing in buffer
	   DIVRF = .TRUE.		! set diversion
	ENDIF
	RETURN
	END	
	SUBROUTINE	KRISS_REFRSH
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	TMRON = .TRUE.
	CALL KRISS_TMRAST
	RETURN
	END	
	SUBROUTINE	KRISS_TMRAST
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	IF (TMRON) THEN			! if timer on then
	   IF (.NOT.KSRON) CALL KRISS_DRAWRF	! draw refresh
	   IF (TMRON) CALL SYS$SETIMR(
     &		%VAL(TMREFN),TMRTIM,%VAL(TMRADR),%VAL(TMREFN))
	ENDIF
	RETURN
	END
	SUBROUTINE	KRISS_RFSTOP
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	IF (TMRON) THEN				! if timer is on
	   TMRON = .FALSE.			! request off
	   CALL SYS$CANTIM(%VAL(TMREFN),)	! cancel it
	   IF (RFON) CALL KRISS_DRAWRF		! remove refresh
	   NPOINT = 0
	   DIVRF = .FALSE.			! diversion off
	ENDIF
	RFON = .FALSE.				! refresh not now on
	RETURN
	END
	SUBROUTINE	KRISS_DRAWRF
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER	I
	INTEGER	COLOR
	IF (NPOINT.GT.0) THEN
	   COLOR = 7
	   IF (.NOT.XORMODE) THEN
	      XORMODE = .TRUE.
	      CALL SI_DRAW_MODE(.TRUE.)
	   ENDIF
	   DO 10 I=1,NPOINT
	      IF (LINE_VIS(I).EQ.0) THEN
	         CALL SI_MOVE(
     &		LINE_COORD(1,I),LINE_COORD(2,I),LINE_COORD(3,I))
	      ELSE
	         CALL SI_LINE(COLOR,
     &		LINE_COORD(1,I),LINE_COORD(2,I),LINE_COORD(3,I))
	      ENDIF
10	   CONTINUE
	   IF (XORMODE) THEN
	      XORMODE = .FALSE.
	      CALL SI_DRAW_MODE(.FALSE.)
	   ENDIF
	   CALL SI_UPDATE
	ELSE
	   TMRON = .FALSE.	! no refresh, so cancel timer
	ENDIF
	RFON = .NOT.RFON
	RETURN
	END
	SUBROUTINE	KRISS_VISIBLE(VIS)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER	VIS
	REAL*8	X,Y,Z
	CALL SI_VISIBLE(VIS)		! set the screen visibility
	IF (VIS.NE.0) THEN
	   CALL DSR_READ(X,Y,Z,.FALSE.)
	   CALL DSR_MOVE(X+1,Y+1,Z+1,.FALSE.)
	   CALL DSR_MOVE(X,Y,Z,.FALSE.)
	ENDIF
	IF (VIS.EQ.0) THEN
	   CALL SI_MENU_COLOR(0,0,0)
	ELSE
	   CALL SI_MENU_COLOR(255,255,255)
	ENDIF
	RETURN
	END
	SUBROUTINE	KRISS_VECT(X1,Y1,X2,Y2,COL)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER	X1,X2,Y1,Y2
	INTEGER		COL		! colour
	INTEGER	C,I
	C(I) = I*480/1024 - 240
	CALL SI_DRAW_LINE(C(X1),C(Y1),C(X2),C(Y2))
	RETURN
	END
	SUBROUTINE	KRISS_RECT(X1,Y1,X2,Y2,FIELD)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER	X1,X2,Y1,Y2
	INTEGER FIELD
	INTEGER	PX1,PX2,PY1,PY2
	PX1 = X1*480/1024
	PX2 = X2*480/1024
	PY1 = Y1*480/1024
	PY2 = Y2*480/1024
	CALL SI_CLEAR_MENU_PIXELS(
     &			MAX(MIN(PX1,PX2)-240,-240),
     &			MAX(MIN(PY1,PY2)-240-1,-320),
     &			MIN(MAX(PX1,PX2)-240,239),
     &			MIN(MAX(PY1,PY2)-240,319) )
	IF (FIELD.EQ.3) THEN
	   MBOXX = 0
	   MBOXY = 0
	ENDIF
	RETURN
	END
	SUBROUTINE	KRISS_TRACK
	IMPLICIT NONE
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	NEW_DSR_READ = DSR_READING
	IF (DSR_READING) THEN
	   DSR_READING = .FALSE.
	   CALL SYS$CANCEL(%VAL(P2_IO))
	   CALL SYS$CLREF(%VAL(USER_EFN))	! pretend nothing happened
	ENDIF
	IF (DSR_MODE.NE.0) CALL DSR_SETMODE(0)
	CALL P2DSM_P2_DEFINE_STAGE_MOTIONS(0)	! disable model movement
	CALL SI_MENU_CURSOR(.TRUE.)
	KSRON = .TRUE.
	CALL KRISS_KSRAST			! start timer
	RETURN
	END
	SUBROUTINE	KRISS_STOP(IX,IY,BOX)
	IMPLICIT NONE
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	INTEGER	IX,IY
	INTEGER	BOX
	INTEGER	CX,CY
	KSRON = .FALSE.				! request off
	CALL SYS$CANTIM(%VAL(KSREFN),)		! cancel it
	CALL SI_MENU_CURSOR(.FALSE.)		! back to graphic mode
	CALL P2DSM_P2_DEFINE_STAGE_MOTIONS(4)	! enable model movement
	IF (NEW_DSR_READ) THEN
	   CALL DSR_START(USER_EFN,
     &		%VAL(IOSB_ADDR),%VAL(AST_ADDR),%VAL(BUFF_ADDR))
	ELSE
	   IF (DSR_MODE.NE.1) CALL DSR_SETMODE(1)
	ENDIF
	IX = (CURSX+240)*1024/480 + 200 	! 200 is KRISS relic
	IY = (CURSY+240)*1024/480
	CX = (CURSX+240+4)/8 - 30 - MORGX
	IF (MOD(MSIZY,2).EQ.0) THEN
	   CY = (CURSY+240+8)/16
	ELSE
	   CY = (CURSY+240)/16
	ENDIF
	CY = MORGY - (CY - 15)
	IF (MBOXX.GT.0) THEN
	   BOX = 0		! assume no box
	   IF (CX.LT.0.OR.CX.GE.MBOXX*MSIZX) GOTO 999
	   IF (CY.LT.0.OR.CY.GE.MBOXY*MSIZY) GOTO 999
	   BOX = (CY/MSIZY)*MBOXX + CX/MSIZX + 1
	ENDIF
999	RETURN
	END
	SUBROUTINE	KRISS_KSRAST
	IMPLICIT NONE
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	INTEGER*4	BUTTON_CODE(4)
	COMMON/BUTTON_CODE/BUTTON_CODE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	REAL*8	X,Y,Z
	INTEGER	IX,IY
	INTEGER	I,B
	INTEGER	FAC
	DATA	FAC/5/
	IF (KSRON) THEN			! if timer on then
	   CALL P2REM_P2_READ_ENCODER_MOVEMENTS(X,Y,Z)
	   IX = INT(X)/FAC
	   IY = INT(Y)/FAC
	   IF (IX.NE.0.OR.IY.NE.0) THEN
	      CURSX = CURSX+IX
	      CURSY = CURSY+IY
	      IF (CURSX.LT.-240) CURSX = -240
	      IF (CURSX.GT.239) CURSX = 239
	      IF (CURSY.LT.-240) CURSY = -240
	      IF (CURSY.GT.239) CURSY = 239
	      CALL SI_PAN_XY(CURSX,CURSY)
	   ENDIF
	   IF (BUTTON_CODE(1).NE.0) THEN
	      NEW_DSR_READ = .FALSE.	! LITES2 will do read itself
	      DO 10 I=1,4
	         DSR_BUTTON(I) = BUTTON_CODE(I)
10	      CONTINUE
	      DSR_IOSB(1) = 1
	      I = DSR_BUTTON(2)*4096 + DSR_BUTTON(3)*64 + DSR_BUTTON(4)
	      B = MOD(I,256)			! ASCII code
	      IF (B.EQ.0) B = I/256 + 128	! no ASCII, so scan code
	      IF (DSR_BUTTON(1).EQ.1) B = MOD(B,32)	! button, or pedal
	      CALL DSR_COPY(B,%VAL(BUFF_ADDR),DSR_IOSB,%VAL(IOSB_ADDR))
	      CALL SYS$SETEF(%VAL(USER_EFN))
	      IF (AST_ADDR.NE.0) CALL LIB$CALLG(0,%VAL(AST_ADDR))
	   ENDIF
	   CALL SYS$SETIMR(
     &		%VAL(KSREFN),KSRTIM,%VAL(KSRADR),%VAL(KSREFN))
	ENDIF
	RETURN
	END
	SUBROUTINE	KRISS_SIDE(N)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER		N		! 1/2/3 = left/right/both
	IF (N.EQ.0) THEN
	   CALL SI_MENU_COLOR(0,0,0)
	ELSE
	   CALL SI_MENU_COLOR(255,255,255)
	ENDIF
	RETURN
	END	
	SUBROUTINE	KRISS_SUSPEND(ON)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	LOGICAL		ON		! suspend, or resume
	KSRON = ON
	RETURN
	END	
	SUBROUTINE	KRISS_REGIST(ACTION)
	IMPLICIT NONE
	INTEGER		ACTION
	RETURN
	END	
	SUBROUTINE	KRISS_TEXT(FIELD,STRING,POSX,POSY,SIZE,LENG,COL)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER		FIELD
	CHARACTER*(*)	STRING
	INTEGER		POSX,POSY
	INTEGER		SIZE
	INTEGER		LENG
	INTEGER		COL
	INTEGER		PX,PY
	IF (FIELD.LE.0.OR.FIELD.GT.2) GOTO 9999
	IF (STRING.EQ.' ') GOTO 9999
	PX = POSX*480/1024
	PY = POSY*480/1024
	PX = PX/8 - 30
	PY = PY/16 - 15
	CALL SI_DRAW_TEXT(PX,PY,%REF(STRING),LEN(STRING))
9999	RETURN
	END	
	SUBROUTINE	KRISS_MENU(ORGX,ORGY,BOXX,BOXY,SIZX,SIZY,DSL,COL)
	IMPLICIT NONE
	LOGICAL		KRS_JUST_INIT	! KRISS just INITed
	LOGICAL		NEW_DSR_READ	! flag for KRISS_TRACK/STOP
	INTEGER*4	TMRTIM(2)	! timer duration
	INTEGER*4	TMRADR		! timer AST address
	INTEGER		TMREFN		! timer event flag
	LOGICAL		XORMODE		! in XOR mode
	LOGICAL		DIVRF		! refresh diversion on
	LOGICAL		TMRON		! timer wanted on
	LOGICAL		RFON		! picture on
	INTEGER*4	KSRTIM(2)	! timer duration
	INTEGER*4	KSRADR		! timer AST address
	INTEGER		KSREFN		! timer event flag
	LOGICAL		KSRON		! timer wanted on
	INTEGER		MAXRF		! limit number of refresh points
	PARAMETER	(MAXRF=40)
	INTEGER		NPOINT
	INTEGER		LINE_VIS(MAXRF)
	REAL*4		LINE_COORD(3,MAXRF)
	INTEGER		CURSX,CURSY
	INTEGER		MORGX,MORGY
	INTEGER		MBOXX,MBOXY
	INTEGER		MSIZX,MSIZY
	COMMON/COLORISS/KRS_JUST_INIT,NEW_DSR_READ,
     &		TMRTIM,TMRADR,TMREFN,XORMODE,DIVRF,TMRON,RFON,
     &		KSRTIM,KSRADR,KSREFN,KSRON,
     &		NPOINT,LINE_VIS,LINE_COORD,
     &		CURSX,CURSY,MORGX,MORGY,MBOXX,MBOXY,MSIZX,MSIZY
	INTEGER		ORGX,ORGY
	INTEGER		BOXX,BOXY
	INTEGER		SIZX,SIZY
	INTEGER*4	DSL(2,*)	! character descriptors
	INTEGER		COL
	INTEGER		X,Y,X2,Y2,OFFY
	INTEGER		IX,IY,P,L
	MBOXX = BOXX
	MBOXY = BOXY
	MSIZX = SIZX*60/1024
	IF (MSIZX.LT.2) MSIZX = 2
	MSIZY = SIZY*30/1024
	IF (MSIZY.LE.0) MSIZY = 1
	OFFY = MSIZY/2
	MORGX = ORGX*60/1024 - 30
	MORGY = (ORGY+BOXY*SIZY)*30/1024 - 15
	P = 0
	DO 10 IY=0,MBOXY-1
	   Y = MORGY-IY*MSIZY
	   DO 10 IX=0,MBOXX-1
	      P = P+1
	      L = DSL(1,P).AND.65535
	      IF (L.LE.0) GOTO 10
	      IF (L.GE.MSIZX) L = MSIZX-1
	      X = MORGX+IX*MSIZX
	      CALL SI_DRAW_TEXT(X,Y-OFFY,%VAL(DSL(2,P)),L)
10	CONTINUE
	X = MORGX*8 - 4		! half char cell to left
	X2 = X + MBOXX*MSIZX*8
	Y = (MORGY+1)*16
	IF (MOD(MSIZY,2).EQ.0) Y = Y-8	! half char cell down
	DO 20 IY=0,MBOXY
	   CALL SI_DRAW_LINE(X,Y,X2,Y)
	   Y = Y - MSIZY*16
20	CONTINUE
	Y = (MORGY+1)*16
	IF (MOD(MSIZY,2).EQ.0) Y = Y-8	! half char cell down
	Y2 = Y - MBOXY*MSIZY*16
	X = MORGX*8 - 4		! half char cell to left
	DO 30 IX=0,MBOXX
	   CALL SI_DRAW_LINE(X,Y,X,Y2)
	   X = X + MSIZX*8
30	CONTINUE
9999	RETURN
	END	
