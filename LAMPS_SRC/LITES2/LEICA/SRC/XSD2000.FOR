	SUBROUTINE DSR_INQUIRE(CODE,VALUE)
	IMPLICIT NONE
	INTEGER	CODE
	INTEGER VALUE
	INTEGER	IVAL
	REAL	RVAL
	EQUIVALENCE (IVAL,RVAL)
	IF (CODE.EQ.1) THEN
	   IVAL = 1	! LEICA type
	ELSEIF (CODE.EQ.2) THEN
	   RVAL = 0.01	! mm size of pixel (for SRIUNI)
	ELSE
	   GOTO 999
	ENDIF
	VALUE = IVAL	
999	RETURN
	END
	LOGICAL FUNCTION DSR_INIT(ON)
	IMPLICIT NONE
	LOGICAL	ON
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	LOGICAL	OK
	LOGICAL	WAS_READING
	DSR_INIT = .TRUE.	! assume OK
	IF (.NOT.ON) THEN
	   IF (DSR_READING) THEN
	      CALL SYS$CANCEL(%VAL(P2_IO))
	      DSR_IOSB(1) = 1
	      CALL DSR_COPY(0,%VAL(BUFF_ADDR),DSR_IOSB,%VAL(IOSB_ADDR))
	   ENDIF
	   IF (DSR_MODE.NE.0) CALL DSR_SETMODE(0) ! back in polled mode
	   GOTO 9999
	ENDIF
	IF (P2_IO.EQ.0) THEN
	   CALL SUP_START_USER_PROGRAM
	   CALL GMTGTM_GET_MODEL_TO_GROUND_TRAN(OK)
	   IF (.NOT.OK) GOTO 9990
	   CALL GGTMTM_GET_GROUND_TO_MODEL_TRAN(OK)
	   IF (.NOT.OK) GOTO 9990
	   CALL DSR_SETMODE(0)
	ENDIF
	WAS_READING = DSR_READING
	IF (DSR_READING) THEN
	   DSR_READING = .FALSE.
	   CALL SYS$CANCEL(%VAL(P2_IO))
	ENDIF
	IF (DSR_MODE.NE.0) CALL DSR_SETMODE(0)
	CALL CP2B_CLEAR_P2_BUFFER
	IF (WAS_READING) CALL DSR_START(USER_EFN,
     &		%VAL(IOSB_ADDR),%VAL(AST_ADDR),%VAL(BUFF_ADDR))
	GOTO 9999
9990	DSR_INIT = .FALSE.
9999	RETURN
	END
	SUBROUTINE DSR_MOVE(X,Y,Z,WAIT)
	IMPLICIT NONE
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	REAL*8	X,Y,Z
	LOGICAL	WAIT
	REAL*8	XM,YM,ZM
	LOGICAL	OK
	LOGICAL	WAS_READING
	WAS_READING = DSR_READING
	IF (DSR_READING) THEN
	   DSR_READING = .FALSE.
	   CALL SYS$CANCEL(%VAL(P2_IO))
	ENDIF
	IF (DSR_MODE.NE.0) CALL DSR_SETMODE(0)
	CALL TGM_TRANSFORM_GROUND_TO_MODEL(X,Y,Z,XM,YM,ZM)
	IF (WAIT) THEN
	   CALL P2MPFM_P2_MOVE_PLATES_FAST_WITH(OK,XM,YM,ZM)
	   CALL P2DSM_P2_DEFINE_STAGE_MOTIONS(4)
	ELSE
	   CALL P2TM_P2_TRACK_WITH_MODEL_COORDI(OK,XM,YM,ZM)
	ENDIF
	IF (WAS_READING) CALL DSR_START(USER_EFN,
     &		%VAL(IOSB_ADDR),%VAL(AST_ADDR),%VAL(BUFF_ADDR))
	RETURN
	END
	SUBROUTINE DSR_READ(X,Y,Z,USE_BUTTON)
	IMPLICIT NONE
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	REAL*8	X,Y,Z
	LOGICAL	USE_BUTTON	! if .T., stored coordinate will do
	LOGICAL	WAS_READING
	IF (USE_BUTTON) THEN
	   CALL TMG_TRANSFORM_MODEL_TO_GROUND(
     &		DSR_MODEL(1),DSR_MODEL(2),DSR_MODEL(3),X,Y,Z)
	   GOTO 990
	ENDIF
	WAS_READING = DSR_READING
	IF (DSR_READING) THEN
	   DSR_READING = .FALSE.
	   CALL SYS$CANCEL(%VAL(P2_IO))
	ENDIF
	IF (DSR_MODE.NE.0) CALL DSR_SETMODE(0)
	CALL RGC_READ_GROUND_COORDINATES(X,Y,Z)
	IF (WAS_READING) CALL DSR_START(USER_EFN,
     &		%VAL(IOSB_ADDR),%VAL(AST_ADDR),%VAL(BUFF_ADDR))
990	RETURN
	END
	LOGICAL FUNCTION DSR_START(EFN,IOSB,AST,BUFF)
	IMPLICIT NONE
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	INTEGER*4	P2_IO
	COMMON/P2_IO/	P2_IO
	INTEGER*4	EFN		! event flag to wait for
	INTEGER*2	IOSB(4)
	EXTERNAL	AST
	BYTE		BUFF		! buffer for output	
	INCLUDE		'($IODEF)'
	INTEGER*4	SYS$QIO
	EXTERNAL	DSR_AST
	INTEGER*4	IERR
	INTEGER*4	TERMSK(2)
	DATA		TERMSK/0,'2000'X/	! end on C/R
	INTEGER		I
	DSR_START=.TRUE.			! assume OK
	IF (DSR_MODE.NE.1) CALL DSR_SETMODE(1)
	USER_EFN = EFN
	IOSB_ADDR = %LOC(IOSB)
	AST_ADDR = %LOC(AST)
	BUFF_ADDR = %LOC(BUFF)
	DO 10 I=1,4
	   IOSB(I) = 0
10	CONTINUE
	DSR_READING = .TRUE.
	IERR=SYS$QIO(%VAL(EFN),			! efn
     &	             %VAL(P2_IO),		! channel
     &	             %VAL(IO$_TTYREADALL.OR.IO$M_NOECHO),! function
     &	             DSR_IOSB,			! iosb
     &	             DSR_AST,			! astadr
     &	             AST,			! astprm
     &	             DSR_BUFF,			! buffer for output
     &	             %VAL(19),			! length of buffer
     &	             ,				! p3
     &	             TERMSK,			! p4
     &	             ,				! p5
     &	              )				! p6
	IF (IERR) GOTO 9999			! OK
	DSR_START=.FALSE.			! QIO failed??
9999	RETURN
	END
	INTEGER FUNCTION DSR_TRN(CH)
	IMPLICIT NONE
	BYTE		CH		! the character
	DSR_TRN = (CH.AND.255) - 1
	RETURN
	END
 	SUBROUTINE DSR_SETMODE(MODE)
	IMPLICIT NONE
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	INTEGER*4	MODE
	INTEGER*4	SEND_WORD(3)
	LOGICAL		TIME_OUT
	INTEGER*4	DESC(8)
	SEND_WORD(1) = MODE	! button/key stream=1, command=0
	CALL RTI_REAL_TO_INTEGER(0.0D0,SEND_WORD(2),SEND_WORD(3))
	DESC(5) = %LOC(SEND_WORD) - 4
	DESC(7) = 1
	DESC(8) = 3
	CALL P2SST_SEND_STRING_TO_P2(37,3,DESC,TIME_OUT)
	DSR_MODE = MODE
	RETURN
	END
 	SUBROUTINE DSR_AST(AST)
	IMPLICIT NONE
	INCLUDE	'($SSDEF)'
	REAL*8		DSR_MODEL(3)
	INTEGER		DSR_BUTTON(4)
	LOGICAL		DSR_READING
	INTEGER		DSR_MODE
	INTEGER*4	USER_EFN
	INTEGER*4	IOSB_ADDR
	INTEGER*4	AST_ADDR
	INTEGER*4	BUFF_ADDR
	INTEGER*2	DSR_IOSB(4)
	BYTE		DSR_BUFF(19)
	COMMON/SD2000/
     &		DSR_MODEL,DSR_BUTTON,DSR_READING,DSR_MODE,
     &		USER_EFN,IOSB_ADDR,AST_ADDR,BUFF_ADDR,DSR_IOSB,DSR_BUFF
	EXTERNAL	AST
	INTEGER	B
	INTEGER	IB(17)
	INTEGER	I,P
	INTEGER	CHECK,RCHECK
	IF (.NOT.DSR_READING) GOTO 999
	IF (DSR_IOSB(1).EQ.0) GOTO 999	! ignore spurious call
	DSR_READING = .FALSE.
	B = 0
	IF (.NOT.DSR_IOSB(1) .OR. DSR_IOSB(2).NE.18) GOTO 990
	IF (DSR_BUFF(1).NE.2 .OR. DSR_BUFF(19).NE.13) GOTO 900
	CHECK = 0
	DO 10 I=1,16
	   IB(I) = (DSR_BUFF(I+1).AND.'FF'X) - 32
	   CHECK = CHECK + IB(I)
10	CONTINUE
	CHECK = MOD(CHECK,64) + 32
	RCHECK = DSR_BUFF(18).AND.'FF'X
	IF (CHECK.NE.RCHECK) GOTO 900
	DO 20 I=1,4
	   DSR_BUTTON(I) = IB(I)
20	CONTINUE
	P = 5
	DO 30 I=1,3
	   DSR_MODEL(I) = IB(P)   * '40000'X +
     &			  IB(P+1) *  '1000'X +
     &			  IB(P+2) *    '40'X +
     &			  IB(P+3)
	   IF (DSR_MODEL(I).GE.8388608) DSR_MODEL(I) = 8388608-DSR_MODEL(I)
	   P = P+4
30	CONTINUE
	I = DSR_BUTTON(2)*4096 + DSR_BUTTON(3)*64 + DSR_BUTTON(4)
	B = MOD(I,256)			! ASCII code
	IF (B.EQ.0) B = I/256 + 128	! no ASCII, so scan code
	IF (DSR_BUTTON(1).EQ.1) B = MOD(B,32)	! button, or pedal
	GOTO 990
900	DSR_IOSB(1) = SS$_ABORT
990	CALL DSR_COPY(B,%VAL(BUFF_ADDR),DSR_IOSB,%VAL(IOSB_ADDR))
	IF (%LOC(AST).NE.0) CALL AST
999	RETURN
	END
 	SUBROUTINE DSR_COPY(B1,B2,IOSB1,IOSB2)
	IMPLICIT NONE
	BYTE		B1,B2
	INTEGER*2	IOSB1(4),IOSB2(4)
	INTEGER		I
	B2 = B1
	DO 10 I=1,4
	   IOSB2(I) = IOSB1(I)
10	CONTINUE
	RETURN
	END
