C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1991-03-26 13:33:08.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
        SUBROUTINE DOOVER
C
***     IDENT   26MR91
***     MODULE  DOOVER
C
C       Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C       Written                                 CCB	25-Jan-1988
C
C	LITES2 cartographic editor OVERLAY command.
C
        IMPLICIT NONE
C
***     PARAMETER/CMN:ACS/
***     PARAMETER/CMN:EFNLUN/
***	PARAMETER/CMN:GKSPAR/
***     PARAMETER/CMN:MOANMESS/
***     PARAMETER/CMN:STAPAR/
C
***     COMMON/CMN:DOUT/
***	COMMON/CMN:FCS/
***     COMMON/LSL$CMNFRT:FRTACD/
***	COMMON/CMN:GLOBAL/
***	COMMON/CMN:IMAGE/
***	COMMON/CMN:LABELS/
***	COMMON/CMN:LAYERS/
***	COMMON/CMN:MAPS/
***	COMMON/CMN:MASTER/
***	COMMON/CMN:OVERLAY/
***	COMMON/CMN:PLOT/
***     COMMON/CMN:STATE/
***     COMMON/CMN:WORKS/
C
C Functions
	EXTERNAL OVERLAY_SELECT_CMD_TABLE
	EXTERNAL OVERLAY_ATTRIBUTE_CMD_TABLE
	EXTERNAL OVERLAY_COLOUR_CMD_TABLE
	EXTERNAL NASTY,MOAN
	INTEGER	ACT_POP_OVERLAY,ACT_PUSH_OVERLAY
	INTEGER	ACT_CONCEAL_OVERLAY,ACT_REVEAL_OVERLAY
	INTEGER	ACT_SET_BACKDROP_VALUE
	INTEGER	ACT_SET_COLOUR_VALUE
	INTEGER	ACT_SET_COLOUR_ATTRIBUTE
	INTEGER	ACT_RECALC
	INTEGER	ACT_DELETE_OVERLAY,ACT_DELETE_DISPLAY
	LOGICAL	CONV_HLS_RGB,CONV_HSV_RGB
C
C Local Variables
	INTEGER*4	OK
	INTEGER		I
	LOGICAL		SEL		! selecting?
	INTEGER		COL1,COL2
	INTEGER*4 	MASKL
	INTEGER*2 	MASKW
	BYTE	  	MASKB
	EQUIVALENCE	(MASKL,MASKW,MASKB)
C
C all commands require a current display that exists
	IF (DISPLAY_CURRENT.EQ.0) THEN
	   CALL MOAN(MSG_NOCURDISP)
	   CALL LEARN(MSG_USEDISPNUM)
	   GOTO 9990
	ENDIF
	IF (.NOT.DISPLAY_EXISTS(DISPLAY_CURRENT)) THEN
	   CALL MOAN(MSG_DISPNOTEXISTS,DISPLAY_CURRENT)
	   IF (DISPLAY_CURRENT.LE.2) THEN
	      CALL LEARN(MSG_USEWORKOVER)
	   ELSE
	      CALL LEARN(MSG_USEDISPCRE)
	   ENDIF
	   GOTO 9990
	ENDIF
C
C Dispatch according to secondary command
	GOTO (100,200,300,400,500,600,700,800,900,1000,1100,
     &		1200,1300,1400,1500,1600,1700), DSECN
C
C Secondary command number out of range
	CALL MSGCMD(NASTY,MSG_ERRSECIND)
	GOTO 9990
C
C OVERLAY NUMBER number
C
100	IF (DINTS(1).LT.0.OR.DINTS(1).GT.MAXOVER) THEN
	   CALL MOAN(MSG_OVERRNG,0,MAXOVER)
	   GOTO 9990
	ENDIF
C
	IF (DINTS(1).GT.0) THEN
	   IF (OVERLAY_PLANES(DINTS(1),DISPLAY_CURRENT).EQ.0) THEN
	      CALL MOAN(MSG_OVNOTEXISTS,DINTS(1),DISPLAY_CURRENT)
	      IF (DISPLAY_CURRENT.LE.2) THEN
	         CALL LEARN(MSG_USEWORKOVER)
	      ELSE
	         CALL LEARN(MSG_USEDISPOVER)
	      ENDIF
	      GOTO 9990
	   ENDIF
	ENDIF
C
	OVERLAY_CURRENT = DINTS(1)
	GOTO 9999
C
C OVERLAY CLEAR
C remove all selections for this overlay
C 
200	IF (DISPLAY_CURRENT.GT.2) GOTO 9300
	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
C
C remove any image selections
	IF (OVERLAY_IMAGE(OVERLAY_CURRENT)) THEN
	   DO 210 I=1,MAXIMAGE
	      O_IMSEL(I,OVERLAY_CURRENT) = .FALSE.
210	   CONTINUE
	   OVERLAY_IMAGE(OVERLAY_CURRENT) = .FALSE.
	ENDIF
C
C remove any IFF selections
	IF (OVERLAY_IFF(OVERLAY_CURRENT)) THEN
	   CALL OVERLAY_SELEAL
	   OVERLAY_IFF(OVERLAY_CURRENT) = .FALSE.
	ENDIF
	GOTO 9999
C
C OVERLAY CLUT
C 
300	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	CALL MSGCMD(MOAN,MSG_CMDNOTIMPLE)
	GOTO 9990
C
C OVERLAY POP
C 
400	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	OK = ACT_POP_OVERLAY(
     &			OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (.NOT.OK) GOTO 9100
	GOTO 8000
C
C OVERLAY PUSH
C 
500	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	OK = ACT_PUSH_OVERLAY(
     &			OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (.NOT.OK) GOTO 9100
	GOTO 8000
C
C OVERLAY REVEAL
C 
600	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	OK = ACT_REVEAL_OVERLAY(
     &			OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (.NOT.OK) GOTO 9100
	GOTO 8000
C
C OVERLAY CONCEAL
C
700	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	OK = ACT_CONCEAL_OVERLAY(
     &			OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (.NOT.OK) GOTO 9100
	GOTO 8000
C
C OVERLAY ATTRIBUTE [colour] subcommand
C
800	IF (DNINT.EQ.0.AND.OVERLAY_CURRENT.NE.0) THEN	! all colours
	   COL1 = 0
	   COL2 = 2**OVERLAY_PLANES(OVERLAY_CURRENT,DISPLAY_CURRENT)-1
	ELSE
	   COL1 = DINTS(1)
	   COL2 = DINTS(1)
	ENDIF
	CALL GET_COMMAND(DSTR(:DSTRL),OVERLAY_ATTRIBUTE_CMD_TABLE)
	IF (MOANED) GOTO 9990
	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	DO 810 I=COL1,COL2
	   OK = ACT_SET_COLOUR_ATTRIBUTE(
     &		OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT),I,DPRIN)
	   IF (.NOT.OK) THEN
	      CALL MOAN(MSG_COLNOTSET)
	      CALL LITES2_SIGNAL(OK)
	      GOTO 9990
	   ENDIF
810	CONTINUE
	GOTO 8000
C
C OVERLAY COLOUR colour subcommand
C
900	COL1 = DINTS(1)		! save the colour
	CALL GET_COMMAND(DSTR(:DSTRL),OVERLAY_COLOUR_CMD_TABLE)
	IF (MOANED) GOTO 9990
	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	GOTO (910,920,930), DPRIN
C
C---Secondary command number out of range
C
	CALL MSGCMD(NASTY,MSG_ERRSECIND)
	GOTO 9990
C
C RGB r g b
910	OK = ACT_SET_COLOUR_VALUE(
     &		OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT),
     &		COL1,DREALS(1),DREALS(2),DREALS(3) )
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   CALL LITES2_SIGNAL(OK)
	   GOTO 9990
	ENDIF
	GOTO 8000
C
C HLS h l s
920	OK = CONV_HLS_RGB(DREALS(1),DREALS(2),DREALS(3))
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   GOTO 9990
	ENDIF
	GOTO 910
C
C HSV h s v
930	OK = CONV_HSV_RGB(DREALS(1),DREALS(2),DREALS(3))
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   GOTO 9990
	ENDIF
	GOTO 910
C
C OVERLAY BACKDROP subcommand
C
1000	CALL GET_COMMAND(DSTR(:DSTRL),OVERLAY_COLOUR_CMD_TABLE)
	IF (MOANED) GOTO 9990
	GOTO (1010,1020,1030), DPRIN
C
C---Secondary command number out of range
C
	CALL MSGCMD(NASTY,MSG_ERRSECIND)
	GOTO 9990
C
C RGB r g b
1010	OK = ACT_SET_BACKDROP_VALUE(DISPLAY_PTR(DISPLAY_CURRENT),
     &				DREALS(1),DREALS(2),DREALS(3) )
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   CALL LITES2_SIGNAL(OK)
	   GOTO 9990
	ENDIF
	GOTO 8000
C
C HLS h l s
1020	OK = CONV_HLS_RGB(DREALS(1),DREALS(2),DREALS(3))
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   GOTO 9990
	ENDIF
	GOTO 1010
C
C HSV h s v
1030	OK = CONV_HSV_RGB(DREALS(1),DREALS(2),DREALS(3))
	IF (.NOT.OK) THEN
	   CALL MOAN(MSG_COLNOTSET)
	   GOTO 9990
	ENDIF
	GOTO 1010
C
C OVERLAY DELETE
C
1100	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	IF (OVERLAY_IMAGE(OVERLAY_CURRENT).OR.
     &	    OVERLAY_IFF(OVERLAY_CURRENT)) THEN
	   CALL MOAN(MSG_OVINUSE,OVERLAY_CURRENT)
	   CALL LEARN(MSG_USEOVCLEAR)
	   GOTO 9990
	ENDIF
	OK = ACT_DELETE_OVERLAY(
     &			OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (.NOT.OK) GOTO 9100
	OVERLAY_PTR(OVERLAY_CURRENT,DISPLAY_CURRENT) = 0
	OVERLAY_PLANES(OVERLAY_CURRENT,DISPLAY_CURRENT) = 0
	IF (DISPLAY_CURRENT.LE.2.AND.OVERLAY_SHARE) THEN
	   OVERLAY_PTR(OVERLAY_CURRENT,3-DISPLAY_CURRENT) = 0
	   OVERLAY_PLANES(OVERLAY_CURRENT,3-DISPLAY_CURRENT) = 0
	ENDIF
	IF (ANNOVER.EQ.OVERLAY_CURRENT) ANNOVER = 0
	OVERLAY_CURRENT = 0
C
C if no overlays remain, then delete the display also
	IF (DISPLAY_CURRENT.GT.2) GOTO 9999
	DO 1110 I=1,MAXOVER
	   IF (OVERLAY_PLANES(I,DISPLAY_CURRENT).NE.0) GOTO 9999
1110	CONTINUE
	OK = ACT_DELETE_DISPLAY(DISPLAY_PTR(DISPLAY_CURRENT))
	IF (.NOT.OK) THEN
	   CALL NASTY(MSG_INTERNALERROR)
	   CALL LITES2_SIGNAL(OK)
	ENDIF
C
	DISPLAY_EXISTS(DISPLAY_CURRENT) = .FALSE.
	DISPLAY_PTR(DISPLAY_CURRENT) = 0
	DISPLAY_PLANES(DISPLAY_CURRENT) = -1
	IF (OVERLAY_SHARE) THEN
	   DISPLAY_EXISTS(3-DISPLAY_CURRENT) = .FALSE.
	   DISPLAY_PTR(3-DISPLAY_CURRENT) = 0
	   DISPLAY_PLANES(3-DISPLAY_CURRENT) = -1
	   OVERLAY_SHARE = .FALSE.
	ENDIF
	IF (ANNODISP.EQ.DISPLAY_CURRENT) THEN
	   ANNODISP = 0
	   ANNOVER = 0
	ENDIF
	DISPLAY_CURRENT = 0
	OVERLAY_WORKSTATION = 0
	OVERLAYS_INUSE = .FALSE.
	GOTO 9999
C
C OVERLAY DEFER
C
1200	OVERLAY_DEFER = .TRUE.		! defer colour updating
	GOTO 9999
C
C OVERLAY UPDATE
C
1300	OVERLAY_DEFER = .FALSE.		! update colours
	GOTO 8000
C
C OVERLAY SELECT subcommand
C
1400	IF (DISPLAY_CURRENT.GT.2) GOTO 9300
	SEL = .TRUE.
	GOTO 1510
C
C OVERLAY DESELECT subcommand
C
1500	IF (DISPLAY_CURRENT.GT.2) GOTO 9300
	SEL = .FALSE.
C
C get tertiary command
1510	CALL GET_COMMAND(DSTR(:DSTRL),OVERLAY_SELECT_CMD_TABLE)
	IF (MOANED) GOTO 9990
	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
C
	GOTO (1511,1512,1513,1514,1515), DPRIN
C
C---Secondary command number out of range
C
	CALL MSGCMD(NASTY,MSG_ERRSECIND)
	GOTO 9990
C
C SELECT MAP range		- select maps
C
1511	IF (SINDEX.EQ.STATE_INITIAL) GOTO 9200
	IF (SEL) THEN
	   CALL SELEMP(O_SAMAPS(OVERLAY_CURRENT),
     &		       O_MAPSLCT(OVERLAY_CURRENT),
     &		       O_MAPSEL(0,OVERLAY_CURRENT) )
	ELSE
	   CALL DESEMP(O_SAMAPS(OVERLAY_CURRENT),
     &		       O_MAPSLCT(OVERLAY_CURRENT),
     &		       O_MAPSEL(0,OVERLAY_CURRENT) )
	ENDIF
	OVERLAY_IFF(OVERLAY_CURRENT) = .TRUE.
	GOTO 9999
C
C SELECT <OVERLAY,LAYER> range	- select layer numbers
C
1512	IF (SINDEX.EQ.STATE_INITIAL) GOTO 9200
	IF (SEL) THEN
	   CALL SELELY(O_SALAYS(OVERLAY_CURRENT),
     &		       O_LAYSLCT(OVERLAY_CURRENT),
     &		       O_OVSEL(0,OVERLAY_CURRENT) )
	ELSE
	   CALL DESELY(O_SALAYS(OVERLAY_CURRENT),
     &		       O_LAYSLCT(OVERLAY_CURRENT),
     &		       O_OVSEL(0,OVERLAY_CURRENT) )
	ENDIF
	OVERLAY_IFF(OVERLAY_CURRENT) = .TRUE.
	GOTO 9999
C
C SELECT <FC,IT> range/group	- select feature codes
C
1513	IF (SEL) THEN
	   CALL SELEFC(O_SAFCS(OVERLAY_CURRENT),
     &		       O_FCSLCT(OVERLAY_CURRENT),
     &		       O_FCMAP(1,OVERLAY_CURRENT) )
	ELSE
	   CALL DESEFC(O_SAFCS(OVERLAY_CURRENT),
     &		       O_FCSLCT(OVERLAY_CURRENT),
     &		       O_FCMAP(1,OVERLAY_CURRENT) )
	ENDIF
	OVERLAY_IFF(OVERLAY_CURRENT) = .TRUE.
	GOTO 9999
C
C SELECT ALL			- all maps, layers, feature codes, and
C				  FSNs (default selected)
1514	IF (SEL) THEN
	   CALL OVERLAY_SELEAL
	   OVERLAY_IFF(OVERLAY_CURRENT) = .TRUE.
	ELSE
	   CALL MSGCMD(MOAN,MSG_NOTPERMIT)
	   GOTO 9990
	ENDIF
	GOTO 9999
C
C SELECT IMAGE range		- select images
C
1515	CALL SELEIM(SEL,O_IMSEL(1,OVERLAY_CURRENT))
	OVERLAY_IMAGE(OVERLAY_CURRENT) = .TRUE.
	GOTO 9999
C
C OVERLAY BLANK - define colour to blank out behind texts
C 
1600	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
C
C if argument is present, then it must be positive.
C if not present, then it means cancel the overlay blanking colour
	IF (DNINT.GT.0) THEN
	   IF (DINTS(1).LT.0) THEN
	      CALL MOAN(MSG_NEGARGS)
	      GOTO 9990
	   ELSE
	      OVERLAY_BLANK(OVERLAY_CURRENT,DISPLAY_CURRENT) = DINTS(1)
	   ENDIF
	ELSE
	   OVERLAY_BLANK(OVERLAY_CURRENT,DISPLAY_CURRENT) = -1
	ENDIF
	IF (DISPLAY_CURRENT.LE.2.AND.OVERLAY_SHARE
     &		) OVERLAY_BLANK(OVERLAY_CURRENT,DISPLAY_CURRENT) =
     &			OVERLAY_BLANK(OVERLAY_CURRENT,3-DISPLAY_CURRENT)
	GOTO 9999
C
C OVERLAY ERASE - clear out overlay
C 
1700	IF (OVERLAY_CURRENT.EQ.0) GOTO 9000
	IF (PLOT_ON) GOTO 9999		! avoid for now
	IF (DISPLAY_CURRENT.GT.2) THEN
	   IF (WKAC(1)) CALL GDAWK(1)
	   IF (WKAC(2)) CALL GDAWK(2)
	ELSE
	   IF (.NOT.WKAC(DISPLAY_CURRENT)) GOTO 9999
	   IF (WKSUPP(DISPLAY_CURRENT)) THEN
	      CALL GDAWK(DISPLAY_CURRENT)
	      WKAC(DISPLAY_CURRENT) = .FALSE.
	   ENDIF
	   IF (OVERLAY_SHARE.AND.WKAC(3-DISPLAY_CURRENT).AND.
     &		WKSUPP(3-DISPLAY_CURRENT)) THEN
	      CALL GDAWK(3-DISPLAY_CURRENT)
	      WKAC(3-DISPLAY_CURRENT) = .FALSE.
	   ENDIF
	ENDIF
C
C select bit planes for this overlay
	MASKL = 0
	CALL LIB$INSV(-1,
     &	     OVERLAY_OFFSET(OVERLAY_CURRENT,DISPLAY_CURRENT),
     &	     OVERLAY_PLANES(OVERLAY_CURRENT,DISPLAY_CURRENT),MASKL)
	CALL LSG_PLANE_SELECT(DISPLAY_CURRENT,MASKL)
	CALL LSG_PLANE_OFFSET(DISPLAY_CURRENT,
     &		OVERLAY_OFFSET(OVERLAY_CURRENT,DISPLAY_CURRENT))
	IF (DISPLAY_CURRENT.LE.2.AND.OVERLAY_SHARE) THEN
	   IF (WKAC(3-DISPLAY_CURRENT)) THEN
	      CALL LSG_PLANE_SELECT(3-DISPLAY_CURRENT,MASKL)
	      CALL LSG_PLANE_OFFSET(3-DISPLAY_CURRENT,
     &		OVERLAY_OFFSET(OVERLAY_CURRENT,DISPLAY_CURRENT))
	   ENDIF
	ENDIF
C
C clear the area to be drawn into
	CALL GSFAIS(GSOLID)		! solid fill
	CALL GSFACI(0)			! in colour 0
C
C clear rectangle
	IF (DISPLAY_HADLIM(DISPLAY_CURRENT)) THEN
	   CALL LSG_FILL_RECTANGLE(DISPLAY_LIMITS(1,DISPLAY_CURRENT),
     &	                        DISPLAY_LIMITS(3,DISPLAY_CURRENT))
	ELSE
	   CALL LSG_FILL_RECTANGLE(LIMITS(1),LIMITS(3))
	ENDIF
C
C flush out
	IF (DISPLAY_CURRENT.GT.2) THEN
	   IF (WKAC(1)) CALL GACWK(1)
	   IF (WKAC(2)) CALL GACWK(2)
	ELSE
	   CALL LSG_PLANE_SELECT(DISPLAY_CURRENT,-1)
	   CALL LSG_PLANE_OFFSET(DISPLAY_CURRENT,0)
	   IF (.NOT.WKAC(DISPLAY_CURRENT)) THEN
	      CALL GACWK(DISPLAY_CURRENT)
	      WKAC(DISPLAY_CURRENT) = .TRUE.
	      WKSUPP(DISPLAY_CURRENT) = .FALSE.
	   ENDIF
	   IF (OVERLAY_SHARE) THEN
	      IF (WKOP(3-DISPLAY_CURRENT)) THEN
	         CALL LSG_PLANE_SELECT(3-DISPLAY_CURRENT,-1)
	         CALL LSG_PLANE_OFFSET(3-DISPLAY_CURRENT,0)
	         CALL LUWK(3-DISPLAY_CURRENT,GSUPP)
	         IF (.NOT.WKAC(3-DISPLAY_CURRENT)) THEN
	            CALL GACWK(3-DISPLAY_CURRENT)
	            WKAC(3-DISPLAY_CURRENT) = .TRUE.
	            WKSUPP(3-DISPLAY_CURRENT) = .FALSE.
	         ENDIF
	      ENDIF
	   ENDIF
	ENDIF
	CALL LUWK(DISPLAY_CURRENT,GSUPP)
C
	GOTO 9999
C
C Update colour map
8000	IF (SINDEX.NE.STATE_INITIAL.AND..NOT.OVERLAY_DEFER) THEN
	   IF (DISPLAY_PLANES(DISPLAY_CURRENT).GT.0) THEN
	      OK = ACT_RECALC(DISPLAY_PTR(DISPLAY_CURRENT),
     &				D_RED,D_GREEN,D_BLUE)
	      IF (.NOT.OK) GOTO 9100
	      CALL LSCRS(DISPLAY_CURRENT,
     &				2**DISPLAY_PLANES(DISPLAY_CURRENT),
     &				D_RED,D_GREEN,D_BLUE)
	   ENDIF
	ENDIF
	GOTO 9999
C
9000	CALL MOAN(MSG_NOCUROV)
	CALL LEARN(MSG_USEOVNUM)
	GOTO 9990
C
9100	CALL NASTY(MSG_INTERNALERROR)
	CALL LITES2_SIGNAL(OK)
	GOTO 9990
C
9200	CALL MSGCMD(MOAN,MSG_CMDNOTVALID)
	GOTO 9990
C
9300	CALL MSGCMD(MOAN,MSG_INVDISP)
	CALL LEARN(MSG_USEDISPNUM)
	GOTO 9990
C
9990	CALL IGNCMD
9999	RETURN
        END
