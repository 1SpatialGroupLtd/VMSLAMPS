	LOGICAL FUNCTION DIGTRN(BUFF,BUFFL,BUTTN,COORDX,COORDY,
     &			USEFUN,FUNC)
C
***	IDENT	29JA88
***	MODULE	DIGTRN
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C
	IMPLICIT NONE
C
C function to decode string from table
C
C *** return value is TRUE if fail, FALSE if succeed ***
C
	INTEGER*4	BUFFL	! length of buffer
	BYTE		BUFF(BUFFL) ! buffer to decode
	INTEGER*4	BUTTN	! button used on puck
	INTEGER*4	COORDX	! X coordinate from table
	INTEGER*4	COORDY	! Y coordinate
	LOGICAL*1	USEFUN	! use routine FUNC to do work
	LOGICAL		FUNC	! routine to use
C
C w/s
C
	BYTE		ICH		! character read from buffer
	INTEGER		OLD_DCPTR	! preserve current DCPTR
C
C and some relevant characters
C
	BYTE		DOLLAR,COMMA
	PARAMETER	(DOLLAR = '$')
	PARAMETER	(COMMA  = ',')
C
C functions called
C
	LOGICAL		RDCH		! read next char
	LOGICAL		RDLONG		! read a long integer
C
C *********************************************************************
C
C the Altek table returns strings of the form:
C
C	$A,12345,12345
C
C that is:
C
C	<dollar><button number><comma><X coord><comma><Y coord><CR>
C
C which gives us 14 characters in a well-formed string (we never
C actually see the <CR> - it just serves as a terminator)
C
C *********************************************************************
C
C if using supplied function, then do so
C
	IF (USEFUN) THEN
	   DIGTRN = FUNC(BUFF,BUFFL,BUTTN,COORDX,COORDY)
	   GOTO 9999
	ENDIF
C
C otherwise do the job ourselves
C
	DIGTRN = .TRUE.			! assume failure
	IF (BUFFL.NE.14) GOTO 9999	! bad string length
C
C Now check that the commas separating things are in exactly the
C right places
C
	IF ( BUFF(3).NE.COMMA  .OR.
     &	     BUFF(9).NE.COMMA ) GOTO 9999
C
C save our DCPTR value
C
	CALL DCPSAV( OLD_DCPTR )
C
C and let us read from s'thing which isn't TXTC
C ie we want to read the table line from BUFF...
C
	CALL SETAUX( BUFF, BUFFL)	! this also moves DCPTR to
C					! the start of the buffer
C *********************************************************************
C
C now read from it
C
	IF (RDCH(ICH))     GOTO 9998	! read the DOLLAR
	IF (ICH.NE.DOLLAR) GOTO 9998	! was it a $ ?
	IF (RDCH(ICH))   GOTO 9998	! read the button
	IF (ICH.GE.'0'.AND.ICH.LE.'9') THEN
	   BUTTN = ICH - 48		! a numeral
	ELSE
	   BUTTN = ICH - 55		! a letter
	ENDIF
C
C check value of button (note H is returned when table is interrogated)
	IF ((BUTTN.LT.0.OR.BUTTN.GT.'F'X).AND.BUTTN.NE.17) GOTO 9998
	IF (RDCH(ICH))     GOTO 9998	! read the comma
	IF (ICH.NE.COMMA)  GOTO 9998	! bad separator ?
	IF (RDLONG(COORDX))GOTO 9998	! read the X coord
	IF (RDCH(ICH))     GOTO 9998	! read next comma
	IF (ICH.NE.COMMA)  GOTO 9998	! bad separator ?
	IF (RDLONG(COORDY))GOTO 9998	! read the Y coord
C
C if we are outside the ordinary area of the table (ie below or to the
C left of the origin) then we will get coordinates greater than 90000
C Apart from the fact we shouldn't really be digitising here, we can
C correct this by making the numbers negative...
C
	IF (COORDX.GT.90000) THEN
	   COORDX = COORDX - (99999+1)
	ENDIF
C
	IF (COORDY.GT.90000) THEN
	   COORDY = COORDY - (99999+1)
	ENDIF
C
	IF (.NOT.RDCH(ICH)) GOTO 9998	! spurious trailing chars ?
C
C success !
C
	DIGTRN = .FALSE.
C
9998	CALL BSLN			! side effect is to set current
C					! buffer back to TXTC again
	CALL DCPSET( OLD_DCPTR )	! and back to our place in line
C					! (set DCPTR to what it was)
C
9999	RETURN
	END
