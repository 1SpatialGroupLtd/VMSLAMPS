	SUBROUTINE LINK(EC,RC,USEFND,FCODE)
C
***	MODULE	LINK
***	IDENT	25JL86
C
C Copyright Laser-Scan Laboratories Limited, Cambridge, England.
C
CMOD	Only change ACB during init; SAC added	 DM	25-Jul-1986
CMOD	Handle CLOSED ftr when 1st pt is a jnctn DM	22-Jul-1986
CMOD	Converged				 DM	25-Jun-1986
CMOD	Use LIMIT(5) rather than SMLLNS in MER	 DM	11-Jun-1986
CMOD	CUTler now treats ELF as a special case	 DM	03-Jun-1986
CMOD	APPSEG is now a logical function	 DM	16-May-1986
CMOD	JINHIB (Junction spotting INHIBit) added DM	01-May-1986
CMOD	JMT (Junction MaTching) added		 DM	28-Apr-1986
CMOD	Manual junction has MPJANG=-361, not -1	 DM	08-Apr-1986
CMOD	NEWVEC now a function; spots bad vector	 DM	20-Mar-1986
CMOD	If last pnt is junctn leave cursor on it DM	27-Nov-1985
CMOD	Cope with S(1)=0 in COMpact		 DM	07-Oct-1985
CMOD	Set direction in NORoll if JNCING	 DM	02-Oct-1985
CMOD	Set direction after appending junction	 DM	24-Sep-1985
CMOD	LJN (Locate and select JunctioN) added	 DM	11-Sep-1985
CMOD	Match the state of FB13 to JNCING (FPJ)	 DM	10-Sep-1985
CMOD	Set ROLING=.TRUE. in BACk (just in case) DM	09-Sep-1985
CMOD	TSTCON now a tri-state integer function	 DM	28-Aug-1985
CMOD	TF() stuff & messages rehashed		 DM	20-Aug-1985
CMOD	ANAlyse finally implemented !!		 DM	27-Jun-1985
CMOD
CMOD	*** OLD UPDATES NOW IN FLF.UPD ***	 DM	16-May-1986
CMOD
CMOD	Created					MCF	       1976
C
**	IF VAX
	IMPLICIT NONE
**	ENDC
C
C parameters:
***	PARAMETER/PARAMS/
C
	PARAMETER GOCOM=8	! fixed commands
	PARAMETER SMFCOM=9
C
C arguments:
	INTEGER	  EC		! entry code:
C					1 - initialise
C					2 - terminate
C					3 - digitise feature
C					4 - adjust mode
C					5 - try "small feature" first
	INTEGER	  RC		! return code:
C				      >=0 - flags for 2nd word of FS
C				       -1 - aborted
	LOGICAL*1 USEFND	! do auto find procedure (INI)
	INTEGER	  FCODE		! returns feature code set by FC commnd
C
***	COMMON/ANACOM/
***	COMMON/BLG/
***	COMMON/DIGC/
***	COMMON/DRWSCL/
***	COMMON/EFNETC/
***	COMMON/ELFPAR/
***	COMMON/EXPC/
***	COMMON/FORKS/
***	COMMON/FTRLST/
***	COMMON/JNCLST/
***	COMMON/JOINTS/
***	COMMON/JUNCTN/
***	COMMON/LINKS/
***	COMMON/LKFOLL/
***	COMMON/LKPARM/
***	COMMON/LNKC/
***	COMMON/MASTER/
***	COMMON/MPAUX/
***	COMMON/MPEP/
***	COMMON/RSE/
***	COMMON/SCCORR/
***	COMMON/SCOTS/
***	COMMON/SCPARM/
***	COMMON/TRKSEG/
***	COMMON/TXTC/
C
**	IF AREA
***	COMMON/AREA/
***	COMMON/XYPIXC/
**	ENDC
C
C functions called:
	INTEGER	  EXPAND
	INTEGER   GETMAC,SETMAC
	INTEGER	  JMATCH
	INTEGER	  LOCJUN
	INTEGER   NEWTIM
	INTEGER   NXTCOM
	INTEGER   RDCOMM
	INTEGER   TSTCON
	LOGICAL	  APPSEG
	LOGICAL	  SMLFTR,BUNCH,ONSIDE
	LOGICAL	  NEWVEC
C
**	IF AREA
	INTEGER	  ARESCA
	LOGICAL	  GETPT
**	ENDC
C
C command table:
	INTEGER   DRWCM
	EXTERNAL  DRWCM
C
C workspace:
	INTEGER   AUTCOM
	INTEGER	  CONTYP(0:7)	! connection type names
	INTEGER   CWD
	INTEGER	  FORCED
	INTEGER   FSTLST(2)	! 'FST','LST'
	INTEGER   I,N,M
	INTEGER   IFB
	INTEGER   ININUM	! the macro for INI
	INTEGER	  JO_CUR_FTR
	INTEGER   MAXSUP,MINSUP
	INTEGER   MOVING
	INTEGER   NMPCON	! Number of last CONfirmed Master Point
	INTEGER   NMPMAX,NMPMIN
	INTEGER	  NXTDIR
	INTEGER   SAVTYP
	INTEGER   SECID(2)	! direction to be used for second half
	INTEGER   TF(0:1)	! for neat output
	INTEGER   TOLD		! previous time zone
	LOGICAL*1 BOOL
	LOGICAL*1 BOX		! for small feature scans
	LOGICAL*1 CLOSED
	LOGICAL*1 FIRSTP
	LOGICAL*1 HADINI	! obeyed the INI macro
	LOGICAL*1 ICH
	LOGICAL*1 MANUAL
	LOGICAL*1 MODPIC	! truncate rather than redraw picture
	LOGICAL*1 NEAR
	LOGICAL*1 OLDDSP
	LOGICAL*1 OUTPUT	! points to be output to IFF ?
	LOGICAL*1 RDING
	LOGICAL*1 ROLING
	LOGICAL*1 SECOND	! second part of two-part feature ?
	LOGICAL*1 SEQ,CUT	! used in DIG & CUT (in-built macros)
	LOGICAL*1 SQARED	! item has been squared
	REAL      D(2)
	REAL      R,R1
	REAL      ROLPOS(2)
	REAL      XC,YC
C
**	IF AREA
	LOGICAL*1 AREDNE	! performed an area-scan for this pass ?
	LOGICAL*1 NOMAP		! no byte map required ?
	REAL	  CENX,CENY	! 'centre' of area scan (see ARESCA)
	REAL	  SCBLSZ	! scan-block size (counts)
	REAL	  XBLH,YBLH	! bottom left corner for RASter option
	REAL	  XTRH,YTRH
**	ENDC
C
	DATA CONTYP/3RLIN,3REDG,3RWID,3RAPX,3RPRE,3RJUN,3RRPX,3RJUN/
	DATA FSTLST/3RFST,3RLST/
	DATA TF(0),TF(1)/'-','+'/
C
C ......................................................................
C
	RC=0
	ININUM=INICOM
	HADINI=.NOT.(USEFND.OR.JNCING)
	BOX=EC.EQ.5
	RSEOFF(X)=0
	RSEOFF(Y)=0
C
**	IF AREA
	ENCARE=0
	AREDNE=.FALSE.
**	ENDC
C
	GO TO (20,60,100,100,40),EC
	CALL WRITEF('LINK: EC of %N !',EC)
	GO TO 2840
C
C ......................................................................
C
C Initialise
C
20	CALL IFFSYS(SAVLUN,2,RDING)
	CALL SETMAC(4)
	LNKFB="100000
	CALL CSWT(0.0,0.0)
	NXTID(X)=200
	NXTID(Y)=200
	FBCODE(14)=14
	FBCODE(16)=16
	INIABO=.FALSE.
	GO TO 100
C
C ......................................................................
C
C set up for small feature
C
40	ININUM=SMFCOM
	HADINI=.FALSE.
C
**	UNLESS AREA
	I=ELF				! remember current ELF setting
	CALL PARIO(4,PTYPE)
	ELF=I
	IMOD=ELF.XOR.1			! reset IMOD according to ELF
	IF (HADLDI) CALL CSRD(NEXT(X),NEXT(Y))
	NXTID(X)=INT(FLOAT(IWID)*WAR*CRY)
	NXTID(Y)=0
	CALL CSWT(NEXT(X)-NXTID(X)/2,NEXT(Y))
**	ENDC
C
	GO TO 100
C
C ......................................................................
C
C Terminate
C
60	IF (.NOT.INIABO) CALL IFFSYS(SAVLUN,1,RDING)
	GO TO 2840
C
C ......................................................................
C
C start
C
80	ELF=-1				! enable automatic ELF setting
	CALL PARIO(4,LTYPE)		! reset to default type
	IF (ELF.LT.0) ELF=IMOD.XOR.1
	BOX=.FALSE.			! for failed small features
C
C ......................................................................
C
C Reset
C
100	SECOND=.FALSE.
	FIRSTP=.TRUE.
	OUTPUT=EC.NE.4
	NMP(1)=0
	INDEX(1)=0
	NMPIFF=0
	SEGLEN=0
	FBCODE(7)=0		! clear unwanted commands from last time
C
C second time around come here
C
120	IF (HADLDI) CALL CSRD(NEXT(X),NEXT(Y))
	CALL SETCHN
C
	CHNSEL=0
	LSTSEL=0
	LSTFRK=0
	TRKWID=-1.0
	TRKPOL=0				! only used if ELF
	NEOLD =0
	AUTCOM=0
	MOVING=2
	NXTDIR=-1
	DRWVEC=.TRUE.
	PENUP =.TRUE.
	NMPCON=0
	ANLYZD=-1
	JINHIB=.FALSE.
	JUMPED=.FALSE.
	MANUAL=.FALSE.
	SCNND =.FALSE.
	GROWN =.FALSE.
	PACTED=.FALSE.
	LISTED=.FALSE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
	ASSED =.FALSE.
	MERGED=.FALSE.
	FAST  =SECOND
	VERY  =.FALSE.
	ROLING=.FALSE.
	CLOSED=.FALSE.
	SQARED=.FALSE.
	CODPOS=.FALSE.
	DISP  =.TRUE.
	OLDDSP=DISP
	MODPIC=.FALSE.
C
C *** nasty frig for FB4=GO !
	FBCODE(4)=LNKCAL+GOCOM-1
	LNKFB=LNKFB.OR."10
C *** end of frig
C
C Display the general state of play
C
140	IF (DISP.EQ.OLDDSP) GO TO 160
	OLDDSP=DISP
	IF (     DISP) CALL NEWTIM(THELP)	! now in HELP mode
	IF (.NOT.DISP) CALL NEWTIM(TFOLL)	! now following
160	IF (DISP.AND.HADLDI)
     &    CALL LNKDRW(MODPIC,MANUAL,ROLING,
     &                MOVING,SQARED,ROLPOS,NXTDIR,BOX)
	MODPIC=.FALSE.
	GO TO 200
C
C Refresh loop and commands
180	DCPTR =-1
	TXTPTR=-2
	CODPOS=0
C
200	N=LNKFB
	IF (JNCING) GO TO 205
	N=N.AND.(.NOT."10000)
	GO TO 210
205	N=N.OR."10000
210	IF (MOVING .EQ. 1) N=N.OR."20000
	CALL FBWT16(N)
	SEQ=.FALSE.
	N=ININUM			! do we want INI command ?
	IF (N.LE.0.OR.HADINI) GO TO 220	! if we don't
	HADINI=.TRUE.
	GO TO 700			! yes - go & get it
C
C get a line and deal with it
220	IF (RDING.AND.DCPTR.GE.TXTPTR) GO TO 280
	CWD=NXTCOM()
	IF (CWD) 260,260,240
C
240	IF (CWD .LE. LNKACT) GO TO 400
	CALL INOUT(CWD-LNKACT)		! set, or type, something
	IF (RDING) GO TO 220
	GO TO 140			! DISP may have changed
C
C blank line or error
260	IF (DCPTR .LT. 0) GO TO 280
	IF (RDING) GO TO 220
	GO TO 180
C
C see about the next line from patch file
280	IF (.NOT.RDING) GO TO 300
	CALL RDABO			! to prevent it hanging
	CALL IFFSYS(SAVLUN,3,RDING,TXTBUF,TXTPTR)
	IF (.NOT.RDING) GO TO 2820	! end of initialise
	DCPTR=1
	IF (ECHO) CALL WRITEF('%A70',TXTBUF)
	GO TO 220
C
C move next scan with cursor
300	IF (DISP .AND. ROLING) GO TO 380
	IF (DISP) GO TO (320,340),MOVING
	GO TO 200
C
C change position
320	IF (HADLDI) CALL CSRD(NEXT(X),NEXT(Y))
	GO TO 360
C
C change angle
340	IF (HADLDI) CALL CSAJST(XC,YC)
	D(X)=XC-NEXT(X)
	D(Y)=YC-NEXT(Y)
	R=SQRT(D(X)*D(X)+D(Y)*D(Y))
	R1=1.0
	IF (R .GT. 30000.0) R1=30000.0/R
	NXTID(X)=D(X)*R1
	NXTID(Y)=D(Y)*R1
360	IF (MANUAL) GO TO 200
	MODPIC=.TRUE.
	GO TO 140
C
C roll along the MP line
380	CALL RALONG(NMPMIN,NMPMAX,ROLPOS)
	GO TO 140
C
C here for commands that do things
C
400	IF (CWD .LE. 16) CWD=FBCODE(CWD)
	GO TO (
     &     200,  200,  200,  200,
     &     200,  200,  200,  200,
     &     200,  200,  200,  200,
     &     200,  440,  200, 1430,	! xxx,MOV,xxx,ABO
C
C macro commands
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,
     &     680,  680,  680,  680,  680,	! MACNUM of these
C
     &     720,  720,  720,		! DEF,PMA,COD
     &	   770,  800,  800,  800,  780, ! VAR,PAR,SET,PTY,TYP
     &     840,   80,  500,		! ADJ,STA,PCO
     &     520,  640,  660,  860,  880,	! PAS,RFB,TFB,QUE,PAU
     &     900,  920,			! FBX, FB
     &    1440, 1460, 1480,		! TWO,MER,CRU
     &    1500, 1510, 1520,		! USE,LJN,MAJ
     &	  1600, 1620, 1630, 1640,	! PIX,EXT,JMT,PPX
     &    1660, 1680, 1700,		! DIG,CUT,SCA
     &	  1850,				! RAS
     &	  1860, 1880,			! GRO,SMT
     &    1900, 1940, 1960, 2020,	! COM,LIS,APP,FOR
     &    2080,	2170,			! TSF,NXE
     &    2180, 2200, 2220, 2240, 2260,	! DRO,FIR,NXT,FUM,RET
     &    2280, 2300, 2360, 2440, 2460,	! LOO,SQU,END,JUM,IFC
     &    2480, 2520, 2500, 2680, 2700,	! ASS,STE,AUT,SLO,FAS
     &    2720, 2760, 1160, 1180, 1200,	! PRE,POK,TXZ,DRW,DRN
     &    1240, 1300, 1320, 1340, 1360,	!  MP,BCC,BAC,ROL,NOR
     &    1380, 1400,			! CUR,MAN
     &    1410, 1411, 1415, 1420,	!  FC,ACB, AC,SAC
     &     960, 1000,			! FCF,TYF
     &    1060, 1080, 1140, 1150,1155,	! PMI,PME,JOI,CLJ,WAD
     &    1870,				! ANA
     &    2840          ),CWD		! EXI
	GO TO 200
C
C out of context commands
C
420	CALL WRITEF('Out of context !')
	GO TO 180
C
C change the action of the cursor
C
440	MANUAL=.FALSE.
	IF (INTARG .NE. 0) MOVING=INTARG
	GO TO (480,460),MOVING
C
460	MOVING=1
	CALL CSWT(NEXT(X),NEXT(Y))
	GO TO 200
C
480	MOVING=2
	CALL CSWT(NEXT(X)+NXTID(X),NEXT(Y)+NXTID(Y))
	NXTDIR=-1
	GO TO 200
C
C PCO/TCO - Indicate the general context
C
500	CALL EXPAND('%A1SCANNED %A1GROWN %A1COMPACTED %A1LISTED ',
     &               TF(SCNND.AND.1),TF(GROWN.AND.1),TF(PACTED.AND.1),
     &		     TF(LISTED.AND.1))
	CALL APPEND('%A1ASSESSED %A1FORKED %A1JOINTED %A1MERGED',
     &		     TF(ASSED.AND.1),TF(FORKED.AND.1),TF(JOINTD.AND.1),
     &		     TF(MERGED.AND.1))
	CALL LINOUT
	CALL WRITEF(
     &	     'ANALYSED %N, %N point%m output to file for this feature',
     &		     ANLYZD,NMPIFF)
	GO TO 200
C
C PAS n - Indicate our assessment, n=0 -> verbose
C
520	CALL EXPAND('%A1APPENDABLE %A1CONFUSED %A1LOST %A1VERY %A1SCAN',
     &		    TF(1-((NOTAPP.OR.CNFSED.OR.LOST.OR.SCAN).AND.1)),
     &		    TF(CNFSED.AND.1),
     &		    TF(LOST.AND.1),TF(VERY.AND.1),TF(SCAN.AND.1))
	CALL APPEND(' TRACKWIDTH %F0.1',TRKWID)
	IF (ELF) CALL APPEND(' POLARITY %N',TRKPOL)
	CALL TTWLIN
	IF (WIZARD.AND.NLOST.NE.0) CALL WRITEF('NLOST %N',NLOST)
	IF (INTARG .NE. 0) GO TO 200
	I=BSTCON
	IF (I .LE. 0) GO TO 200
C
	IF (CONNCT(4,I).NE.5) GO TO 540
	CALL WRITEF('JUNCTION ARM QUALITY')
	GO TO 560
540	IF (ELF) THEN
	  CALL WRITEF('POLARITY END TYPE QUALITY')
	ELSE
	  CALL WRITEF(' OFFSET  END TYPE QUALITY')
	ENDIF
560	CALL WRITEF(' ')
C
580	IF (CONNCT(4,I).NE.5) GO TO 600
	CALL WRITEF('%I5    %I2 %F8.2',
     &          CONNCT(2,I),CONNCT(3,I),QUALTY(I))
	GO TO 620
600	CALL WRITEF('%I6   %R  %R%F8.2',
     &          CONNCT(1,I),FSTLST(CONNCT(3,I)),
     &          CONTYP(CONNCT(4,I)),QUALTY(I))
620	I=NXTBST(I)
	IF (I.GT.0) GO TO 580
	GO TO 200
C
C RFB - Read Function Button & store result for later testing
C
640	CALL FBRD(IFB)
	GO TO 200
C
C TFB n mmm - Test Function Button & obey command
C	a) lights FBn
C	b) tests to see if FBn has been pressed in this cycle
C	c) obeys command 'mmm' with INTARG set to zero if FB pressed
660	N=INTARG
	LNKFB=LNKFB.OR.ISHFT(1,N-1)
	CALL FBWT16(LNKFB)
	CWD=NXTCOM()
	INTARG=0
	IF (IFB .NE. N) GO TO 200	! carry on
	IF (CWD) 180,180,240		! error or specified command
C
C call macro command
C
680	N=CWD-LNKCAL+1
700	M=GETMAC(N)
	GO TO 740
C
C define, print and code macro commands
C
720	I=CWD-LNKDEF+1
C
C do we let him change anything (unless we are initialising or adj'ng) ?
	IF ((I.EQ.1.OR.I.EQ.3).AND.
     &      .NOT.WIZARD.AND.
     &      (EC.NE.1).AND.
     &      (EC.NE.4)) GO TO 820
	M=SETMAC(I)
740	GO TO (200,260,760),M
760	IF (RDING) GO TO 280			! for a new line
	GO TO 180
C
C VAR m n r - set parameter 'm' for type 'n' to be 'r'
C
770	IF (NUMREL.GT.0) GO TO 800		! need ADJ to change it
	I=0					! but just typing is OK
	GO TO 810
C
C TYPE (n) - Track-dependant parameter mechanism
C
780	IF (INTARG.LE.0) INTARG=SAVTYP
	SAVTYP=LTYPE
	LTYPE=INTARG
	ELF=-1					! fall through to ...
C
C PAR,SET,PTY
C
800	I=CWD-LNKPAR+1
	IF ((I.LE.2).AND.
     &      .NOT.WIZARD.AND.
     &      (EC.NE.1).AND.
     &      (EC.NE.4)) GO TO 820
810	CALL PARIO(I,INTARG)
	IF ((I.EQ.4).AND.(ELF.LT.0)) ELF=IMOD.XOR.1
	GO TO 200
C
C moan if tried to alter something without typing the magic word
820	CALL WRITEF('Type ADJ to modify the type table and macros%C',7)
	GO TO 180
C
C ADJ - enable changing of parameters
C
840	IF (WIZARD.EQ.0) WIZARD=1
	GO TO 200
C
C QUE n mmm - queue up command 'mmm' to occur
C             after n/100 seconds.
C
860	QUETIM=INTARG		! delay
	QUECOM=NXTCOM()	! command number
	IF (QUECOM) 260,260,200	! report any error
C
C PAU n mmm - test FBn (which is lit) to set not FAST.
C	      Obey 'mmm' if not fast, else skip it.
C
880	I=ISHFT(1,INTARG-1)
	LNKFB=LNKFB.OR.I
	CALL FBRD(N)
	FAST=FAST .AND. N.NE.INTARG
	CWD =NXTCOM()
	IF (FAST) GO TO 200	! carry on
	IF (CWD) 180,180,240
C
C FBX n - remove alias from FBn (n < 0 ==> apply to FB1 thru FBn)
C
900	CWD=0
C
C FB n mmm - define FBn to be synonymous with command 'mmm'. FBn is lit.
C	     if 'mmm' is illegal or missing, then treat as 'FBX n'
C
920	M=INTARG
	IF (IABS(M).GT.16) GO TO 180
	IF (CWD .NE. 0) CWD=NXTCOM()
	IF (CWD .LT. 0) CWD=0
	DO 940 N=MAX(1,M),IABS(M)
	  FBCODE(N)=CWD
	  I=ISHFT(1,N-1)
	  LNKFB=(LNKFB.AND..NOT.I).OR.((CWD.GT.0).AND.I)
940	CONTINUE
	GO TO 200
C
C FCF nnnnnnn - set up ITFTAB - as in FLSUB, but can be done in IFRSYS
C
960	IF (EC.NE.1) GO TO 1040
	DO 980 I=1,MAXFB
	  ITFTAB(I)=INTAR(I)
980	CONTINUE
	GO TO 200
C
C TYF nnnnnnn - set up TYFTAB
C
1000	IF (EC.NE.1) GO TO 1040
	DO 1020 I=1,MAXFB
	  TYFTAB(I)=INTAR(I)
1020	CONTINUE
	GO TO 200
C
1040	CALL WRITEF('Command not available in this mode%C',7)
	GO TO 200
C
C PMI,PME - init and end performance monitoring
1060	IF (PMEING) GO TO 1100
	CALL PME_INIT
	PMEING=.TRUE.
	GO TO 200
C
1080	IF (.NOT.PMEING) GO TO 1120
	CALL PME_EXIT
	PMEING=.FALSE.
	GO TO 200
C
1100	CALL WRITEF('PME already initialised')
	GO TO 200
1120	CALL WRITEF('PME not initialised')
	GO TO 200
C
C JOI - create some JOINTS (N.B. distinct from ANALYZ's JOINS).
1140	CALL SETCHN
	IF (.NOT.SCNND) GO TO 420
	CALL JOIN(IU,IV)
	JOINTD=.TRUE.
	PACTED=.FALSE.
	LISTED=.FALSE.
	FORKED=.FALSE.
	MERGED=.FALSE.
	CHNSEL=0
	LSTSEL=0
	GROWN =.TRUE.
	GO TO 200
C
C CLJ - CLosed Jointed small feature.
1150	IF (.NOT.JOINTD.OR..NOT.LISTED) GO TO 420
	JO_FTR_NUM=0
	JO_CUR_FTR=0
	CALL CLOJOI(START,ID,IU,IV)
	GO TO 200
C
C WAD - waddle around a CLJ feature extracting master points.
1155	IF (JO_FTR_NUM.LE.0) GO TO 200
	JO_CUR_FTR=JO_CUR_FTR+1
	IF (INTARG.GT.0) JO_CUR_FTR=INTARG
	IF (JO_CUR_FTR.GT.JO_FTR_NUM) JO_CUR_FTR=1
	NMP(1)=0
	CALL WADDLE(START,JO_FPOINTS(X,JO_FFIRST(1,JO_CUR_FTR)),
     &                                JO_FLENGTH(1,JO_CUR_FTR),
     &                    JO_FPOINTS(X,JO_FFIRST(2,JO_CUR_FTR)),
     &                                JO_FLENGTH(2,JO_CUR_FTR),TMPCHK)
	GO TO 200
C
C TXZ - clear Tektronix screen
C
1160	CALL RDABO
	CALL TXCLR
	GO TO 200
C
C DRAW something
C
1180	BOOL=.TRUE.	! "DRW" => set scale & draw scan
	GO TO 1220
C
1200	BOOL=.FALSE.	! "DRN" => don't (uses existing scale)
1220	IF (DCPTR.GE.TXTPTR) GO TO 200	! nothing to read
	CWD=RDCOMM(DRWCM,.FALSE.)
	IF (CWD.LT.0) GO TO 420		! number - moan
	IF (CWD.EQ.0) GO TO 200
	CALL RDABO
	CALL LNKTEK(BOOL,CWD)
	GO TO 1220
C
C add a Master Point
C
1240	IF (.NOT.MANUAL) GO TO 1280		! first time ?
	IF (.NOT.ROLING) GO TO 1250		! no - in ROLING mode ?
	ROLING=.FALSE.				! yes - stop it (??)
	CALL BUNCH(ROLPOS(X),ROLPOS(Y),-2)	! tidy up (creating MP)
1250	IF (NMP(1).GT.MAXMP-2) GO TO 1260
	IF (HADLDI) CALL CSRD(XC,YC)
	IF (BUNCH(XC,YC,1)) MPTYPE(NMP(1))=-1
	IF (NMP(1).GT.1) GO TO 140
	SEC(X)=MP1(X,1)
	SEC(Y)=MP1(Y,1)
	SECTYP=MPTYPE(1)
	GO TO 140
C
1260	CALL WRITEF('No room for manual point')
	MANUAL=.FALSE.
	GO TO 140
C
C first time - set up
1280	MANUAL=.TRUE.
	CHNSEL=0			! drop selection
	MOVING=1
	IF (JINHIB) JNCING=JINHIB
	IF (NMP(1).LT.1) GO TO 1295
	IF (ROLING) GO TO 1285
	CALL BUNCH(0.0,0.0,2)		! tidy up backlogged points
	CALL CSWT(MP1(X,NMP(1)),MP1(Y,NMP(1)))
	GO TO 1290
1285	CALL BUNCH(ROLPOS(X),ROLPOS(Y),-2)	! tidy up if ROLING
1290	IF (MPTYPE(NMP(1)).EQ.0) MPTYPE(NMP(1))=-1
1295	ROLING=.FALSE.				! (which we now stop)
	ANLYZD=-1
	GO TO 140
C
C BCC - come back by one master point checking to ensure that we do not
C come back past the last confirmed point.
C
1300	IF (NMP(1).LE.NMPCON) GO TO 200
C
C come BACk by one master point
C
1320	IF (NMP(1).LE.1) GO TO 140
	CALL BUNCH(0.0,0.0,2)			! tidy up
	ROLING=.TRUE.
	CLOSED=.FALSE.
	TRKWID=-1.0				! forget current width
	NMP(1)=NMP(1) - 1			! it's as easy as that !
C
	CHNSEL=0
	LSTSEL=0
	ROLPOS(X)=MP1(X,NMP(1))
	ROLPOS(Y)=MP1(Y,NMP(1))
	CALL CSWT(ROLPOS(X),ROLPOS(Y))
	NEXT(X)=ROLPOS(X)
	NEXT(Y)=ROLPOS(Y)
	GO TO 140
C
C set ROLling mode
1340	ANLYZD=-1
	IF (JINHIB) JNCING=JINHIB
	IF (NMP(1).LE.0) GO TO 140
	CALL BUNCH(0.0,0.0,2)			! tidy up
	IF (NMP(1).LE.1) GO TO 140
	NMPMIN=1
	NMPMAX=NMP(1)
	IF (NMPMAX.LE.NMPMIN) GO TO 1360
	ROLING=.TRUE.
	CLOSED=.FALSE.
	CALL CSWT(MP1(X,NMP(1)),MP1(Y,NMP(1)))
	IF (HADLDI) CALL CSAJST(ROLPOS(X),ROLPOS(Y))
	GO TO 140
C
C NOR - unset rolling mode
1360	IF (.NOT.ROLING) GO TO 140
	ROLING=.FALSE.
	CALL BUNCH(ROLPOS(X),ROLPOS(Y),-2)	! tidy up (creating MP)
	IF (.NOT.(JNCING.OR.JINHIB)) GO TO 1370	! junctions enabled ?
	CALL NEWVEC(1,NXTDIR)			! yes - set scan directn
	CALL SETDIR(NXTID,IDIR,IU,IV)
	ID(IU)=IDSIZE
	ID(IV)=0
1370	NEXT(X)=ROLPOS(X)
	NEXT(Y)=ROLPOS(Y)
	ANLYZD=-1
	GO TO 140
C
C align CURsor using the CLOse-up screen
C
1380	CALL PARIO(4,PTYPE)		! set wide line type
	CALL FAX(.TRUE.,IWID,IPIT)
	GO TO 1405
C
C use close-up screen to MANually measure a series of points.
C
1400	CALL PARIO(4,PTYPE)		! set wide line type
	IF (.NOT.ROLING) GO TO 1401	! in ROLING mode ?
	ROLING=.FALSE.			! yes - stop it
	CALL BUNCH(ROLPOS(X),ROLPOS(Y),-2)	! tidy up (creating MP)
1401	MANUAL=.TRUE.
	CALL FAX(.FALSE.,IWID,IPIT)
	CALL MANDIG(IWID,IPIT)
1405	CALL PARIO(4,LTYPE)		! restore old line type
	GO TO 140
C
C FC change feature code for the current feature
1410	FCODE=INTARG
	GO TO 200
C
C ACB base - show or alter the Ancillary Code Base. This value is added
C to the TYPE field of all ACs subsequently added using the AC or SAC
C command facilities. Note that this does NOT affect special LSL ACs
C such as our automatic use of AC 3 for height coding.
1411	IF (NUMINT.EQ.0) GO TO 1412
	IF (EC.NE.1) GO TO 1413
	ACBASE=INTARG
	GO TO 1425
C
1412	CALL WRITEF('Current Ancillary Code Base is %N',ACBASE)
	GO TO 1425
1413	CALL WRITEF(
     &	    'You cannot alter the Ancillary Code Base in this mode%C',7)
	GO TO 1425
C
C AC type value [text] - insert an AC entry in the file at the current
C writing position.
1415	IF (EC.NE.3.AND.EC.NE.5) GO TO 420	! must have NF etc
	IF (NMPIFF.GT.0) GO TO 1419		! can't have output STs
	CALL GENAC				! read and create AC
	GO TO 1425
C
1419	CALL WRITEF('Too late !%C',7)
	GO TO 1425
C
C SAC - Set/show the Standing Ancillary Code (only set if initialising).
1420	CALL STNDAC(EC.NE.1)
1425	DCPTR=-1				! junk rest of line
	TXTPTR=-2
	GO TO 200
C
C Reset/abort/exit
C
1430	GO TO (200,2840,2780,2840,2780),EC
C
C TWO	- scan twice & grow the results
C
1440	IF (.NOT.HADLDI) GO TO 140
	START(X)=NEXT(X)
	START(Y)=NEXT(Y)
	ID(X)=MAX(ABS(NXTID(X)),ABS(NXTID(Y)))
	ID(Y)=0
	IF (EC.EQ.5) START(X)=START(X) + ID(X)/2   ! centre the scan
C
**	IF AREA
	IF (ELF) THEN
	   CALL DISMOD(0)
	   CALL SETCHN				! to clear chain arrays
	   I=ARESCA(START(X),START(Y),ARESQX,ARESQY,.TRUE.,.FALSE.)
	   CALL GRWARE(I,HOLE,RIPPLE,IU,IV,IPIT)
	ELSE
	   CALL ICHNIN(START,ID)
	ENDIF
**	IFF
	CALL ICHNIN(START,ID)
**	ENDC
C
	IU=1				! remember hor. scan vector
	IV=2
	SCNND=.TRUE.
	GROWN=.TRUE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
	LISTED=.FALSE.
	GO TO 140
C
C MER -	merge the results of TWO scans
C
1460	CALL MERSCN(EPSLON,IFIX(LIMIT(5)+0.5))
	MERGED=.TRUE.
	LISTED=.TRUE.
	GO TO 200
C
C CRUsh - similar to COMPACT
C
1480	IF (.NOT.GROWN) GO TO 420
	CALL CRUSH(ETA,CRUCOS,CRUDIS)
	PACTED=.TRUE.
	LISTED=.FALSE.
	GO TO 200
C
C USE - look for a junction
C
1500	IF (.NOT.LISTED) GO TO 420
	CALL JMAIN(I)			! dummy arg will not set CONGOT
	GO TO 200
C
C LJN - locate a previously digitised junction and take it 'in hand'.
C
1510	IF (.NOT.ROLING) GO TO 140
	IF (LOCJUN(ROLPOS(X),ROLPOS(Y))) 1511,140,1515
C
1511	FAST=.TRUE.			! manual junction ...
	FRKCOM=24			! fall into MJN from DECide
	LSTFRK=-1			! don't let ASSESS cobble FRKCOM
	GO TO 1516			! join common code
C
1515	FAST=.FALSE.			! fall into INTerrupt from DEC
1516	ROLING=.FALSE.			! stop rolling now
	N=4
	GO TO 700			! dummy up an 'OKK' 
C
C MAJ n - add junction with n arms at current manual cursor position
C
1520	IF (NJUNC.LE.MAXJL-2) GO TO 1540
	CALL WRITEF('Unable to add junction%C',7)
	GO TO 180
1540	IF (INTARG.GT.1) GO TO 1560
	CALL WRITEF('You must specify the number of arms%C',7)
	GO TO 180
1560	IF (INTARG.LE.MAXBRA) GO TO 1580
	CALL WRITEF('Too many arms%C',7)
	GO TO 180
1580	IF (.NOT.MANUAL) GO TO 420	! out of context
	IF (NMP(1).GT.MAXMP-2) GO TO 1260	! no room - moan
	JINHIB=JNCING			! inhibit junction spotting
	IF (HADLDI) CALL CSRD(XC,YC)	! get the cursor position
	CALL BUNCH(XC,YC,1)		! add it to the master pt buffer
	IF (INTARG.LE.2) GO TO 140
	MPTYPE(NMP(1))=INTARG		! flag it as a junction
	DO 1590 I=1,MAXBRA
	  MPJANG(I,NMP(1))=-361
1590	CONTINUE
	NJUNC=JLNJP
	DO 1595 I=1,NMP(1)
	  IF (MPTYPE(I).GT.0) NJUNC=NJUNC + 1
1595	CONTINUE
	IF (NJUNC.GE.MAXJL-1)
     &     CALL WRITEF('WARNING - no more junctions can be added%C',7)
	GO TO 140
C
C PIX - scan in two dimensions and form pixels
1600	IF (ANLYZD.NE.1) GO TO 1610	! junction found by ANALYZ ?
	ANLYZD=ANLYZD + 1		! (only reset NEXT once)
	NEXT(X)=START(X) + JUNSCN(X)
	NEXT(Y)=START(Y) + JUNSCN(Y)
1610	START(X)=NEXT(X)
	START(Y)=NEXT(Y)
	IF (HADLDI) THEN
	   IF (MANUAL) CALL CSRD(START(X),START(Y))
	   IF (EC.EQ.5) START(X)=START(X) + NXTID(X)/2 ! centre the scan
	   CALL XYSCA(START(X),START(Y))
	ENDIF
	SCNND=.TRUE.
	GROWN=.FALSE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
	LISTED=.FALSE.
	GO TO 140
C
C EXT - form contours, and grown, listed, compacted chains
1620	I=0
	IF (NUMINT.GT.0) I=INTARG
	CALL EXTCHN(I)
	SCNND =.TRUE.
	GROWN =.TRUE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
	LISTED=.TRUE.
	CUT   =.FALSE.
	MERGED=.TRUE.
	CHNSEL=0
	LSTSEL=0
	GO TO 200
C
C JMT - Junction MaTching (look for junction in the immediate vicinity).
1630	IF (JMATCH(MANUAL)) 1631,200,1635
C
1631	FAST=.TRUE.			! manual junction ...
	FRKCOM=24			! fall into MJN from DECide
	LSTFRK=-1			! don't let ASSESS cobble FRKCOM
C
1635	DCPTR=-1			! if got a junction ...
	TXTPTR=-2			! lose commands in hand
	CODPOS=0
	N=4
	GO TO 700			! dummy up an 'OKK' 
C
C PPX - Print Pixels
1640	IF (NUMINT.LE.0) INTAR(1)=0	! PPX
	IF (NUMINT.GT.1) GO TO 1641
	INTAR(2)=INTAR(1)		! PPX i
	INTAR(1)=-INTAR(1)
1641	IF (NUMINT.GT.2) GO TO 1642
	INTAR(3)=INTAR(1)		! PPX i j
	INTAR(4)=INTAR(2)
	GO TO 1645
1642	IF (NUMINT.GT.3) GO TO 1645
	INTAR(4)=INTAR(3)		! PPX i j k
	INTAR(3)=-INTAR(3)
1645	CALL XYPRT(INTAR(1),INTAR(2),INTAR(3),INTAR(4))
	GO TO 140
C
C ......................................................................
C
C DIGitise - SCAn, ANAlyse, (SMooTh), COMpact, LISt
C
1660	SEQ=.TRUE.
	CUT=.FALSE.
	GO TO 1700
C
C CUTler - SCAn, FORk, (SMooTh), COMpact, LISt (unless ELF small ftr).
C
1680	IF (ELF.AND.(EC.EQ.5)) THEN	! special case if ELF small ftr
	   DCPTR=-1			! lose commands in hand
	   TXTPTR=-2
	   CODPOS=0
	   N=28				! dummy up an 'ESF' 
	   GO TO 700
	ENDIF
	SEQ=.TRUE.
	CUT=.TRUE.
C
C Do a SCAn
C
1700	IF (.NOT.HADLDI) GO TO 140
C
**	IF AREA
	IF (EC.NE.5) GO TO 1740		! jump if not small feature
	ARESQX=MAX0(1,INTARG)		! area scanned is ARESQX*ARESQY
	ARESQY=ARESQX
	NOMAP=.TRUE.			! nice and patchable !!
	CALL PARIO(4,PTYPE)		! regenerate scanner parameters
	NXTID(X)=0
	NXTID(Y)=IWID*WAR*CRX*ARESQX	! width of area scanned
C
C have we already scanned once for this stint in LINK??
	IF (AREDNE) GO TO 1720		! yup - so leave NEXT alone
	AREDNE=.TRUE.
	NEXT(Y)=NEXT(Y) - NXTID(Y)/2.0
1720	ENCARE=ARESCA(NEXT(X),NEXT(Y),ARESQX,ARESQY,NOMAP,.FALSE.)
	IWID=IWID*ARESQX
	IDIR=0
**	ENDC
C
1740	CALL DISMOD(0)
	RSEOFF(X)=0
	RSEOFF(Y)=0
	ID(X)=NXTID(X)
	ID(Y)=NXTID(Y)
	START(X)=NEXT(X)
	START(Y)=NEXT(Y)
C
	IF (ID(X).EQ.0.AND.ID(Y).EQ.0) GO TO 2750
	IF (NMPIFF+NMP(1) .GT. 0) GO TO 1760
	SECID(X)=-ID(X)
	SECID(Y)=-ID(Y)
1760	CALL MOVTO(START(X),START(Y))
	IF (NXTDIR .LT. 0) GO TO 1780
	IDIR=NXTDIR
	IU=2 - IDIR
	IV=1 + IDIR
	GO TO 1800
1780	CALL SETDIR(ID,IDIR,IU,IV)
C
1800	CONTINUE
**	IF AREA
	IF (EC .NE. 5) CALL SCANBY(ID(X),ID(Y),1)
**	IFF
	CALL SCANBY(ID(X),ID(Y),1)
**	ENDC
C
	NEGOT=-NEOLD
C
**	IF AREA
	GROWN=EC.EQ.5
	MERGED=EC.EQ.5
	LISTED=EC.EQ.5
**	IFF
	GROWN=.FALSE.
	MERGED =.FALSE.
	LISTED=.FALSE.
**	ENDC
	SCNND=.TRUE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
C
C rough check for closure
	IF (OPEN) GO TO 1840
	R=(SEC(X)-START(X))**2+(SEC(Y)-START(Y))**2
C
**	IF AREA
	IF (EC .NE. 5) GO TO 1820
	NEAR=R.LT.(S(1)+IDSIZE+IWID*CR(1)*WAR)**2
	GO TO 1840
**	ENDC
1820	NEAR=R.LT.(S(1)+IDSIZE+IWID*CR(IV)*WAR)**2
C
1840	CALL SCSET(0)
	IF (.NOT.SEQ) GO TO 140
	IF (CUT) GO TO 2020		! on to next item in sequence
	GO TO 1870
C
C RASter ('whole screen' area scan - output dumped to disk).
1850	CONTINUE
**	IF AREA
	IF (.NOT.HADLDI) GO TO 120
	CALL PARIO(4,PTYPE)		! regenerate scanner parameters
	CALL DISMOD(0)
	CALL CHSIZE(400.0,400.0,0.0)
	CALL CSWT(MAX(CPMEAS(1,3),CPMEAS(1,4)),
     &		  MAX(CPMEAS(2,1),CPMEAS(2,4)))
	IF (GETPT(XTRH,YTRH,' Upper right')) GO TO 1859
	CALL CSWT(MIN(CPMEAS(1,1),CPMEAS(1,2)),
     &		  MIN(CPMEAS(2,2),CPMEAS(2,3)))
	IF (GETPT(XBLH,YBLH,' Lower left')) GO TO 1859
	CALL DISMOD(0)
	OPEN (UNIT=1,NAME='LSL$DB:DATABASE.LAA',FORM='UNFORMATTED',
     &	      STATUS='NEW',CARRIAGECONTROL='NONE',
     &	      IOSTAT=I,ERR=1852)
	WRITE (1,IOSTAT=I,ERR=1853) CFT	   ! output cubic coeffs ...
	WRITE (1,IOSTAT=I,ERR=1853) CPMEAS ! corner points ...
	WRITE (1,IOSTAT=I,ERR=1853) IPIT/2 ! and half the pitch
	GO TO 1855
C
1852	CALL WRITEF('Error %N opening LSL$DB:DATABASE.LAA',I)
	GO TO 1857
1853	CALL WRITEF('Error %N writing to LSL$DB:DATABASE.LAA',I)
	GO TO 1858
C
1855	CENX=(XTRH + XBLH)/2.0
	CENY=YBLH
	SCBLSZ=((2.0*(FLOAT(IWID)*WAR*CRX/2.0)/FLOAT(IPIT) + 1) - 4)*
     &	       FLOAT(IPIT)		! scan block size (honest !!)
	ARESQX=NINT((XTRH - XBLH)/SCBLSZ) + 1
	ARESQY=NINT((YTRH - YBLH)/SCBLSZ) + 1
	ENCARE=ARESCA(CENX,CENY,ARESQX,ARESQY,.TRUE.,.TRUE.)
	IF (ENCARE.LT.0) GO TO 1858
C
	CALL WRITEF('%CArea scan completed%C',7,7)
	CLOSE (UNIT=1)
1857	CALL DISMOD(0)
	CALL SCSET(0)
	GO TO 120
C
1858	CLOSE (UNIT=1,DISPOSE='DELETE')
1859	CALL WRITEF('Abandoned')
	GO TO 1857
**	IFF
	CALL WRITEF('Not implemented yet')
	GO TO 140
**	ENDC
C
C apply 'FORk' type chain growing
C
2020	IF (.NOT.SCNND) GO TO 420
	CALL SETCHN
C
**	IF AREA
	IF (EC .NE. 5) GO TO 2040	! only for small features
	CALL CUTARE(2,1,HOLE,RIPPLE,ENCARE)
	GO TO 2060
**	ENDC
2040	CALL CUTLER(IU,IV,HOLE,RIPPLE)
C
2060	PACTED=.FALSE.
	LISTED=.FALSE.
	CHNSEL=0
	LSTSEL=0
	GROWN =.TRUE.
	FORKED=.TRUE.
	JOINTD=.FALSE.
	IF (SEQ) GO TO 1880
	GO TO 200
C
C GROw alias REGrow (historical)
C
1860	CALL SETCHN
	IF (.NOT.SCNND) GO TO 420
	CALL GROW(IU,IV)
	SEQ=.FALSE.			! GROw superseded by ANAlyse
	GO TO 1875
C
C ANAlyse the results of our scan
C
1870	IF (.NOT.SCNND) GO TO 420
	CALL ANALYZ
	IF (.NOT.JINHIB) GO TO 1872	! junction spotting inhibited ?
	IF (.NOT.JNCING) GO TO 1871	! is it actually disabled ?
	JINHIB=.FALSE.			! no - we've scanned once
	GO TO 1872
1871	JNCING=JINHIB			! yes - show we've done a scan
1872	IF (ANLYZD.GE.0) GO TO 1875
	N=7				! failed - enter HELP mode
	CHNSEL=0
	LSTSEL=0
	GO TO 700
C
1875	PACTED=.FALSE.			! success
	LISTED=.FALSE.
	FORKED=.FALSE.
	JOINTD=.FALSE.
	MERGED=.FALSE.
	CHNSEL=0
	LSTSEL=0
	GROWN =.TRUE.
	IF (.NOT.SEQ) GO TO 200
	IF (.NOT.SMOING) GO TO 1900
C
C SMT - smooth all the chains
C
1880	IF (.NOT.GROWN) GO TO 420
	CALL SMOOTH
	IF (.NOT.SEQ) GO TO 200
C
C COMpact all the chains
C
1900	IF (.NOT.GROWN) GO TO 420
	MAXSUP=S(1)*0.7071/IPIT		! max number of pnts to suppress
	IF (MAXSUP.EQ.0) MAXSUP=32767
	MAXSUP=MIN(MAXSUP,INT(CRUDIS/IPIT)) ! use CRUDIS if available
	MINSUP=LIMIT(14)
	DO 1920 I=1,MAXCHN
	  CALL CMPCT(I,ETA,IU,IV,MAXSUP,MINSUP)
1920	CONTINUE
	PACTED=.TRUE.			! 'cos we've done it
	LISTED=.FALSE.			! 'cos we've messed this up now
	IF (.NOT.SEQ) GO TO 200
C
C LIS - convert chains to lists
C
1940	IF (.NOT.GROWN) GO TO 420
	CALL CHNLST
	LISTED=.TRUE.
	GO TO 140
C
C ......................................................................
C
C APPend this bit to the MP1 points
C
1960	IF (CHNSEL.NE.0) GO TO 1965
C
C ... nothing in hand - moan, unless ending feature.
	IF (INTARG.NE.0) GO TO 140
	GO TO 420			! "out of context" moan
1965	IF (.NOT.LISTED) GO TO 420
C
C ... if ending closed feature, don't bother appending.
	IF (INTARG.NE.0.AND.CLOSED) GO TO 140
C
C ... if junction in hand & ending feature, drop arm but keep jnctn pnt.
	IF (.NOT.(JNCING.OR.JINHIB)) GO TO 1970
	IF (INTARG.NE.0.AND.SEGJUN.GT.0) SEGLEN=1
C
C ... if junction arm prediction chain in hand and not ending feature,
C ... don't do anything yet (next trip through ASSESS will cause us to
C ... predict and scan for the arm).
	IF (CONNCT(4,CHNSEL).NE.4) GO TO 1970	! prediction chain ?
	IF (LSTSEL.NE.1) GO TO 1970		! just had a junction ?
	IF (CONNCT(4,1).NE.5) GO TO 1970
	IF (INTARG.EQ.0) GO TO 140		! nothing to do ...
	CHNSEL=1				! unless ending feature
	LSTSEL=0
	SEGLEN=0
C
1970	FORCED=0
	IF (VEXING.AND.INTARG.NE.0) FORCED=1	! finish up vertex ext.
C
C append TRKSEG to /MPEP/, checking for closure if NEAR and NOT SECOND.
	IF (APPSEG(NEAR.AND..NOT.SECOND,OUTPUT,FORCED,CLOSED)) GOTO 2105
C
1980	I=1					! come here from LOOP
	IF (OUTPUT) I=FNUM(OVRNUM)
	IF (CLOSED) GO TO 2000
	CALL WRITEF('Feature %N is full%C',I,7)
	GO TO 2100
2000	IF (BRIEF) THEN
	   CALL TXWT(EXPBUF,EXPAND('%C%C',7,7))	! just ring the bell
	ELSE
	   CALL WRITEF('Feature %N closed%C',I,7)
	ENDIF
2100	FAST=.FALSE.
	INDEX(1)=0
C
2105	LSTSEL=CHNSEL
	IF (CHNSEL.GT.0) LSTWAY=CONNCT(3,CHNSEL)
	CHNSEL=0
	ASSED=.FALSE.
	JUMPED=.FALSE.
	IF (CONNCT(4,LSTSEL).NE.5) GO TO 140	! just appended jnctn ?
	CALL NEWVEC(1,NXTDIR)			! yes - set scan directn
	CALL SETDIR(NXTID,IDIR,IU,IV)
	ID(IU)=IDSIZE				! but retain square scan
	ID(IV)=0
	NEGOT=0					! prevent enc drawing
	GO TO 140
C
C LOOp the feature in hand
C
2280	IF (CLOSED) GO TO 1980
	CALL BUNCH(SEC(X),SEC(Y),1)
	CLOSED=.TRUE.
	GO TO 1980
C
C TSF -	 test for small feature, two sorts:
C
2080	IF (ELF) THEN			! edge mode small feature
	   IF (.NOT.GROWN) GO TO 420
	   CALL EDGFTR(EPSLON,N)
	   NMP(1)=0
	   FTRSEL=0
	   IF (N.EQ.0) GO TO 140	! found anything ?
	   CALL EDGSMF(NXTCHN(N))	! use NXTCHN as workspace
	   CALL RFSCAN(NXTCHN(1),-N,NXTID(X)/2)	! show ftrs in refresh
	   MODPIC=.TRUE.		! don't let LNKDRW mess it up
	   IF (N.GT.1) GO TO 140	! make him choose if several ...
	   GO TO 2170			! else dummy up an NXE
	ELSE				! line mode small feature
	   IF (.NOT.FORKED) GO TO 420
	   IF (SMLFTR(START(1),IU,IV)) GO TO 2120
**	UNLESS	AREA
	   NEXT(IU)=START(IU) + ID(IU)/2	! flip the scan
	   NEXT(IV)=START(IV) - ID(IU)/2
	   NXTID(IU)=ID(IV)
	   NXTID(IV)=ID(IU)
**	ENDC
	   NXTDIR=-1
	   FRKCOM=SMFCOM		! try again or ...
	   IF (IDIR.EQ.0) GO TO 2160	! call operator ("DUN" macro)
	   GO TO 140
	ENDIF
C
C it is one
2120	IF (.NOT.BRIEF) CALL WRITEF('Small feature %N%C',FNUM(OVRNUM),7)
2140	CLOSED=.TRUE.
	SEC(X)=MP1(X,1)
	SEC(Y)=MP1(Y,1)
	SECTYP=MPTYPE(1)
C
2160	FRKCOM =10	! "DUN" => done a feature
	GO TO 140
C
C NXE -	fetch next edge mode feature from list
C
2170	IF (FTRSEL.NE.0) FTRSEL=NXTFTR(FTRSEL)
	IF (FTRSEL.EQ.0) FTRSEL=BSTFTR
	CALL EDGSEL(FTRSEL)
	IF (FTRSEL.NE.0) GO TO 2140		! establish feature
	GO TO 140
C
C DROP chain selection
C
2180	CHNSEL=0	! easy
	NOTAPP=.FALSE.
	GO TO 140
C
C select FIRST chain
C
2200	CHNSEL=0
C
C select NEXT best
C
2220	IF (.NOT. ASSED) GO TO 420
	IF (CHNSEL .NE. 0) CHNSEL=NXTBST(CHNSEL)
	IF (CHNSEL .EQ. 0) CHNSEL=BSTCON
	CALL NXTSEG				! to set up /TRKSEG/
	NOTAPP=TSTCON(CHNSEL)			! check appendability
	GO TO 140
C
C FUMble about for a line, leaving the answers in CONNCT and FRKCOM.
C
2240	CALL FUMBLE
	GO TO 200
C
C RETreat back from difficulty, in order to look at it better,
C predict a scan to do this.
C
2260	CALL WRITEF('RETreat no longer available%C',7)
CCC	CALL RTREAT(START(1),IDSIZE,NEXT(1),NXTID(1))
CCC	NXTDIR=-1
	GO TO 180
C
C SQUare the feature in hand
C
2300	IF (SQUTOL.LE.0.0) GO TO 140
	M=NMP(1)
	IF (M+NMPIFF.GT.MAXMP) GO TO 2320
	IF (M.LE.3) GO TO 2340
	CALL SQUARE(MP1,NMP(1),SQUTOL,TRKWID,CLOSED)
	SQARED=.TRUE.
	CALL WRITEF('%N points reduced to %N',M,NMP(1))
	GO TO 140
2320	CALL WRITEF('Too big to square (%N)%C',M+NMPIFF,7)
	GO TO 140
2340	CALL WRITEF('Too small to square (%N)%C',M,7)
	GO TO 140
C
C END of feature
C
2360	IF (NMP(1).EQ.0) GO TO 2420
	IF (ELF.AND..NOT.(OPEN.OR.CLOSED))
     &	   CALL WRITEF('WARNING - Feature not closed%C',7)
	RC=0
	IF (SECOND) RC=8			! reorder feature flag
	IF (.NOT.CLOSED) GO TO 2380
	IF (NJUNC.EQ.0) RC=RC + 1		! closed feature flag
	IF (SQARED) GO TO 2380
	IF (SECTYP.LE.0) GO TO 2361
	IF (MPTYPE(NMP(1)).GT.0) GO TO 2380	! both ends are jnctns
	GO TO 2370				! first pnt is junction
2361	IF (MPTYPE(NMP(1)).GT.0) GO TO 2362	! last pnt is junction
	IF (ONSIDE()) NMP(1)=NMP(1) - 1	! lose last pt (if not a vertex)
2362	IF (NMPIFF.GT.0) GO TO 2365	! see if 1st pnt already output
	MP1(X,1)=MP1(X,NMP(1))		! drag 1st pnt back to 'last'
	MP1(Y,1)=MP1(Y,NMP(1))
	MPTYPE(1)=MPTYPE(NMP(1))
	IF (MPTYPE(1).LE.0) GO TO 2368
	DO 2363 I=1,MAXBRA		! deal with junction data
	   MPJANG(I,1)=MPJANG(I,NMP(1))
	   SECJAN(I)=MPJANG(I,1)	! save new 1st point info
2363	CONTINUE
	MPIARM(1)=0
	MPOARM(1)=MPOARM(NMP(1))
	SECJOA=MPOARM(1)
	MPOARM(NMP(1))=0
	GO TO 2368
C
C ... first point already output to IFF file.
2365	IF (.NOT.OUTPUT) GO TO 2366
	CALL IFFPKE(I,N,SECPOS)
	D(X)=MP1(X,NMP(1))
	D(Y)=MP1(Y,NMP(1))
	CALL TRXUSE(D(X),D(Y),FCOEFF)
	CALL EIHWR(D,2,1)		! drag 1st point back to 'last'
	IF (WIZARD) CALL WRITEF('ST entry patched')
2366	IF (MPTYPE(NMP(1)).LE.0) GO TO 2368
	CALL WRITEF('%CLast point is a junction but first is not%C',7,7)
	GO TO 2369
C
2368	SECTYP=MPTYPE(NMP(1))		! remember new first point
2369	SEC(X)=MP1(X,NMP(1))
	SEC(Y)=MP1(Y,NMP(1))
	GO TO 2380
C
C pull last point back to start (junction) point
2370	CALL BUNCH(SEC(X),SEC(Y),-2)	! roll back to junction
	IF (MPTYPE(NMP(1)).GT.0) GO TO 2380
	MPTYPE(NMP(1))=SECTYP
	DO 2375 I=1,MAXBRA
	   MPJANG(I,NMP(1))=SECJAN(I)
2375	CONTINUE
	MPIARM(NMP(1))=0
	MPOARM(NMP(1))=0
C
C if last point is a junction, leave cursor on it.
2380	IF (MPTYPE(NMP(1)).LE.0) GO TO 2390	
	NEXT(X)=MP1(X,NMP(1))
	NEXT(Y)=MP1(Y,NMP(1))
	CALL CSWT(NEXT(X),NEXT(Y))
C
C output the points.
2390	CALL OUTMP1(0,THKNSS,PENUP,OUTPUT)
	GO TO (200,200,2400,100,2400),EC
C
C now go other way.
2400	IF (SECOND) GO TO 2840
	IF (CLOSED .OR. .NOT.USEFND) GO TO 2840
	SECOND=.TRUE.
	CALL CSWT(SEC(X),SEC(Y))
	NXTID(X)=SECID(X)
	NXTID(Y)=SECID(Y)
	NMP(1)=0
	GO TO 120
C
C zero length feature.
2420	IF (SECOND) GO TO 2840			! allow null second half
	CALL WRITEF('Nothing to accept')
	GO TO 200
C
C JUMp to new bit of line
C
2440	JUMPED=.TRUE.
	IF (JINHIB) JNCING=JINHIB
	GO TO 200
C
C IFC -	IFF Check. Used after FUM or ASS, examines the data file and
C	rejects any choices that lie on a previously digitised feature.
C
2460	IF (.NOT.ASSED) GO TO 420
CCC	CALL CHKOLD(MPNEAR**2, 0)
	GO TO 2180			! DROp chain selection
C
C ASSess the situation
C
2480	IF (.NOT.LISTED) GO TO 420
	CALL ASSESS
	ASSED=.TRUE.
	GO TO 2180			! go and drop chain selection
C
C AUTo & STEp - decide the action and take it ...
C
2500	FAST=.TRUE.			! ('AUT' => fast)
2520	AUTCOM=FRKCOM			! ('STE' implies nothing)
	IF (AUTCOM.GT.0) GO TO 2660	! USEFRK's set a command number
	AUTCOM=0
	IF (SCAN) GO TO 2640		! new scan needed ?
	IF (NOTAPP) GO TO 2540		! can't append this connection ?
	IF (CNFSED) GO TO 2600		! confused ?
	IF (.NOT.LOST) GO TO 2580	! OK ?
	IF (.NOT.VERY) GO TO 2620	! no, we're lost - how badly ?
CCC	IF ((JNCING.OR.JINHIB).AND..NOT.MERGED.AND.ANLYZD.LT.0)
CCC     &     GO TO 2560		! very lost, try a junction scan
C
	AUTCOM=AUTCOM + 1		! (7) very lost
2540	AUTCOM=AUTCOM + 1		! (6) NOTAPP connection
2560	AUTCOM=AUTCOM + 1		! (5) junction scan needed
2580	AUTCOM=AUTCOM + 1		! (4) OK
2600	AUTCOM=AUTCOM + 1		! (3) confused
2620	AUTCOM=AUTCOM + 1		! (2) lost
2640	AUTCOM=AUTCOM + 1		! (1) new scan needed
	IF (NOTAPP.GT.0) AUTCOM=5	! found a junction (override)
2660	N=AUTCOM
	GO TO 700			! call macro command AUTCOM
C
C SLOW command
2680	FAST=.FALSE.
	GO TO 2710
C
C FAST command
2700	FAST=.TRUE.
2710	ANLYZD=-1
	GO TO 200
C
C PREDICT new scan vector's position
C
2720	NLOST=1
C
2740	JUMPED=.FALSE.
	MANUAL=.FALSE.
	IF (.NOT.NEWVEC(NLOST,NXTDIR)) GO TO 140
C
2750	CALL WRITEF('Bad prediction vector')
	GO TO 180
C
C POKE about to find the lost line
C
2760	IF (INTARG .NE. 0) NLOST=INTARG
	GO TO 2740
C
C ......................................................................
C
C EXITS
C
C ABOrt feature.
C
2780	RC=-1
	GO TO 2840
C
C Finished initialisation - close patch file etc.
2820	CALL IFFSYS(SAVLUN,4)
C
2840	RETURN
	END
