C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1994-04-27 12:31:30.000000000 +0100
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	LOGICAL FUNCTION PROCESS_I2NTF_COMMENT(IN_STR,IN_LEN)
C
***	IDENT	27AP94
***	MODULE	PROCESS_I2NTF_COMMENT
C
C Copyright LaserScan Ltd, Cambridge, England
C
C Author S Gupta 13-August-1991
C
C This reads specific data from comments generated by 12NTF:
C   "IFF file"  "Spheroid"  "Projection"  "Scale"  "Units"  "Height data"
C
CMOD	parses file name: the device and version are ommitted  SG  16-Aug-1991
CMOD	Fix problem where the spheroid is checked against the  ST  27-Apr-1994
C	MD2_SPH list with a 0 on the end due to v2.0 having
C       an additional character (%) on the end. Mod 1359.
C
C	.------------------{  PSEUDO CODE }---------------------.
C	| 							|
C	|   decipher the comment into a common block		|
C	|   setting appropriate flags				|
C	| 							|
C	|   (see structure chart part of documentation)		|
C	`-------------------------------------------------------'
C
	IMPLICIT NONE
C
	CHARACTER*81	IN_STR
	INTEGER		IN_LEN
C
	INCLUDE 'NTFDATA.CMN'
	INCLUDE 'LSLDATA.CMN'
	INCLUDE 'COMMANDS.CMN'
	INCLUDE 'LSL$CMNIFF:MD2DES.CMN'
	INCLUDE 'LSL$CMNIFF:MD2NAM.CMN'
C
	LOGICAL		MATCH_NAME
	LOGICAL		RDINT
	LOGICAL		RDREAL
	EXTERNAL	MD2DAT
C
C Workspace
C
	LOGICAL		OK				! Function return
	CHARACTER*80	KEY_STR, DEF_STR, DATA_STR
	INTEGER		KEY_LEN, DEF_LEN, DATA_LEN
	INTEGER		DATA_START
	INTEGER		MATCHED_INDEX
	LOGICAL		MATCH, FOUND_END
	CHARACTER	THIS_CHAR, PREV_CHAR
	INTEGER		LOOP
	LOGICAL		HAD_COLON, HAD_SEMI_COLON
C
C##############################################################################
C
	OK = .TRUE.
C
C..............................................................................
C the length of key-field in the comment fields are at most 11 characters long
C add in the length of the record_descriptor (2)
C
	OK = IN_LEN.GT.13
	IF (.NOT.OK) GOTO 999
C
C..............................................................................
C get the key-field
C
	KEY_STR = IN_STR(3:13)			!get the key field
	KEY_LEN   = 11				!default to 11 chars
C
C	.......................................................................
C	go from end of string backwards skipping blank spaces, adjust length
C
	DO WHILE ( (KEY_STR(KEY_LEN:KEY_LEN).EQ.' ').AND.(KEY_LEN.GE.1))
	  KEY_LEN = KEY_LEN -1
	END DO
C
C	.......................................................................
C	compare to the key-fields we recognise
C
	MATCH = .FALSE.						!no match yet
	LOOP = 0						!start at 0
C
	DO WHILE((.NOT.MATCH).AND.(LOOP.LT.NUM_CODES))
	  LOOP = LOOP +1					!next item
	  DEF_LEN   = I2NTF_CODE_LEN(LOOP)			!get length
	  DEF_STR = I2NTF_CODE_STR(LOOP)(1:DEF_LEN)		!get field
	  MATCH = KEY_STR(1:KEY_LEN).EQ.DEF_STR(1:DEF_LEN) 	!compare
	END DO
C
	OK = MATCH					! set return value
	IF (.NOT.OK) GOTO 999
	MATCHED_INDEX = LOOP
C
C.............................................................................
C the KEY_STR matches, get the data field start from after KEY_STR, 
C always starts at character position 19
C (leading spaces in projection are intentional)
C
	DATA_START = 19
	IF (VERSION.EQ.2.0) IN_LEN = IN_LEN - 1		! allow for 0% at end
C
C	......................................................................
C	work back from the end of record, and find last non_space character
C
	FOUND_END = .FALSE.
	LOOP = IN_LEN
	DO WHILE ( (.NOT.FOUND_END) .AND. (LOOP.GT.DATA_START))
	  LOOP = LOOP - 1
	  THIS_CHAR = IN_STR(LOOP:LOOP)
	  PREV_CHAR = IN_STR(LOOP-1:LOOP-1)
	  FOUND_END = (THIS_CHAR.NE.' ').AND.(PREV_CHAR.NE.' ')
	END DO
C
	OK = FOUND_END
	IF (.NOT.OK) GOTO 999
C
C	......................................................................
C	get the data field
C
	DATA_LEN = LOOP-DATA_START +1
	DATA_STR(1:DATA_LEN) = IN_STR( DATA_START:DATA_START+DATA_LEN)
C
C-----------------------------------------------------------------------------
C put the data field into a common block for later use.
C
C	........................................................................
C	with the file name ignore the device, extension and version
C	read between the first colon and upto first dot
C
	IF     (MATCHED_INDEX.EQ.1) THEN		! file name
C
C	  ......................................................................
C	  look for the first colon
C
	  HAD_COLON = .FALSE.
	  LOOP = DATA_START
C
	  DO WHILE ( (.NOT.HAD_COLON).AND.(LOOP.LT.IN_LEN) )
	    HAD_COLON = ( IN_STR(LOOP:LOOP) .EQ. ':' )	!compare
	    LOOP = LOOP+1				!set to next character
	  END DO
C
	  IF (HAD_COLON) DATA_START = LOOP		!remember if success
C
C	  ......................................................................
C	  look for the dot
C
	  HAD_SEMI_COLON = .FALSE.
	  LOOP = DATA_START
C
	  DO WHILE ( (.NOT.HAD_SEMI_COLON).AND.(LOOP.LT.IN_LEN) )
	    LOOP = LOOP+1				!set to next character
	    HAD_SEMI_COLON = ( IN_STR(LOOP:LOOP) .EQ. ';' )	!compare
	  END DO
C
	  IF (HAD_SEMI_COLON) DATA_LEN = LOOP-DATA_START
C
C	  ......................................................................
C	  save the new data, doesnt matter if not changed
C
	  OK = DATA_LEN.GE.1
	  IF (OK) THEN
	    LSL$_FILE_LEN = DATA_LEN
	    LSL$_FILE_NAME(1:DATA_LEN) = IN_STR( DATA_START:DATA_START+DATA_LEN)
	    LSL$_HAD_FNAME = LSL$_FILE_LEN.GE.1		!set flag
	  ENDIF	
C
C	........................................................................
C
	ELSEIF (MATCHED_INDEX.EQ.2) THEN		! Spheroid
	  OK = MATCH_NAME(	DATA_STR , DATA_LEN,
     &				MD2_NOSPH, MD2_SPHCD, MD2_SPH,
     &				LSL$_SPHER)
	  LSL$_HAD_SPHER = OK
C
C	........................................................................
C
	ELSEIF (MATCHED_INDEX.EQ.3) THEN		! Projection
	  OK = MATCH_NAME(	DATA_STR, DATA_LEN,
     &				MD2_NOPRJ, MD2_PRJCD, MD2_PRJ,
     &				LSL$_PROJ)
	  LSL$_HAD_PROJ = OK
C
C	........................................................................
C
	ELSEIF (MATCHED_INDEX.EQ.4) THEN		! Scale
	  CALL SETAUX( %REF(DATA_STR) , DATA_LEN)
	  OK = .NOT.RDREAL(LSL$_SCALE)
	  LSL$_HAD_SCALE = OK
C
C	........................................................................
C
	ELSEIF (MATCHED_INDEX.EQ.5) THEN		! Units
	  OK = MATCH_NAME(	DATA_STR, DATA_LEN,
     &				MD2_NOUNT, MD2_UNTCD, MD2_UNT,
     &				LSL$_UNITS)
	  LSL$_HAD_UNITS= OK
C
C	........................................................................
C
	ELSEIF (MATCHED_INDEX.EQ.6) THEN		! Height units
	  OK = MATCH_NAME(	DATA_STR, DATA_LEN,
     &				MD2_NOUNT, MD2_UNTCD, MD2_UNT,
     &			 	LSL$_HEIGHT)
	  LSL$_HAD_HEIGHT = OK
C
C	........................................................................
C
	ELSE
	  CALL WRITEF('%%NTF2I-E-SOFTWARE, Error reading comment lines')
	  CALL WRITEF('-NTF2I-W-MISC, map descriptor may be incorrect')
	  CALL WRITEF('-NTF2I-I-MISC, contact Laser Scan')
	ENDIF
	
C
C##############################################################################
C
999	PROCESS_I2NTF_COMMENT = OK
	RETURN
	END
