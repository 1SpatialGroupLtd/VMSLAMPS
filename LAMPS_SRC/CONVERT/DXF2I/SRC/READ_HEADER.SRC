C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1993-06-15 11:52:54.000000000 +0100
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	LOGICAL*4 FUNCTION READ_HEADER()
C
***	MODULE READ_HEADER
***	IDENT 15JN93
C
C ©Copyright Laser Scan Ltd, Cambridge, England.
C
C Author  :  A.T. Timms					 2 Nov 1987
C Modified:  P. Pan					13 Mar 1990
C            P. Pan					 7 Jun 1990
C
CMOD1004     J. Barber					 7 Jun 1991
C	     Use $EXTMIN/$EXTMAX for Range (not $LIMMIN/$LIMMAX as well)
C	     Add layer 0 bounding area feature to contain certain 
C	     header variables as AC entries (if requested with /HEADER)
C
CMOD1080     J. Barber					29 Jan 1992
C	     Set MD2 variables to 0 explicitly, and scale to 1
C
CMOD1103     J. Barber					23 Apr 1992
C	     Use $CECOLOR instead $CECOLOUR
C
CMOD1156     J. Barber					15 Oct 1992
C	     Create /ABSOLUTE qualifier to use $EXTMIN in Range(1)
C	     and Range(3) for the MD2LOC entry, to be subtracted from
C	     any coordinates. Can be used to preserve accuracy in the
C	     translation.
C	     Can be recovered in I2DXF with the /ABSOLUTE qualifier.
C
CMOD1234     J. Barber					 7 Jun 1993
C	     Set HAD_RANGE if DXF header entries read and IFF entries
C	     written
C
C ******* Add $FLATLAND 0/1 to header AC's **************
C
C Function to read DXF file HEADER section
C
	IMPLICIT NONE
C
	INCLUDE  'LSL$CMNLSL:READSTR.PAR'
	INCLUDE  'LSL$CMNIFF:IFFHAN.CMN'
	INCLUDE  'LSL$CMNIFF:MHDEF.CMN'
C	INCLUDE  'LSL$CMNIFF:MAPDES.CMN'
	INCLUDE  'LSL$CMNIFF:MD2DES.CMN'
	INCLUDE  'LSL$CMNDXFPAR:LOOKUP.CMN'
	INCLUDE  'HERE:DXF2I.CMN'
	INCLUDE  'HERE:DXF2IMSG.PAR'
C
C Functions
	INTEGER		FLRLIN			! Read a line from file
	INTEGER		READSTR			! Get a string
	INTEGER		RDREAL			! Get a real
	INTEGER		RDINT			! Get an integer
C
C Workspace
	REAL		XY(4,4)			! Corner point array
	REAL		CFT(10,2)		! Cubic coefficients
	CHARACTER*255	STRING,CHAR		! Any old string
	INTEGER		II,III,JJ,JJJ		! Loop variables
	INTEGER		LEN			! String length
	INTEGER*2	COLTYP	   ! Colour organisation (by block or layer)
	INTEGER*2	FC(4)
	REAL		COORD(2,5)
C
C AC variable CHAR duplicates of CMN DEF_TEXT_HEIGHT,DEF_POINT_SIZE
C
	CHARACTER*255	TEXTSIZE,PDSIZE
	INTEGER		TEXTSIZE_LEN,PDSIZE_LEN
C
	CHARACTER*255	CECOLOR,CELTYPE
	LOGICAL		HAD_CECOLOR,HAD_CELTYPE
	INTEGER		CECOLOR_LEN,CELTYPE_LEN
C
C Header variables for AC's only
C
	CHARACTER*255	LUNITS,LUPREC,PDMODE
	INTEGER		LUNITS_LEN,LUPREC_LEN,PDMODE_LEN
	LOGICAL		HAD_LUNITS,HAD_LUPREC,HAD_PDMODE
C
	CHARACTER*255	TDCREATE,TDINDWG,TDUPDATE,TDUSRTIMER
	INTEGER		TDCREATE_LEN,TDINDWG_LEN
	INTEGER		TDUPDATE_LEN,TDUSRTIMER_LEN
	LOGICAL		HAD_TDCREATE,HAD_TDINDWG
	LOGICAL		HAD_TDUPDATE,HAD_TDUSRTIMER
C
	CHARACTER*255	UCSNAME
	INTEGER		UCSNAME_LEN
	LOGICAL		HAD_UCSNAME
C
	CHARACTER*255	UCSORG(3)
	INTEGER		UCSORG_LEN(3)
	LOGICAL		HAD_UCSORG
C
	CHARACTER*255	UCSXDIR(3)
	INTEGER		UCSXDIR_LEN(3)
	LOGICAL		HAD_UCSXDIR
C
	CHARACTER*255	UCSYDIR(3)
	INTEGER		UCSYDIR_LEN(3)
	LOGICAL		HAD_UCSYDIR
C
	BYTE		AC(255)
	INTEGER*2	ACLEN
	INTEGER		ACTYPE
C
        DATA CFT/0.0,1.0,10*0.0,1.0,7*0.0/
C
C.......................................................................
C
	IF (HAD_LOG) CALL LSL_PUTMSG(DXF2I__RDHDSC)
C
	BY_LAYER       = .FALSE.
	LTYPE_BY_LAYER = .FALSE.
C
	HAD_CECOLOR    = .FALSE.
	HAD_CELTYPE    = .FALSE.
	HAD_RANGE      = .FALSE.		! no header read yet
C
C Common block AC variables
	HAD_TEXT_HEIGHT = .FALSE.
	HAD_TEXT_STYLE  = .FALSE.
	HAD_POINT_SIZE  = .FALSE.
	HAD_LAYER_NAME  = .FALSE.
C
C Local AC variables
	HAD_LUNITS     = .FALSE.
	HAD_LUPREC     = .FALSE.
	HAD_PDMODE     = .FALSE.
	HAD_TDCREATE   = .FALSE.
	HAD_TDINDWG    = .FALSE.
	HAD_TDUPDATE   = .FALSE.
	HAD_TDUSRTIMER = .FALSE.
	HAD_UCSNAME    = .FALSE.
	HAD_UCSORG     = .FALSE.
	HAD_UCSXDIR    = .FALSE.
	HAD_UCSYDIR    = .FALSE.
C
C Get another line from the header
C
99	READ_HEADER = FLRLIN()
	IF (.NOT.READ_HEADER) GOTO 2001
C
	CALL BSLN
	NUMLIN = NUMLIN + 1
	LEN = READSTR(STRING,,ON_EOL)
	IF (LEN.EQ.0) GOTO 99 		! Account for valid null lines
C
C Delegate according to the contents of string
C
	IF (STRING(1:LEN).EQ.'ENDSEC') THEN
	   GOTO 1000
	ELSEIF (STRING(1:LEN).EQ.'0') THEN
	   GOTO 99
	ELSEIF (STRING(1:LEN).EQ.'2') THEN
	   GOTO 99
	ELSEIF (STRING(1:LEN).EQ.'9') THEN
	   GOTO 99
C
C Upper right drawing extent
C
	ELSEIF (STRING(1:LEN).EQ.'$EXTMAX') THEN
	   DO 60 II = 1,2
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      IF (RDREAL(RA(II*2))) THEN
	 	 READ_HEADER = DXF2I__UNACONT
		 GOTO 2001
	      ENDIF
60	   CONTINUE
C
C Upper right drawing limits
C
	ELSEIF (STRING(1:LEN).EQ.'$LIMMAX') THEN
	   DO 50 II = 1,2
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
C	      CALL BSLN
C	      IF (RDREAL(RA(II*2))) THEN
C	 	 READ_HEADER = DXF2I__UNACONT
C		 GOTO 2001
C	      ENDIF
50	   CONTINUE
C
C Lower left drawing extent
C
	ELSEIF (STRING(1:LEN).EQ.'$EXTMIN') THEN
	   DO 30 II = 1,2
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      IF (RDREAL(RA(II*2-1))) THEN
	 	 READ_HEADER = DXF2I__UNACONT
		 GOTO 2001
	      ENDIF
30	   CONTINUE
C
C Lower left drawing limits
C
	ELSEIF (STRING(1:LEN).EQ.'$LIMMIN') THEN
	   DO 40 II = 1,2
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
C	      CALL BSLN
C	      IF (RDREAL(RA(II*2-1))) THEN
C	 	 READ_HEADER = DXF2I__UNACONT
C		 GOTO 2001
C	      ENDIF
40	   CONTINUE
C
C Colour by block or layer?
C
	ELSEIF (STRING(1:LEN).EQ.'$CECOLOUR' .OR.
     &		STRING(1:LEN).EQ.'$CECOLOR') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   CECOLOR_LEN = READSTR(CECOLOR,,ON_EOL)
	   IF (CECOLOR_LEN.EQ.0) GOTO 99   ! Account for valid null lines
	   HAD_CECOLOR = .TRUE.
C
	   CALL BSLN
	   IF (RDINT(COLTYP)) THEN
	      READ_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   IF (COLTYP.EQ.256) BY_LAYER = .TRUE.
C
C LINETYPE by layer? (BYBLOCK not supported)
C
	ELSEIF (STRING(1:LEN).EQ.'$CELTYPE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   CELTYPE_LEN = READSTR(CELTYPE,,ON_EOL)
	   IF (CELTYPE_LEN.EQ.0) GOTO 99   ! Account for valid null lines
C
	   HAD_CELTYPE = .TRUE.
	   IF (CELTYPE(1:CELTYPE_LEN).EQ.'BYLAYER') LTYPE_BY_LAYER = .TRUE.
C
C Default layer name
C
	ELSEIF (STRING(1:LEN).EQ.'$CLAYER') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   DEF_LAYER_NAME_LEN = READSTR(DEF_LAYER_NAME,,ON_EOL)
	   IF (DEF_LAYER_NAME_LEN.EQ.0) GOTO 99	! Account for null lines
	   HAD_LAYER_NAME = .TRUE.
C
C Default text height
C
	ELSEIF (STRING(1:LEN).EQ.'$TEXTSIZE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   IF (RDREAL(DEF_TEXT_HEIGHT)) THEN
	      READ_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   HAD_TEXT_HEIGHT = .TRUE.
C
	   CALL BSLN
	   TEXTSIZE_LEN = READSTR(TEXTSIZE,,ON_EOL)
C
C Default text style
C
	ELSEIF (STRING(1:LEN).EQ.'$TEXTSTYLE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   DEF_TEXT_STYLEN = READSTR(DEF_TEXT_STYLE,,ON_EOL)
	   IF (DEF_TEXT_STYLEN.EQ.0) GOTO 99	! Account for null lines
	   HAD_TEXT_STYLE = .TRUE.
C
C Default point size
C
	ELSEIF (STRING(1:LEN).EQ.'$PDSIZE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   IF (RDREAL(DEF_POINT_SIZE)) THEN
	      READ_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   HAD_POINT_SIZE = .TRUE.
C
	   CALL BSLN
	   PDSIZE_LEN = READSTR(PDSIZE,,ON_EOL)
C
	ELSEIF (STRING(1:LEN).EQ.'$PDMODE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   PDMODE_LEN = READSTR(PDMODE,,ON_EOL)
	   IF (PDMODE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_PDMODE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSNAME') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   UCSNAME_LEN = READSTR(UCSNAME,,ON_EOL)
	   IF (UCSNAME_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_UCSNAME = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSORG') THEN
	   DO 3 II = 1,3
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSORG_LEN(II) = READSTR(UCSORG(II),,ON_EOL)
3	   CONTINUE
C
	   HAD_UCSORG = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSXDIR') THEN
	   DO 2 II = 1,3
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSXDIR_LEN(II) = READSTR(UCSXDIR(II),,ON_EOL)
2	   CONTINUE
C
	   HAD_UCSXDIR = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSYDIR') THEN
	   DO 1 II = 1,3
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      READ_HEADER = FLRLIN()
	      IF (.NOT.READ_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSYDIR_LEN(II) = READSTR(UCSYDIR(II),,ON_EOL)
1	   CONTINUE
C
	   HAD_UCSYDIR = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$LUNITS') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   LUNITS_LEN = READSTR(LUNITS,,ON_EOL)
	   IF (LUNITS_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_LUNITS = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$LUPREC') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   LUPREC_LEN = READSTR(LUPREC,,ON_EOL)
	   IF (LUPREC_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_LUPREC = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDCREATE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDCREATE_LEN = READSTR(TDCREATE,,ON_EOL)
	   IF (TDCREATE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDCREATE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDINDWG') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDINDWG_LEN = READSTR(TDINDWG,,ON_EOL)
	   IF (TDINDWG_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDINDWG = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDUPDATE') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDUPDATE_LEN = READSTR(TDUPDATE,,ON_EOL)
	   IF (TDUPDATE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDUPDATE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDUSRTIMER') THEN
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   READ_HEADER = FLRLIN()
	   IF (.NOT.READ_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDUSRTIMER_LEN = READSTR(TDUSRTIMER,,ON_EOL)
	   IF (TDUSRTIMER_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDUSRTIMER = .TRUE.
 	ENDIF
C
	GOTO 99
C
C.......................................................................
C Write out IFF headers to IFF file
C
1000	CONTINUE
	CALL IFFSEL(IFFLUN)
	CALL FLWSEL(IFFLUN)
C
C Use SW origin for MD2 MD2LOC if had /ABSOLUTE qualifier
C
	IF (HAD_ABS) THEN
	  MD2LOC(1) = RA(1)		! = $EXTMIN
	  MD2LOC(2) = RA(3)		! = $EXTMIN
C
	  RA(1) = 0.0			! = RA(1) - MD2LOC(1)
	  RA(2) = RA(2) - MD2LOC(1)
	  RA(3) = 0.0 			! = RA(3) - MD2LOC(2)
	  RA(4) = RA(4) - MD2LOC(2)
	ELSE
	  MD2LOC(1) = 0
	  MD2LOC(2) = 0
	ENDIF
C
C Set scale, offset etc.
C
	MATV2  = 2
	MD2SCL = 1
	MD2PRJ = 0
	MD2UNT = 0
	MD2SPH = 0
C
	LPOSRA = LPOSE		! remember where the RAnge is
	CALL IFFRA(RA)
	HAD_RANGE    = .TRUE.
	RANGE_UPDATE = .FALSE.
	CALL IFFHI
 	CALL IFFMH(MHARR,MHLEN)	! map header
C
C	CALL IFFMD(MDARR,MDLEN)			! map descriptor
C
	CALL IFFMD(MD2ARR,MD2LEN)		! map descriptor
	CALL IFFNS(' File created by DXF2I ')
	CALL IFFCC(CFT)
C
C Control points - set array elements
C
	XY(1,1) = RA(1)
	XY(2,1) = RA(4)
	XY(1,2) = RA(1)
	XY(2,2) = RA(3)
	XY(1,3) = RA(2)
	XY(2,3) = RA(3)
	XY(1,4) = RA(2)
        XY(2,4) = RA(4)
C
C Loop to copy these into the rest of the array elements
C
	DO 1100 III = 1,4
	   DO 1005 JJJ = 1,2
		XY(JJJ+2,III) = XY(JJJ,III) 
1005	   CONTINUE
1100	CONTINUE
C
	CALL IFFCP(XY)
C
C reports
C
        IF (HAD_LOG) CALL LSL_PUTMSG
     &			(DXF2I__MAPEXTENT,RA(1),RA(2),RA(3),RA(4))
C
C Warn if colour or line type by layer
C
	IF (BY_LAYER) THEN
	   CALL WRITEF
	   CALL LSL_PUTMSG(DXF2I__COLBYLAY)
	   CALL WRITEF
	ENDIF
	IF (LTYPE_BY_LAYER) THEN
	   CALL LSL_PUTMSG(DXF2I__LTYPEBYLAY)
	   CALL WRITEF
	ENDIF
C
C initialise the feature counter
C
	PROCESS_TOTAL = 0
        PROCESS_SUCC  = 0
        PROCESS_FAIL  = 0
C
C set the default layer number to 0 and flag no layer open
C
	LSTIFFLAY = 0
	IN_LAYER = .FALSE.
C
	NF = 0
	DO 5 II = 1,4
	   FC(II) = 0
5	CONTINUE
C
C Create border feature for header AC's
C
	IF (.NOT.HAD_HDR) GOTO 2000
C
	IF (HAD_LOG) CALL LSL_PUTMSG(DXF2I__WRTHDRFTR)
C
	LSTIFFLAY = 0
	LPOSNO = LPOSE
	CALL IFFNO(LSTIFFLAY,0,0)
	IN_LAYER = .TRUE.
C
	ACTYPE = DEF_HEADER_AC
	NF = NF + 1
	CALL IFFNF(NF,NF)
	CALL IFFFS(FC)
C
C Output AC's
C
	IF (HAD_TEXT_HEIGHT) THEN
	   CHAR = '$TEXTSIZE '
	   LEN  = 10
	   DO 106 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
106	   CONTINUE
C
	   DO 6 II = 1,TEXTSIZE_LEN
	      AC(LEN+II) = ICHAR(TEXTSIZE(II:II))
6	   CONTINUE
C
	   ACLEN = LEN + TEXTSIZE_LEN
	   CALL IFFAC(ACTYPE,TEXTSIZE_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_TEXT_STYLE) THEN
	   CHAR = '$TEXTSTYLE '
	   LEN  = 11
	   DO 107 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
107	   CONTINUE
C
	   DO 7 II = 1,DEF_TEXT_STYLEN
	      AC(LEN+II) = ICHAR(DEF_TEXT_STYLE(II:II))
7	   CONTINUE
C
	   ACLEN = LEN + DEF_TEXT_STYLEN
	   CALL IFFAC(ACTYPE,DEF_TEXT_STYLEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_POINT_SIZE) THEN
	   CHAR = '$PDSIZE '
	   LEN  = 8
	   DO 108 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
108	   CONTINUE
C
	   DO 8 II = 1,PDSIZE_LEN
	      AC(LEN+II) = ICHAR(PDSIZE(II:II))
8	   CONTINUE
C
	   ACLEN = LEN + PDSIZE_LEN
	   CALL IFFAC(ACTYPE,PDSIZE_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_PDMODE) THEN
	   CHAR = '$PDMODE '
	   LEN  = 8
	   DO 109 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
109	   CONTINUE
C
	   DO 9 II = 1,PDMODE_LEN
	      AC(LEN+II) = ICHAR(PDMODE(II:II))
9	   CONTINUE
C
	   ACLEN = LEN + PDMODE_LEN
	   CALL IFFAC(ACTYPE,PDMODE_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_LUNITS) THEN
	   CHAR = '$LUNITS '
	   LEN  = 8
	   DO 110 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
110	   CONTINUE
C
	   DO 10 II = 1,LUNITS_LEN
	      AC(LEN+II) = ICHAR(LUNITS(II:II))
10	   CONTINUE
C
	   ACLEN = LEN + LUNITS_LEN
	   CALL IFFAC(ACTYPE,LUNITS_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_LUPREC) THEN
	   CHAR = '$LUPREC '
	   LEN  = 8
	   DO 111 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
111	   CONTINUE
C
	   DO 11 II = 1,LUPREC_LEN
	      AC(LEN+II) = ICHAR(LUPREC(II:II))
11	   CONTINUE
C
	   ACLEN = LEN + LUPREC_LEN
	   CALL IFFAC(ACTYPE,LUPREC_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_TDCREATE) THEN
	   CHAR = '$TDCREATE '
	   LEN  = 10
	   DO 112 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
112	   CONTINUE
C
	   DO 12 II = 1,TDCREATE_LEN
	      AC(LEN+II) = ICHAR(TDCREATE(II:II))
12	   CONTINUE
C
	   ACLEN = LEN + TDCREATE_LEN
	   CALL IFFAC(ACTYPE,TDCREATE_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_TDINDWG) THEN
	   CHAR = '$TDINDWG '
	   LEN  = 9
	   DO 113 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
113	   CONTINUE
C
	   DO 13 II = 1,TDINDWG_LEN
	      AC(LEN+II) = ICHAR(TDINDWG(II:II))
13	   CONTINUE
C
	   ACLEN = LEN + TDINDWG_LEN
	   CALL IFFAC(ACTYPE,TDINDWG_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_TDUPDATE) THEN
	   CHAR = '$TDUPDATE '
	   LEN  = 10
	   DO 114 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
114	   CONTINUE
C
	   DO 14 II = 1,TDUPDATE_LEN
	      AC(LEN+II) = ICHAR(TDUPDATE(II:II))
14	   CONTINUE
C
	   ACLEN = LEN + TDUPDATE_LEN
	   CALL IFFAC(ACTYPE,TDUPDATE_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_TDUSRTIMER) THEN
	   CHAR = '$TDUSRTIMER '
	   LEN  = 12
	   DO 115 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
115	   CONTINUE
C
	   DO 15 II = 1,TDUSRTIMER_LEN
	      AC(LEN+II) = ICHAR(TDUSRTIMER(II:II))
15	   CONTINUE
C
	   ACLEN = LEN + TDUSRTIMER_LEN
	   CALL IFFAC(ACTYPE,TDUSRTIMER_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_UCSNAME) THEN
	   CHAR = '$UCSNAME '
	   LEN  = 9
	   DO 116 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
116	   CONTINUE
C
	   DO 16 II = 1,UCSNAME_LEN
	      AC(LEN+II) = ICHAR(UCSNAME(II:II))
16	   CONTINUE
C
	   ACLEN = LEN + UCSNAME_LEN
	   CALL IFFAC(ACTYPE,UCSNAME_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_UCSORG) THEN
	   CHAR = '$UCSORG '
	   LEN  = 8
	   DO 117 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
117	   CONTINUE
C
	   DO 17 III = 1,3
	      DO 18 II = 1,UCSORG_LEN(III)
	         AC(LEN+II) = ICHAR(UCSORG(III)(II:II))
18	      CONTINUE
	      LEN = LEN + UCSORG_LEN(III)+1
	      AC(LEN) = ICHAR(' ')
17	   CONTINUE
C
	   ACLEN = LEN
	   CALL IFFAC(ACTYPE,LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_UCSXDIR) THEN
	   CHAR = '$UCSXDIR '
	   LEN  = 9
	   DO 119 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
119	   CONTINUE
C
	   DO 19 III = 1,3
	      DO 20 II = 1,UCSXDIR_LEN(III)
	         AC(LEN+II) = ICHAR(UCSXDIR(III)(II:II))
20	      CONTINUE
	      LEN = LEN + UCSXDIR_LEN(III)+1
	      AC(LEN) = ICHAR(' ')
19	   CONTINUE
C
	   ACLEN = LEN
	   CALL IFFAC(ACTYPE,LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_UCSYDIR) THEN
	   CHAR = '$UCSYDIR '
	   LEN  = 9
	   DO 121 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
121	   CONTINUE
C
	   DO 21 III = 1,3
	      DO 22 II = 1,UCSYDIR_LEN(III)
	         AC(LEN+II) = ICHAR(UCSYDIR(III)(II:II))
22	      CONTINUE
	      LEN = LEN + UCSYDIR_LEN(III)+1
	      AC(LEN) = ICHAR(' ')
21	   CONTINUE
C
	   ACLEN = LEN
	   CALL IFFAC(ACTYPE,LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_LAYER_NAME) THEN
	   CHAR = '$CLAYER '
	   LEN  = 8
	   DO 123 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
123	   CONTINUE
C
	   DO 23 II = 1,DEF_LAYER_NAME_LEN
	      AC(LEN+II) = ICHAR(DEF_LAYER_NAME(II:II))
23	   CONTINUE
C
	   ACLEN = LEN + DEF_LAYER_NAME_LEN
	   CALL IFFAC(ACTYPE,DEF_LAYER_NAME_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_CECOLOR) THEN
	   CHAR = '$CECOLOR '
	   LEN  = 9
	   DO 124 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
124	   CONTINUE
C
	   DO 24 II = 1,CECOLOR_LEN
	      AC(LEN+II) = ICHAR(CECOLOR(II:II))
24	   CONTINUE
C
	   ACLEN = LEN + CECOLOR_LEN
	   CALL IFFAC(ACTYPE,CECOLOR_LEN,AC,ACLEN)
	ENDIF
C
	IF (HAD_CELTYPE) THEN
	   CHAR = '$CELTYPE '
	   LEN  = 9
	   DO 125 JJ= 1,LEN
	      AC(JJ) = ICHAR(CHAR(JJ:JJ))
125	   CONTINUE
C
	   DO 25 II = 1,CELTYPE_LEN
	      AC(LEN+II) = ICHAR(CELTYPE(II:II))
25	   CONTINUE
C
	   ACLEN = LEN + CELTYPE_LEN
	   CALL IFFAC(ACTYPE,CELTYPE_LEN,AC,ACLEN)
	ENDIF
C
C Set border
C
	COORD(1,1) = RA(1)
	COORD(2,1) = RA(3)
	COORD(1,2) = RA(2)
	COORD(2,2) = RA(3)
	COORD(1,3) = RA(2)
	COORD(2,3) = RA(4)
	COORD(1,4) = RA(1)
	COORD(2,4) = RA(4)
	COORD(1,5) = RA(1)
	COORD(2,5) = RA(3)
C
	CALL IFFST(COORD,5,0)
	CALL IFFEF
	GOTO 2000
C
C Error exit
C
2001	CALL LSL_PUTMSG(DXF2I__RDLINERR,NUMLIN)
C
2000	RETURN
	END
C
