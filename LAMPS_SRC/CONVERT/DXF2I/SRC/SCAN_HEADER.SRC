C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1993-06-15 10:51:34.000000000 +0100
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	LOGICAL*4 FUNCTION SCAN_HEADER()
C
***	MODULE SCAN_HEADER
***	IDENT 15JN93
C
C ©Copyright Laser-Scan Ltd, Cambridge, England.
C
C Author  :  A.T. Timms					 2 Nov 1987
C
CMOD1226     J. Barber					12 May 1993
C	     Copied from read_header for /SCAN to just read the
C	     DXF file, no IFF output
C
C Function to read DXF file HEADER section
C
	IMPLICIT NONE
C
	INCLUDE  'LSL$CMNLSL:READSTR.PAR'
	INCLUDE  'LSL$CMNDXFPAR:LOOKUP.CMN'
	INCLUDE  'HERE:DXF2I.CMN'
	INCLUDE  'HERE:DXF2IMSG.PAR'
C
C Functions
	INTEGER		FLRLIN			! Read a line from file
	INTEGER		READSTR			! Get a string
	INTEGER		RDREAL			! Get a real
	INTEGER		RDINT			! Get an integer
C
C Workspace
	CHARACTER*255	STRING,CHAR		! Any old string
	INTEGER		II,III			! Loop variables
	INTEGER		LEN			! String length
	INTEGER*2	COLTYP	   ! Colour organisation (by block or layer)
	INTEGER*2	FC(4)
C
C AC variable CHAR duplicates of CMN DEF_TEXT_HEIGHT,DEF_POINT_SIZE
C
	CHARACTER*255	TEXTSIZE,PDSIZE
	INTEGER		TEXTSIZE_LEN,PDSIZE_LEN
C
	CHARACTER*255	CECOLOR,CELTYPE
	LOGICAL		HAD_CECOLOR,HAD_CELTYPE
	INTEGER		CECOLOR_LEN,CELTYPE_LEN
C
C Header variables for AC's only
C
	CHARACTER*255	LUNITS,LUPREC,PDMODE
	INTEGER		LUNITS_LEN,LUPREC_LEN,PDMODE_LEN
	LOGICAL		HAD_LUNITS,HAD_LUPREC,HAD_PDMODE
C
	CHARACTER*255	TDCREATE,TDINDWG,TDUPDATE,TDUSRTIMER
	INTEGER		TDCREATE_LEN,TDINDWG_LEN
	INTEGER		TDUPDATE_LEN,TDUSRTIMER_LEN
	LOGICAL		HAD_TDCREATE,HAD_TDINDWG
	LOGICAL		HAD_TDUPDATE,HAD_TDUSRTIMER
C
	CHARACTER*255	UCSNAME
	INTEGER		UCSNAME_LEN
	LOGICAL		HAD_UCSNAME
C
	CHARACTER*255	UCSORG(3)
	INTEGER		UCSORG_LEN(3)
	LOGICAL		HAD_UCSORG
C
	CHARACTER*255	UCSXDIR(3)
	INTEGER		UCSXDIR_LEN(3)
	LOGICAL		HAD_UCSXDIR
C
	CHARACTER*255	UCSYDIR(3)
	INTEGER		UCSYDIR_LEN(3)
	LOGICAL		HAD_UCSYDIR
C
C.......................................................................
C
	IF (HAD_LOG) CALL LSL_PUTMSG(DXF2I__RDHDSC)
C
	BY_LAYER       = .FALSE.
	LTYPE_BY_LAYER = .FALSE.
C
	HAD_CECOLOR    = .FALSE.
	HAD_CELTYPE    = .FALSE.
C
C Common block AC variables
	HAD_TEXT_HEIGHT = .FALSE.
	HAD_TEXT_STYLE  = .FALSE.
	HAD_POINT_SIZE  = .FALSE.
	HAD_LAYER_NAME  = .FALSE.
C
C Local AC variables
	HAD_LUNITS     = .FALSE.
	HAD_LUPREC     = .FALSE.
	HAD_PDMODE     = .FALSE.
	HAD_TDCREATE   = .FALSE.
	HAD_TDINDWG    = .FALSE.
	HAD_TDUPDATE   = .FALSE.
	HAD_TDUSRTIMER = .FALSE.
	HAD_UCSNAME    = .FALSE.
	HAD_UCSORG     = .FALSE.
	HAD_UCSXDIR    = .FALSE.
	HAD_UCSYDIR    = .FALSE.
C
C Get another line from the header
C
99	SCAN_HEADER = FLRLIN()
	IF (.NOT.SCAN_HEADER) GOTO 2001
C
	CALL BSLN
	NUMLIN = NUMLIN + 1
	LEN = READSTR(STRING,,ON_EOL)
	IF (LEN.EQ.0) GOTO 99 		! Account for valid null lines
C
C Delegate according to the contents of string
C
	IF (STRING(1:LEN).EQ.'ENDSEC') THEN
	   GOTO 1000
	ELSEIF (STRING(1:LEN).EQ.'0') THEN
	   GOTO 99
	ELSEIF (STRING(1:LEN).EQ.'2') THEN
	   GOTO 99
	ELSEIF (STRING(1:LEN).EQ.'9') THEN
	   GOTO 99
C
C Upper right drawing extent
C
	ELSEIF (STRING(1:LEN).EQ.'$EXTMAX') THEN
	   DO 60 II = 1,2
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      IF (RDREAL(RA(II*2))) THEN
	 	 SCAN_HEADER = DXF2I__UNACONT
		 GOTO 2001
	      ENDIF
60	   CONTINUE
C
C Upper right drawing limits
C
	ELSEIF (STRING(1:LEN).EQ.'$LIMMAX') THEN
	   DO 50 II = 1,2
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
C	      CALL BSLN
C	      IF (RDREAL(RA(II*2))) THEN
C	 	 SCAN_HEADER = DXF2I__UNACONT
C		 GOTO 2001
C	      ENDIF
50	   CONTINUE
C
C Lower left drawing extent
C
	ELSEIF (STRING(1:LEN).EQ.'$EXTMIN') THEN
	   DO 30 II = 1,2
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      IF (RDREAL(RA(II*2-1))) THEN
	 	 SCAN_HEADER = DXF2I__UNACONT
		 GOTO 2001
	      ENDIF
30	   CONTINUE
C
C Lower left drawing limits
C
	ELSEIF (STRING(1:LEN).EQ.'$LIMMIN') THEN
	   DO 40 II = 1,2
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
C	      CALL BSLN
C	      IF (RDREAL(RA(II*2-1))) THEN
C	 	 SCAN_HEADER = DXF2I__UNACONT
C		 GOTO 2001
C	      ENDIF
40	   CONTINUE
C
C Colour by block or layer?
C
	ELSEIF (STRING(1:LEN).EQ.'$CECOLOUR' .OR.
     &		STRING(1:LEN).EQ.'$CECOLOR') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   CECOLOR_LEN = READSTR(CECOLOR,,ON_EOL)
	   IF (CECOLOR_LEN.EQ.0) GOTO 99   ! Account for valid null lines
	   HAD_CECOLOR = .TRUE.
C
	   CALL BSLN
	   IF (RDINT(COLTYP)) THEN
	      SCAN_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   IF (COLTYP.EQ.256) BY_LAYER = .TRUE.
C
C LINETYPE by layer? (BYBLOCK not supported)
C
	ELSEIF (STRING(1:LEN).EQ.'$CELTYPE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   CELTYPE_LEN = READSTR(CELTYPE,,ON_EOL)
	   IF (CELTYPE_LEN.EQ.0) GOTO 99   ! Account for valid null lines
C
	   HAD_CELTYPE = .TRUE.
	   IF (CELTYPE(1:CELTYPE_LEN).EQ.'BYLAYER') LTYPE_BY_LAYER = .TRUE.
C
C Default layer name
C
	ELSEIF (STRING(1:LEN).EQ.'$CLAYER') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   DEF_LAYER_NAME_LEN = READSTR(DEF_LAYER_NAME,,ON_EOL)
	   IF (DEF_LAYER_NAME_LEN.EQ.0) GOTO 99	! Account for null lines
	   HAD_LAYER_NAME = .TRUE.
C
C Default text height
C
	ELSEIF (STRING(1:LEN).EQ.'$TEXTSIZE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   IF (RDREAL(DEF_TEXT_HEIGHT)) THEN
	      SCAN_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   HAD_TEXT_HEIGHT = .TRUE.
C
	   CALL BSLN
	   TEXTSIZE_LEN = READSTR(TEXTSIZE,,ON_EOL)
C
C Default text style
C
	ELSEIF (STRING(1:LEN).EQ.'$TEXTSTYLE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   DEF_TEXT_STYLEN = READSTR(DEF_TEXT_STYLE,,ON_EOL)
	   IF (DEF_TEXT_STYLEN.EQ.0) GOTO 99	! Account for null lines
	   HAD_TEXT_STYLE = .TRUE.
C
C Default point size
C
	ELSEIF (STRING(1:LEN).EQ.'$PDSIZE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   IF (RDREAL(DEF_POINT_SIZE)) THEN
	      SCAN_HEADER = DXF2I__UNACONT
	      GOTO 2001
	   ENDIF
	   HAD_POINT_SIZE = .TRUE.
C
	   CALL BSLN
	   PDSIZE_LEN = READSTR(PDSIZE,,ON_EOL)
C
	ELSEIF (STRING(1:LEN).EQ.'$PDMODE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   PDMODE_LEN = READSTR(PDMODE,,ON_EOL)
	   IF (PDMODE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_PDMODE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSNAME') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   UCSNAME_LEN = READSTR(UCSNAME,,ON_EOL)
	   IF (UCSNAME_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_UCSNAME = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSORG') THEN
	   DO 3 II = 1,3
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSORG_LEN(II) = READSTR(UCSORG(II),,ON_EOL)
3	   CONTINUE
C
	   HAD_UCSORG = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSXDIR') THEN
	   DO 2 II = 1,3
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSXDIR_LEN(II) = READSTR(UCSXDIR(II),,ON_EOL)
2	   CONTINUE
C
	   HAD_UCSXDIR = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$UCSYDIR') THEN
	   DO 1 II = 1,3
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      SCAN_HEADER = FLRLIN()
	      IF (.NOT.SCAN_HEADER) GOTO 2001
	      NUMLIN = NUMLIN+1
C
	      CALL BSLN
	      UCSYDIR_LEN(II) = READSTR(UCSYDIR(II),,ON_EOL)
1	   CONTINUE
C
	   HAD_UCSYDIR = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$LUNITS') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   LUNITS_LEN = READSTR(LUNITS,,ON_EOL)
	   IF (LUNITS_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_LUNITS = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$LUPREC') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   LUPREC_LEN = READSTR(LUPREC,,ON_EOL)
	   IF (LUPREC_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_LUPREC = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDCREATE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDCREATE_LEN = READSTR(TDCREATE,,ON_EOL)
	   IF (TDCREATE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDCREATE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDINDWG') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDINDWG_LEN = READSTR(TDINDWG,,ON_EOL)
	   IF (TDINDWG_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDINDWG = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDUPDATE') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDUPDATE_LEN = READSTR(TDUPDATE,,ON_EOL)
	   IF (TDUPDATE_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDUPDATE = .TRUE.
C
	ELSEIF (STRING(1:LEN).EQ.'$TDUSRTIMER') THEN
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   SCAN_HEADER = FLRLIN()
	   IF (.NOT.SCAN_HEADER) GOTO 2001
	   NUMLIN = NUMLIN+1
C
	   CALL BSLN
	   TDUSRTIMER_LEN = READSTR(TDUSRTIMER,,ON_EOL)
	   IF (TDUSRTIMER_LEN.EQ.0) GOTO 99		! Account for null lines
	   HAD_TDUSRTIMER = .TRUE.
 	ENDIF
C
	GOTO 99
C
C.......................................................................
C Select the SCAN file for output
C
1000	CONTINUE
C
	CALL FLWSEL(SCANLUN)
C
C reports
C
C warn if colour or line type by layer
C
	IF (BY_LAYER) THEN
	   CALL WRITEF
	   CALL LSL_PUTMSG(DXF2I__COLBYLAY)
	   CALL WRITEF
	ENDIF
	IF (LTYPE_BY_LAYER) THEN
	   CALL LSL_PUTMSG(DXF2I__LTYPEBYLAY)
	   CALL WRITEF
	ENDIF
C
	NF = 0
	DO 5 II = 1,4
	   FC(II) = 0
5	CONTINUE
C
	GOTO 2000
C
C Error exit
C
2001	CALL LSL_PUTMSG(DXF2I__RDLINERR,NUMLIN)
C
2000	RETURN
	END
C
