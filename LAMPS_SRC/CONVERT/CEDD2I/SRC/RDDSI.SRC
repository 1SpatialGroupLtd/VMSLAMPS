	LOGICAL FUNCTION RDDSI
C
***	IDENT	08SE88
***	MODULE	RDDSI
C
C	Copyright LaserScan Laboratories Ltd., Cambridge, England
C
C Author J Barber, 16 May 1988
C
C This subroutine reads the DSI (Data Set Identification) block which
C  it expects to find in BYTBUF, and outputs the info to the map 
C  descriptor (MD-2) of IFF, or to AC's in an enclosing area feature
C  in layer 0 which bounds the whole map
C 
C Accuracy regions and registration points are also put into layer 0
C  as area/point features with their values as AC,s
C
	IMPLICIT NONE
C
***     PARAMETER/HERE:CEDD2IMSG/
***     COMMON/LSL$CMNIFF:MD2DES/       ! MD2 map descriptor 
***     COMMON/HERE:STATE/
***     COMMON/HERE:DESCR/
***     COMMON/HERE:SCRIPT/             ! for map info
***	COMMON/HERE:PARAMS/	        ! for DIAG
***     COMMON/HERE:BUFFER/
C
C functions called
C
C  a note about READSTR (using the local RDCH):
C  At present READSTR ignores trailing spaces in the 'length of string'
C  returned. As this return is the only way of telling whether RDCH has
C  stopped reading because of its 'end of line' termination ('DEL') it
C  is important to count the spaces to check that READSTR has read the 
C  requested no. of characters. This is done by forcing READSTR to 
C  "terminate" at 'DELETE' given in the argument list. Although RDCH 
C  will return TRUE ('end of line') before the term. char. is tested, 
C  trailing spaces will end up being counted as normal characters.
C
        LOGICAL         RDCH
        LOGICAL         RDDMSH          ! convert DDMMSSSS
        LOGICAL         RDREG           ! read reg'n points
        LOGICAL         RDACC           ! read accuracy regions
        LOGICAL         STRTIF          ! start IFF
        LOGICAL         CVTDAY          ! convert DDMMYY
        LOGICAL         DSI_READ_LONG   ! read longword
        LOGICAL         DSI_READ_REAL
        LOGICAL         DSI_READ_STRING ! read char string
C
C workspace
C
	INTEGER*2	PTR             ! locally saved pointer
        INTEGER*2       DCP1,DCP2
        INTEGER*2       I               ! loop counter
        INTEGER*2       START
        INTEGER*2       LEN
C
        INTEGER         INTOUT          ! result from RDDMSH
        REAL*8          OUT 
C
        INTEGER         RGPTAD          ! reg'n points address
        INTEGER         ACPTAD          ! accuracy regions address
        INTEGER         NUMPTS          ! no of reg'n points
        INTEGER         NUMREG          ! no of acc regions
        INTEGER         LSTRCT          ! last record count
        INTEGER         SCALE           ! for MD2SCL
C
        INTEGER         LL(2)           ! for origin lat/long
        INTEGER         REMAIN
        INTEGER         DEG(2)
        INTEGER         MIN(2)
        INTEGER         HUN(2)
        REAL            SEC(2)
C
        LOGICAL         SEC100          ! converting to sec/100? 
        LOGICAL         MINSEC          ! converting minutes to
C                                       !   seconds?
        CHARACTER*1     HEMIS(2)
	CHARACTER*25	TITLE		! for TITLE 
        CHARACTER*40    IGNORE          ! data to ignore
        CHARACTER*4     GROUP           ! group headers
        CHARACTER*40    STRING          ! for last data, if any 
C
        BYTE            REST(40)
C
        BYTE            NUL
        DATA            NUL /Z00/
        CHARACTER*2     NUL2
        CHARACTER*3     NUL3
C
C  ****************************************************************
C be optimistic initially
C
	RDDSI = .TRUE.
C
        WRITE (NUL2, 5) NUL, NUL
5       FORMAT (2A1)
C
        WRITE (NUL3, 10) NUL, NUL, NUL
10      FORMAT (3A1)
C
C the first four characters should be DSIG - dataset ident group
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.9) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Dataset Ident Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (GROUP.NE.'DSIG') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, PTR, GROUP)
C
C  first the series designator/product type 
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.13) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Series Designator/product'
        PRODCT = '     '
C
        IF (.NOT.DSI_READ_STRING (5, PRODCT, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  now the dataset reference name/number ID
C
	CALL DCPSAV(PTR)
        IF (PTR.NE.18) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Reference Code/ID'
        REFNCE = '                    '
C
        IF (.NOT.DSI_READ_STRING (20, REFNCE, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C now the edition number
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.38) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Edition Number'
        EDNNUM = 0
C
        IF (.NOT.DSI_READ_LONG (3, EDNNUM, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  compilation date YYMM 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.41) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Compilation date'
C
        CMPDAT = 0
        IF (.NOT.CVTDAY (.FALSE., CMPDAT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  revision date YYMM 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.45) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Revision date'
C
        REVDAT = 0
        IF (.NOT.CVTDAY (.FALSE., REVDAT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  IHO format date YYMMDD 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.49) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'IHO Format date'
C
        IHODAT = 0
        IF (.NOT.CVTDAY (.TRUE., IHODAT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  FACS format date YYMMDD 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.55) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'FACS Format date'
C
        FACDAT = 0
        IF (.NOT.CVTDAY (.TRUE., FACDAT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  ignore next 102 spaces
C
        DO 115 I = 1,3
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.61+34*(I-1)) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Ignored - unused'
C
        IF (.NOT.DSI_READ_STRING (34, IGNORE, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
115     CONTINUE
C
C next four characters should be DSPG - dataset parameter group
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.163) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Dataset Parameter Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (GROUP.NE.'DSPG') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, PTR, GROUP)
C
C  the map data/coordinate  type- GEO, MAP, DIG
C
C   GEO - Geographic coordinates (angle): proj'n transformation
C         may convert to projection coordinates.
C
C   MAP - Projection coordinates (x,y) on a cartographic projection:
C         proj'n transformation may convert to geographic coords.
C
C   DIG - Machine coordinates (x,y) on digitising table: become 
C         proj'n/geographic coords when adjusted to control
C         (registration) points
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.167) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Map Data Type'
C
        GEOGR = .FALSE.
        MAPTYP = '   '
C
        IF (.NOT.DSI_READ_STRING (3, MAPTYP, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (MAPTYP.EQ.'GEO') THEN
           GEOGR = .TRUE.
           MD2PRJ = 100
        ELSEIF (MAPTYP.EQ.'MAP') THEN
           MD2PRJ = 0                      ! for now
        ELSEIF (MAPTYP.EQ.'DIG') THEN
           MD2PRJ = 0                      ! for now
        ELSE
           MD2PRJ = 0
           CALL LSL_PUTMSG (CEDD2I__MAPTYPERR, MAPTYP)
        ENDIF
C
C  the measuring units in x,y - IN, UM, SEC etc
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.170) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'X,Y measurements unit'
C
        MINSEC = .FALSE.
        SEC100 = .FALSE.
        CONVN = 1D0
        MD2UNT = 0
        XUNITS = '   '
C
        IF (.NOT.DSI_READ_STRING (3, XUNITS, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (RDSTRERR .OR. XUNITS.EQ.'   ' .OR. 
     &                    XUNITS.EQ.NUL3) THEN
           CALL LSL_PUTMSG (CEDD2I__MISSUNITS)
           CALL SETWIN (PTR+8, )
           GOTO 119
        ENDIF
C
C   the horiz resolution
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.173) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Horizontal resolution'
        XNUMBR = 0.0
C
        IF (.NOT.DSI_READ_REAL (5, XNUMBR, TITLE, 1)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        IF (MAPTYP.EQ.'GEO') THEN                  ! geographic
C
           IF (XUNITS.EQ.'DEG') THEN
              MD2UNT = 4                   ! convert to whole degrees
              CONVN = XNUMBR
           ELSEIF (XUNITS.EQ.'MIN') THEN
              MINSEC = .TRUE.
              CONVN = XNUMBR*60D0
              XUNITS = 'SEC'
              XNUMBR = 1.0
              MD2UNT = 3                   ! convert to secs
           ELSEIF (XUNITS.EQ.'SEC') THEN
              IF (XNUMBR.LE.0.1) THEN
                 CONVN = XNUMBR/0.1D0
                 XNUMBR = 0.1
                 MD2UNT = 110              ! convert to sec/10
                 IF (XNUMBR.NE.0.1) SEC100 = .TRUE.
              ELSE
                 CONVN = XNUMBR
                 MD2UNT = 3                ! convert to whole secs
              ENDIF
           ELSE
              CONVN = 1D0
              MD2UNT = 105                 ! user specified units
           ENDIF
C
        ELSEIF (MAPTYP.EQ.'MAP') THEN
           IF (XUNITS.EQ.'M  ') THEN
              CONVN = XNUMBR
              MD2UNT = 2                   ! convert to whole metres
           ELSEIF (XUNITS.EQ.'FT ') THEN
              CONVN = XNUMBR
              MD2UNT = 1                   ! convert to whole feet
           ELSE
              CONVN = 1D0
              MD2UNT = 105
           ENDIF
C
        ELSEIF (MAPTYP.EQ.'DIG') THEN
           IF (XUNITS.EQ.'MM ') THEN
              CONVN = XNUMBR
              MD2UNT = 101                   ! keep as mm
           ELSEIF (XUNITS.EQ.'IN ') THEN
              CONVN = XNUMBR * 1000D0        ! convert to ins/1000
              XNUMBR = 0.001
              MD2UNT = 103
           ELSE
              CONVN = 1D0
              MD2UNT = 105
           ENDIF
        ENDIF
C
119     IF (FULL_DIAG) THEN
           CALL WRITEF
           CALL WRITEF (' MD2 units of IFF file are:      %N',
     &                                                       MD2UNT)
           CALL WRITEF (' Conversion factor for units is: %^D%F7.3', 
     &                                                        CONVN)
           CALL WRITEF
        ENDIF
C
C  next the Geodetic Datum - reference system for horiz positions
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.178) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Geodetic Datum '
        GEODTM = '   '
C
        IF (.NOT.DSI_READ_STRING (3, GEODTM, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  next the Ellipsoid/spheroid to which horiz datum is referenced
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.181) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Ellipsoid/spheroid'
        ELLIPS = '   '
C
        IF (.NOT.DSI_READ_STRING (3, ELLIPS, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        MD2SPH = 0
C
        IF  (ELLIPS.EQ.'AAY') MD2SPH = 9
        IF  (ELLIPS.EQ.'AUN') MD2SPH = 14
        IF  (ELLIPS.EQ.'AAM') MD2SPH = 11
        IF  (ELLIPS.EQ.'BES') MD2SPH = 2
        IF  (ELLIPS.EQ.'CLK') MD2SPH = 0
        IF  (ELLIPS.EQ.'CLJ') MD2SPH = 1
        IF  (ELLIPS.EQ.'EVE') MD2SPH = 6
        IF  (ELLIPS.EQ.'EVM') MD2SPH = 10
        IF  (ELLIPS.EQ.'GRS') MD2SPH = 8
        IF  (ELLIPS.EQ.'INT') MD2SPH = 4
        IF  (ELLIPS.EQ.'KRA') MD2SPH = 15
        IF  (ELLIPS.EQ.'WAL') MD2SPH = 12
        IF  (ELLIPS.EQ.'WGB') MD2SPH = 7
        IF  (ELLIPS.EQ.'WGC') MD2SPH = 5
        IF  (ELLIPS.EQ.'WGE') MD2SPH = 22
        IF  ((ELLIPS.EQ.'   ') .OR. (ELLIPS.EQ.NUL3))
     &            CALL LSL_PUTMSG (CEDD2I__SPHERUNSET)
C
	IF (FULL_DIAG) THEN
           CALL WRITEF
           CALL WRITEF (' MD2 spheroid = %N', MD2SPH)
           CALL WRITEF
        ENDIF
C
C  the measuring units in z - FT  etc, and the signal whether 
C   the SEG record will contain (x,y) or (x,y,x)
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.184) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Z measurements unit'
C
        THREED = .FALSE.
        ZUNITS = '   '
C
        IF (.NOT.DSI_READ_STRING (3, ZUNITS, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF ((ZUNITS.EQ.'   ') .OR. (ZUNITS.EQ.NUL3)) THEN
           THREED = .FALSE.
           CALL SETWIN (PTR+8, )            ! miss resolution
           ZNUMBR = 0.0
           GOTO 150
        ELSE
           THREED = .TRUE.
        ENDIF
C
C   the vertical resolution
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.187) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Vertical resolution'
        ZNUMBR = 0.0
C
        IF (.NOT.DSI_READ_REAL (5, ZNUMBR, TITLE, 1)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  next the vert reference code - MSL, GEOD: vert units referenced to
C                                         ellipsoid of specified datum
150     CALL DCPSAV (PTR)
        IF (PTR.NE.192) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Vertical reference code'
        VREF = '    '
C
        IF (.NOT.DSI_READ_STRING (4, VREF, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  next the Vertical Sounding Datum
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.196) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Vertical Sounding Datum'
        SNDDTM = '    '
C
        IF (.NOT.DSI_READ_STRING (4, SNDDTM, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (FULL_DIAG) THEN
           CALL WRITEF
C
           CALL WRITEF (' Vertical measurements referenced to')
C
           IF (VREF.EQ.'GEOD') THEN
              CALL WRITEF ('  spheroid of geodetic datum: %S', GEODTM)
           ELSEIF ((VREF.EQ.' MSL') .OR. (VREF.EQ.'MSL ')) THEN
              CALL WRITEF ('  vertical sounding datum: %S', SNDDTM)
           ELSE
              CALL WRITEF ('  unknown vertical datum')
           ENDIF
           CALL WRITEF
        ENDIF
C
C now the Origin Latitude of delta-coordinates:
C  latitude to which all geographic delta-coordinates in SEG records
C  are referenced
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.200) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Origin Latitude'
C
        MD2LOC(2) = 0D0
        MD2LOC(1) = 0D0
C
        OUT = 0D0
        INTOUT = 0
        ILAT0 = 0
        IF (.NOT.RDDMSH (.TRUE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        MD2LOC(2) = OUT
        ILAT0 = INTOUT
C
C and the Origin Longitude of delta-coordinates:
C  longitude to which all geographic delta-coordinates in SEG records
C  are referenced
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.209) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Origin Longitude'
C
        INTOUT = 0
        ILONG0 = 0 
        OUT = 0D0
        IF (.NOT.RDDMSH (.FALSE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        MD2LOC(1) = OUT 
        ILONG0 = INTOUT
C
C  check for right file by lat/long origin in arcsecs/100
C
        IF (SKIP) THEN
           IF (SERLAT) THEN
              IF (SKLAT.NE.ILAT0) GOTO 1000
           ENDIF                              ! right latitude
C
           IF (SERLON) THEN
              IF (SKLONG.NE.ILONG0) GOTO 1000
           ENDIF                              ! right longitude
C                                             !   (as well)
           SERLAT = .FALSE.                   ! process this file
           SERLON = .FALSE.
           SKIP   = .FALSE.
C
C  to get past here, must be processing this file
C
           CALL WRITEF
           CALL WRITEF (' Copying dataset no. %^W%N from tape', MANNUM)
           CALL WRITEF ('    requested by origin:')
        ENDIF
C
C  work out the degree, minute, second values
C
        LL(1) = ABS(ILAT0)
        LL(2) = ABS(ILONG0)
C
        IF (ILAT0.LT.0) THEN
           HEMIS(1) = 'S'
        ELSE
           HEMIS(1) = 'N'
        ENDIF
C
        IF (ILONG0.LT.0) THEN
           HEMIS(2) = 'W'
        ELSE
           HEMIS(2) = 'E'
        ENDIF
C
        DO 190 I = 1,2
        DEG(I) = LL(I)/360000
        REMAIN = LL(I) - DEG(I)*360000
C
        MIN(I) = REMAIN/6000
        HUN(I) = REMAIN - MIN(I)*6000
C
        SEC(I) = HUN(I)/100.0
190     CONTINUE
C
        CALL WRITEF
        CALL WRITEF (' Dataset origin is: ')
        CALL WRITEF
        CALL WRITEF ('    Latitude  %P %I4%I4%F7.2 %S   (%N)',
     &                    DEG(1), MIN(1), SEC(1), HEMIS(1), ILAT0)
        CALL WRITEF ('   Longitude  %P %I4%I4%F7.2 %S   (%N)',
     &                    DEG(2), MIN(2), SEC(2), HEMIS(2), ILONG0)
C
C  print other relevant information
C
        CALL WRITEF
        IF (MAPTYP.EQ.'GEO') THEN
           CALL WRITEF (' Geographic coordinates used throughout map')
        ELSEIF (MAPTYP.EQ.'MAP') THEN
           CALL WRITEF (' Map (ground) coordinates used throughout map')
        ELSEIF (MAPTYP.EQ.'DIG') THEN
           CALL WRITEF (' Digitising coordinates used throughout map')
        ENDIF
        CALL WRITEF
C
        IF (.NOT.THREED) THEN
           CALL WRITEF 
     & (' Coordinates are 2-dim: %F7.3 %S  by  %F7.3 %S',
     &     XNUMBR, XUNITS, XNUMBR, XUNITS)
        ELSE
           CALL WRITEF 
     & (' Coordinates are 3-dim: %F7.3 %S  by  %F7.3 %S  & %F7.3 %S',
     &     XNUMBR, XUNITS, XNUMBR, XUNITS, ZNUMBR, ZUNITS)
        ENDIF
        CALL WRITEF
        IF (SEC100) CALL WRITEF 
     &          (' Horiz units are being converted to arcsec/10')
        IF (MINSEC) CALL WRITEF 
     &          (' Horiz units are minutes: converting to arcsecs')
        CALL WRITEF
C
C  now the False Origins of projection in horiz units & res'n
C   and elevation from which all z values are measured in vert units
C   & res'n
C
        DO 200 I = 1,3  
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.219 +(I-1)*10) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'False Origin'
        ORIGIN(I) = 0
C
        IF (.NOT.DSI_READ_LONG (10, ORIGIN(I), TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
200     CONTINUE
C
C  the map extremes    
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.249) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Southernmost latitude'
C
        OUT = 0D0
        INTOUT = 0
        LATS = 0D0
        IF (.NOT.RDDMSH (.TRUE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        LATS = OUT
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.258) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Westernmost longitude'
C
        OUT = 0D0
        INTOUT = 0
        LONGW = 0D0
        IF (.NOT.RDDMSH (.FALSE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        LONGW = OUT
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.268) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Northernmost latitude'
C
        OUT = 0D0
        INTOUT = 0
        LATN = 0D0
        IF (.NOT.RDDMSH (.TRUE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        LATN = OUT
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.277) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Easternmost longitude'
C
        OUT = 0D0
        INTOUT = 0
        LONGE = 0D0
        IF (.NOT.RDDMSH (.FALSE., OUT, INTOUT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
        LONGE = OUT
C
        IF (GEOGR) THEN
           RANGE(1)  = LONGW 
           RANGE(2)  = LONGE
           RANGE(3)  = LATS
           RANGE(4)  = LATN
           RNGSET = .TRUE.                  ! range set
        ELSE
           RANGE(1)  = 0.0
           RANGE(2)  = 0.0
           RANGE(3)  = 0.0
           RANGE(4)  = 0.0
           MD2LOC(2) = 0D0                  ! already delta-coords
           MD2LOC(1) = 0D0
        ENDIF
C
        CALL WRITEF
        CALL WRITEF (' Local Origin is (x,y):  %^D%F9.2 %^D%F9.2 ',
     &                                      MD2LOC(1), MD2LOC(2))
        CALL WRITEF
        CALL WRITEF (' Range of map is: ')
        CALL WRITEF (' %F9.2 %F9.2   %F9.2 %F9.2 ',
     &                    RANGE(1), RANGE(2), RANGE(3), RANGE(4))
        CALL WRITEF
C
C  numbers of features, segments in dataset
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.287) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Total no. of features'
        TOTFTR = 0
C
        IF (.NOT.DSI_READ_LONG (6, TOTFTR, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.293) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'No. of point features'
        TOPFTR = 0
C
        IF (.NOT.DSI_READ_LONG (6, TOPFTR, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.299) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'No. of linear features'
        TOLFTR = 0
C
        IF (.NOT.DSI_READ_LONG (6, TOLFTR, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.305) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'No. of area features'
        TOAFTR = 0
C
        IF (.NOT.DSI_READ_LONG (6, TOAFTR, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.311) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Total no. of segments'
        TOTSEG = 0
C
        IF (.NOT.DSI_READ_LONG (6, TOTSEG, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.317) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  more unused
C
        TITLE = 'Ignored - unused'
C
        IF (.NOT.DSI_READ_STRING (40, IGNORE, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C the next 4 characters should be DSMP - dataset map projection group
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.357) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Dataset Map Projn Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (GROUP.NE.'DSMP') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, PTR, GROUP)
C
C  projection (blank for geographic)
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.361) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Projection Code'
        PROJN = '  '
C
        IF (.NOT.DSI_READ_STRING (2, PROJN, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (.NOT.GEOGR) THEN               ! not geographic
           IF (PROJN.EQ.'AC') THEN
              MD2PRJ = 3
           ELSEIF (PROJN.EQ.'AK') THEN
              MD2PRJ = 11                  ! maybe?
           ELSEIF (PROJN.EQ.'AL') THEN
              MD2PRJ = 12
           ELSEIF (PROJN.EQ.'GN') THEN
              MD2PRJ = 13
           ELSEIF (PROJN.EQ.'RB') THEN
              MD2PRJ = 20
           ELSEIF (PROJN.EQ.'LE') THEN
              MD2PRJ = 4
           ELSEIF (PROJN.EQ.'LJ') THEN
              MD2PRJ = 11               ! maybe?
           ELSEIF (PROJN.EQ.'MC') THEN
              MD2PRJ = 5
           ELSEIF (PROJN.EQ.'OC') THEN
              MD2PRJ = 21
           ELSEIF (PROJN.EQ.'OD') THEN
              MD2PRJ = 14
           ELSEIF (PROJN.EQ.'PG') THEN
              MD2PRJ = 6
           ELSEIF (PROJN.EQ.'PH') THEN
              MD2PRJ = 7
           ELSEIF (PROJN.EQ.'TC') THEN
              MD2PRJ = 9
           ELSE
              CALL LSL_PUTMSG (CEDD2I__PROJNUNSET)
	   ENDIF
        ELSE                   ! geographic, test for unset PROJN
C
           IF ((PROJN.EQ.'  ') .OR. (PROJN.EQ.NUL2)) THEN
              MD2PRJ = 100
           ELSE
              CALL LSL_PUTMSG (CEDD2I__PROJNINVAL, PROJN, MAPTYP)
           ENDIF
        ENDIF
C
        IF (FULL_DIAG) THEN 
           CALL WRITEF
           CALL WRITEF (' MD2 projection = %N', MD2PRJ)
           CALL WRITEF
        ENDIF
C
C the next four groups of 10 chars are projection parameters
C
        DO 230 I = 1,4
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.363 +(I-1)*10) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Projection Parameter'
        PRJPAR(I) = '          '
C
        IF (.NOT.DSI_READ_STRING (10, PRJPAR(I), TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
230     CONTINUE
C
C  scale reciprocal of x,y digitised or map proj'n coordinates
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.403) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Scale Reciprocal (MD2)'
        SCALE = 0
C
        IF (.NOT.DSI_READ_LONG (9, SCALE, TITLE, 1)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
        IF (RDLONGERR) CALL LSL_PUTMSG (CEDD2I__SCALEUNSET)
C
        MD2SCL = SCALE
C
C  more unused 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.412) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Ignored - unused'
C
        IF (.NOT.DSI_READ_STRING (40, IGNORE, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C the next 4 characters should be DSHG - dataset history group
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.452) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Dataset History Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (GROUP.NE.'DSHG') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, PTR, GROUP)
C
C  edition code - recompilation count, revision count
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.456) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Recompilation Count'
        CMPCNT = 0
C
        IF (.NOT.DSI_READ_LONG (2, CMPCNT, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.458) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Revision Count'
        REVCNT = 0
C
        IF (.NOT.DSI_READ_LONG (1, REVCNT, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  producer spec stock number
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.459) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Producer Spec Stock No.'
        PSSNUM = '               '
C
        IF (.NOT.DSI_READ_STRING (15, PSSNUM, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  product spec stock date YYMM 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.474) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Product Spec Stock Date'
C
        PSSDAT = 0
        IF (.NOT.CVTDAY (.FALSE., PSSDAT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  spec amendment no to product spec
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.478) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Spec Amendment Number'
        PSCHNO = 0
C
        IF (.NOT.DSI_READ_LONG (3, PSCHNO, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  producer - country, agency, branch  CCAAABBB
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.481) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Producer'
        PRODCR = '        '
C
        IF (.NOT.DSI_READ_STRING (8, PRODCR, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  primary digitising system
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.489) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Digitising System'
        DIGSYS = '          '
C
        IF (.NOT.DSI_READ_STRING (10, DIGSYS, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  last processing system
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.499) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Processing System'
        PROSYS = '          '
C
        IF (.NOT.DSI_READ_STRING (10, PROSYS, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  grid system code - blank for 'GEO'
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.509) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Grid System Code'
        GRIDCD = '  '
C
        IF (.NOT.DSI_READ_STRING (2, GRIDCD, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (GEOGR) THEN
           IF ((GRIDCD.NE.'  ') .AND. (GRIDCD.NE.NUL2)) 
     &            CALL LSL_PUTMSG (CEDD2I__GRIDINVAL, GRIDCD)
        ENDIF
C
C  absolute horiz accuracy
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.511) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Absolute Horiz Accuracy'
        MHAHAC = 0
C
        IF (.NOT.DSI_READ_LONG (4, MHAHAC, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  absolute vert accuracy
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.515) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Absolute Vert Accuracy'
        MHAVAC = 0
C
        IF (.NOT.DSI_READ_LONG (4, MHAVAC, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  relative horiz accuracy
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.519) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Relative Horiz Accuracy'
        MHRHAC = 0
C
        IF (.NOT.DSI_READ_LONG (4, MHRHAC, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  relative vert accuracy
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.523) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Relative Vert Accuracy'
        MHRVAC = 0
C
        IF (.NOT.DSI_READ_LONG (4, MHRVAC, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  height accuracy in metres
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.527) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Height Accuracy'
        MHVHAC = 0
C
        IF (.NOT.DSI_READ_LONG (4, MHVHAC, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  data generalisation - 0 raw data, 1 thinned data
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.531) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Data Generalisation'
        DATGEN = 0
C
        IF (.NOT.DSI_READ_LONG (1, DATGEN, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  match/merge nos - N, E, S, W
C
        DO 400 I = 1,4
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.531+I) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
	TITLE = 'Match/merge number'
        MMVNUM(I) = 0
C
        IF (.NOT.DSI_READ_LONG (1, MMVNUM(I), TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
400     CONTINUE
C
C  match/merge dates YYMM - N, E, S, W 
C
        DO 410 I = 1,4
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.536 +4*(I-1)) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Match/merge date'
C
        MMDATE(I) = 0
        IF (.NOT.CVTDAY (.FALSE., MMDATE(I), TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
410     CONTINUE
C
C  earliest source date YYMM 
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.552) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Earliest Source date'
C
        ESRCDT = 0
        IF (.NOT.CVTDAY (.FALSE., ESRCDT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  latest source date YYMM
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.556) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Latest Source date'
C
        LSRCDT = 0
        IF (.NOT.CVTDAY (.FALSE., LSRCDT, TITLE)) THEN
           IF (BLKERR.OR.DELFND) THEN
              CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
              RDDSI = .FALSE.
              GOTO 999
           ENDIF
        ENDIF
C
C  data collection code, criteria (as in product spec)
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.560) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Data Collection code'
        DCCODE = 0
C
        IF (.NOT.DSI_READ_LONG (1, DCCODE, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.561) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Data Collection criteria'
        DCCRIT = 0
C
        IF (.NOT.DSI_READ_LONG (3, DCCRIT, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
C  data structure code - C/S
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.564) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           RDDSI = .FALSE.
           GOTO 999
        ENDIF
C
        TITLE = 'Data Structure Code'
        STRUCT = ' '
C
        IF (.NOT.DSI_READ_STRING (1, STRUCT, TITLE, 0)) THEN
           RDDSI = .FALSE.
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        CALL WRITEF
        IF (STRUCT.EQ.'S') THEN
           CALL WRITEF (' *** This is a Sequential map')
        ELSEIF (STRUCT.EQ.'C') THEN
           CALL WRITEF (' *** This is a Chain-Node map')
        ELSE
           CALL LSL_PUTMSG (CEDD2I__STRUCTERR, STRUCT)
        ENDIF
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.565) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  now start main IFF file
C
        IF (.NOT.STRTIF (IFFLUN, FULNAM)) THEN            ! failed
           CALL LSL_PUTMSG (CEDD2I__STRTIFERR, FULNAM(:FULLEN))
           RDDSI = .FALSE.
           GOTO 999
        ENDIF 
C
        CALL OUTHDR (.TRUE.)             ! output header stuff
C                                        !   for proper IFF file
        CALL OUTLAY(0)                   ! open layer 0
C
        CALL LAYER0                      ! fill layer 0
C
C  reset BYTBUF and decode pointer after being messed by ACD stuff
C
        CALL SETAUX (BYTBUF, BUFLEN)
        CALL DCPSET (PTR)
C
C  after here all entries are optional and padding char 'DEL' imminent
C    to return RDCH TRUE and READSTR,RDLONG etc. cease 
C    reading/interpreting
C
C  ignore next 27 spaces
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.565) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
        TITLE = 'Ignored - unused'
C
        IF (.NOT.DSI_READ_STRING (27, IGNORE, TITLE, 0)) GOTO 999
C
C the next four characters should be DSVG - dataset variable address 
C                                                             group
        CALL DCPSAV (PTR)
        IF (PTR.NE.592) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
        TITLE = 'DS Variable Address Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) GOTO 999
C
        IF (GROUP.NE.'DSVG') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, PTR, GROUP)
C
C first the registration points address
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.596) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
	TITLE = 'Registration Points Addr'
        RGPTAD = 0
C
        IF (.NOT.DSI_READ_LONG (5, RGPTAD, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (RGPTAD.LT.0) THEN
           CALL LSL_PUTMSG (CEDD2I__REGSTRTERR, RGPTAD)
           RGPTAD = 0
        ENDIF
C
C and the accuracy regions address
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.601) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
	TITLE = 'Accuracy Regions Address'
        ACPTAD = 0
C
        IF (.NOT.DSI_READ_LONG (5, ACPTAD, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (ACPTAD.LT.0) THEN
           CALL LSL_PUTMSG (CEDD2I__ACCSTRTERR, ACPTAD)
           ACPTAD = 0
        ENDIF
C
C   more unused  
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.606) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 999
        ENDIF
C
        TITLE = 'Ignored - unused'
C
        IF (.NOT.DSI_READ_STRING (40, IGNORE, TITLE, 0)) THEN
           IF ((RGPTAD.GT.0) .OR. (ACPTAD.GT.0)) CALL LSL_PUTMSG 
     &                              (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
C  if reg'n points occur they should start at PTR 646
C    control/registration points are those whose geographic and 
C    machine coords are known, used to adjust machine into proj'n
C    coords.
C
C  work out where to go next
C
        IF (RGPTAD.GT.0) THEN               ! they do exist 
           IF (RGPTAD.NE.646) THEN
              CALL LSL_PUTMSG (CEDD2I__REGSTRTERR, RGPTAD)
              START = RGPTAD
              CALL SETWIN (START, )
              GOTO 600
           ENDIF
C
C  if only accuracy regions, they should start at PTR 646
C
        ELSE                                ! no reg'n points/error
           CALL WRITEF (' No Registration Points')
           IF (ACPTAD.GT.0) THEN            ! they do exist
              IF (ACPTAD.NE.646) THEN
                 CALL LSL_PUTMSG (CEDD2I__ACCSTRTERR, ACPTAD)
                 START = ACPTAD
                 CALL SETWIN (START, )
                 GOTO 700
              ENDIF
           ELSE                             ! no acc regions/error
              CALL WRITEF (' No Accuracy Regions')
              GOTO 800                      ! no more data, finish
           ENDIF
        ENDIF
C
C  registration group should start here:
C   the next four characters should be DSRG - dataset registration 
C                                                       point group
600     CALL DCPSAV (DCP1)
C
        TITLE = 'DS Registration Group'
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, DCP1)
           GOTO 999
        ENDIF
C
        IF (GROUP.NE.'DSRG') CALL LSL_PUTMSG 
     &                  (CEDD2I__DSIGRPERR, TITLE, DCP1, GROUP)
C
C  number of registration points
C
	CALL DCPSAV (PTR)
        IF (PTR.NE.DCP1+4) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           IF (ACPTAD.GT.0) THEN
              START = ACPTAD
              CALL SETWIN (START, )        ! do acc regions instead
              GOTO 700
           ELSE
              GOTO 800                     ! give up
           ENDIF
        ENDIF
C
	TITLE = 'No of Registration Points'
        NUMPTS = 0
C
        IF (.NOT.DSI_READ_LONG (3, NUMPTS, TITLE, 1)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        IF (RDLONGERR) THEN
           IF ((ACPTAD.GT.0) .AND. (RGPTAD.GT.0)) THEN
              NUMPTS = (ACPTAD - RGPTAD -7)/51
              CALL LSL_PUTMSG (CEDD2I__NUMPTSCALC, NUMPTS)
           ENDIF
	ENDIF
C
        IF (NUMPTS.LE.0) THEN
           IF (NUMPTS.LT.0) CALL LSL_PUTMSG (CEDD2I__NUMPTSERR, NUMPTS)
           IF (NUMPTS.EQ.0) CALL WRITEF (' No Registration Points') 
           IF (ACPTAD.GT.0) THEN
              START = ACPTAD
              CALL SETWIN (START, )
              GOTO 700                 ! do acc regions instead
           ELSE
              GOTO 800                 ! give up
           ENDIF
        ELSEIF (NUMPTS.GT.999) THEN 
           CALL LSL_PUTMSG (CEDD2I__NUMPTSERR, NUMPTS)
           NUMPTS = 999
        ENDIF
C
C  read the registration points records
C
        CALL DCPSAV (PTR)
        IF (PTR.NE.DCP1+7) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           IF (ACPTAD.GT.0) THEN
              START = ACPTAD
              CALL SETWIN (START, )      ! do acc regions instead
              GOTO 700
           ELSE
              GOTO 800                   ! give up
           ENDIF
        ENDIF
C
C  note that in the registration points block it is possible that
C    a new block/record is started, so that DCPTR may differ from
C    that expected by multiples of 1972 (although highly unlikely 
C    here)
C  save RECCNT
C
        LSTRCT = RECCNT
C
        CALL WRITEF
        CALL WRITEF (' %N Registration points', NUMPTS)
C
        IF (NUMPTS.GT.0) THEN
           IF (.NOT.RDREG (NUMPTS)) THEN
              IF (BLKERR.OR.DELFND) THEN
                 CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
                 GOTO 999
              ENDIF
              CALL LSL_PUTMSG (CEDD2I__RDREGERR)
              IF (ACPTAD.GT.0) THEN
                 START = ACPTAD
                 CALL SETWIN (START, )
                 GOTO 700                            ! some error
              ELSE
                 GOTO 800                            ! give up
              ENDIF
           ENDIF
        ENDIF
C
        IF (ACPTAD.EQ.0) GOTO 800
C
        CALL DCPSAV (DCP2)
C
        IF (DCP2.NE.DCP1+7+51*NUMPTS -1972*(RECCNT-LSTRCT)) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, DCP2)
           GOTO 999
        ENDIF
C
C  the accuracy regions should start here if any
C
700     TITLE = 'DS Accuracy Region Group'
C
        CALL DCPSAV (DCP2)
        GROUP = '    '
C
        IF (.NOT.DSI_READ_STRING (4, GROUP, TITLE, 0)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, DCP2)
           GOTO 999
        ENDIF
C
        IF (RDSTRERR) THEN
           START = DCP2+4
           IF (DCP2.GT.1980) START = MOD (DCP2+4, 1972)
           CALL SETWIN (START, )
        ENDIF
C
        IF (GROUP.NE.'DSAG') CALL LSL_PUTMSG
     &                      (CEDD2I__DSIGRPERR, TITLE, DCP2, GROUP)
C
C  if map coordinates are not geographic converting to arcsec/10,
C     the coordinates of the  accuracy regions will be non-sensical
C
        IF (.NOT.GEOGR) THEN
           CALL LSL_PUTMSG (CEDD2I__COORDTYPERR)
           GOTO 800
        ENDIF
C
C  number of accuracy regions
C
	CALL DCPSAV (PTR)
        IF ((PTR.NE.DCP2+4) .AND. (PTR.NE.DCP2+4-1972)) THEN
           CALL LSL_PUTMSG (CEDD2I__DSICNTERR, TITLE, PTR)
           GOTO 800
        ENDIF
C
	TITLE = 'No. of Accuracy Regions'
        NUMREG = 0
C
        IF (.NOT.DSI_READ_LONG (2, NUMREG, TITLE, 1)) THEN
           CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
           GOTO 999
        ENDIF
C
        START = PTR+2
        IF (PTR.GT.1980) START = MOD (PTR+2, 1972)
        CALL SETWIN (START, )
C
        IF (NUMREG.LT.0) THEN
           CALL LSL_PUTMSG (CEDD2I__NUMREGERR, NUMREG)
           GOTO 800
        ELSEIF (NUMREG.GT.99) THEN 
           CALL LSL_PUTMSG (CEDD2I__NUMREGERR, NUMREG)
           NUMREG = 99
        ELSEIF (NUMREG.EQ.0) THEN
           CALL WRITEF (' No Accuracy Regions')
           GOTO 800
        ENDIF
C
        CALL WRITEF
        CALL WRITEF (' %N Accuracy regions', NUMREG)
C
        IF (NUMREG.GT.0) THEN
           IF (.NOT.RDACC (NUMREG, NUMPTS)) THEN
              IF (BLKERR.OR.DELFND) THEN
                 CALL LSL_PUTMSG (CEDD2I__UNEXPEND, TITLE, PTR)
                 GOTO 999
              ENDIF
              CALL LSL_PUTMSG (CEDD2I__RDACCERR)
           ENDIF
        ENDIF
C
C   should be no more data - print it if there is
C
800     DO 850 I = 1,40
        REST (I) = ' '
850     CONTINUE
C
        DO 900 I = 1,40
        IF (RDCH (REST(I))) GOTO 940
900     CONTINUE
C
        WRITE (STRING, 950) (REST(I), I = 1,40)
C
        IF (STRING.NE.'                                        ') THEN
           TITLE = 'Remaining data'
           CALL LSL_PUTMSG (CEDD2I__DSIENDERR, TITLE, STRING)
        ELSE
           GOTO 999
        ENDIF
C
        GOTO 800
C
940     WRITE (STRING, 950) (REST(I), I = 1,40)
950     FORMAT (40A1)
C
999     TITLE = ' DSI End'
C
        CALL DCPSAV (PTR)
C
        IF (DIAG) THEN
           CALL WRITEF
           CALL WRITEF (' Stopped reading DSI at %S at %^W%N', 
     &                                               TITLE, PTR)
           CALL WRITEF
        ENDIF
C
        IF (INFTR) CALL IFFEF             ! just in case
        IF (INLAY(0)) CALL ENDLAY(0)      ! close layer 0
C
1000	RETURN		                  ! return with it
	END
C
