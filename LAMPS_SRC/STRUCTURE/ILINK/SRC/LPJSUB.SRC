C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1991-03-12 16:17:42.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	LOGICAL*4 FUNCTION LPJSUB(
     &		PFTR,QFTR,IP1,IQ1,
     &		PT,CC,PRV,NXT,PNT_FTR,
     &		FTR_PTS,FTR_INFTR,IN_FTR_STATUS,
     &		MAXPTS,MAXINFTRS,MAXOUTFTRS)

***	MODULE	LPJSUB
***	IDENT	12MR91

C	Copyright : Laser-Scan Laboratories Ltd., Cambridge, England

CMOD	Use LIN_PAC to ensure PAC codes are in range	WJJ	02-Feb-1990
CMOD	Bug-fix - use COORD_TOL**2 in length check	WJJ 26-Jan-1990
CMOD	Bug-fix - don't tamper with PF,QF after LININT	WJJ 26-Jan-1990
CMOD	Converted to use Point Accuracy Codes		ACM 05-Dec-1988
CMOD	Made a function					TJH 29-May-1987

C	Created   : ACM					       Nov 1986

	IMPLICIT NONE

C Parameters
	INCLUDE		'($SSDEF)'

C Commons
	INCLUDE		'LSL$CMNIFF:IFFHAN.CMN'	! has LPOSH
	INCLUDE		'LSL$CMNILINK:ILINK.CMN'

C Data in/out
	INTEGER*4	PFTR,QFTR		! line indices
	INTEGER*4	IP1			! pt at start of P vectr
	INTEGER*4	IQ1			! pt at start of Q vectr
	INTEGER*4	MAXPTS,MAXINFTRS,MAXOUTFTRS
	INTEGER*4	NXT(MAXPTS),PRV(MAXPTS)
	INTEGER*4	FTR_PTS(2,MAXOUTFTRS)
	INTEGER*4	FTR_INFTR(MAXOUTFTRS)
	INTEGER*4	CC(MAXPTS)

	REAL*4		PT(2,MAXPTS)

	BYTE		IN_FTR_STATUS(MAXINFTRS)

	LOGICAL*1	PNT_FTR(MAXOUTFTRS)

C Workspace
	REAL*4		P1P2X,P1P2Y		! vec from P1 to P2
	REAL*4		Q1Q2X,Q1Q2Y		! vec from Q1 to Q2
	REAL*4		P2Q2X,P2Q2Y		! vec from P2 to Q2
	REAL*4		P1Q1X,P1Q1Y		! vec from P1 to Q1
	REAL*4		P2Q1X,P2Q1Y		! vec from P2 to Q1
	REAL*4		P1Q2X,P1Q2Y		! vec from P1 to Q2
	REAL*4		P1X,P1Y,P2X,P2Y		! vector P end pts
	REAL*4		Q1X,Q1Y,Q2X,Q2Y		! vector Q end pts
	REAL*4		PF,QF,TF		! scale factors
	REAL*4		X,Y			! point to join to
	REAL*4		E1X,E1Y,E2X,E2Y		! for LININT
	REAL*4		DP1P2SQ,DQ1Q2SQ
	REAL*4		DP1Q1SQ,DP1Q2SQ
	REAL*4		DP2Q1SQ,DP2Q2SQ
	REAL*4		SQDIST			! sq dist

	REAL*4		P1_EXTOL,P2_EXTOL,Q1_EXTOL,Q2_EXTOL
	REAL*4		P1_JNTOL,P2_JNTOL,Q1_JNTOL,Q2_JNTOL

	REAL*4		SQDIST_P1_PROJ
	REAL*4		SQDIST_P1_VRTX
	REAL*4		SQDIST_P1_PERP

	REAL*4		SQDIST_P2_PROJ
	REAL*4		SQDIST_P2_VRTX
	REAL*4		SQDIST_P2_PERP

	REAL*4		SQDIST_Q1_PROJ
	REAL*4		SQDIST_Q1_VRTX
	REAL*4		SQDIST_Q1_PERP

	REAL*4		SQDIST_Q2_PROJ
	REAL*4		SQDIST_Q2_VRTX
	REAL*4		SQDIST_Q2_PERP

	REAL*4		X_P1_PROJ,Y_P1_PROJ
	REAL*4		X_P1_VRTX,Y_P1_VRTX
	REAL*4		X_P1_PERP,Y_P1_PERP

	REAL*4		X_P2_PROJ,Y_P2_PROJ
	REAL*4		X_P2_VRTX,Y_P2_VRTX
	REAL*4		X_P2_PERP,Y_P2_PERP

	REAL*4		X_Q1_PROJ,Y_Q1_PROJ
	REAL*4		X_Q1_VRTX,Y_Q1_VRTX
	REAL*4		X_Q1_PERP,Y_Q1_PERP

	REAL*4		X_Q2_PROJ,Y_Q2_PROJ
	REAL*4		X_Q2_VRTX,Y_Q2_VRTX
	REAL*4		X_Q2_PERP,Y_Q2_PERP

	INTEGER*4	IPTSTA,IPTFIN		! ftr end pt indices
	INTEGER*4	IP2,IQ2
	INTEGER*4	IEND1,IEND2		! for LININT
	INTEGER*4	IN_FTR			! input ftr index
	INTEGER*4	IPAC			! Pt Att Code index

	LOGICAL*4	P_IS_END,Q_IS_END	! P/Q ftr ends pts?
	LOGICAL*4	P1_IS_END,P2_IS_END
	LOGICAL*4	Q1_IS_END,Q2_IS_END
	LOGICAL*4	P_IS_POINT		! PFTR if pt-ftr?
	LOGICAL*4	Q_IS_POINT		! QFTR if pt-ftr?
	LOGICAL*4	PARALLEL		! vecs parallel?
	LOGICAL*4	INT_ON_PVEC,INT_ON_QVEC	! int on P/Q vec?
	LOGICAL*4	LINES_INTERSECT		! lines intersect?

	LOGICAL*4	CAN_JOIN_P1_TO_PROJ
	LOGICAL*4	CAN_JOIN_P1_TO_VRTX
	LOGICAL*4	CAN_JOIN_P1_TO_PERP

	LOGICAL*4	CAN_JOIN_P2_TO_PROJ
	LOGICAL*4	CAN_JOIN_P2_TO_VRTX
	LOGICAL*4	CAN_JOIN_P2_TO_PERP

	LOGICAL*4	CAN_JOIN_Q1_TO_PROJ
	LOGICAL*4	CAN_JOIN_Q1_TO_VRTX
	LOGICAL*4	CAN_JOIN_Q1_TO_PERP

	LOGICAL*4	CAN_JOIN_Q2_TO_PROJ
	LOGICAL*4	CAN_JOIN_Q2_TO_VRTX
	LOGICAL*4	CAN_JOIN_Q2_TO_PERP

	LOGICAL*4	CANT_JOIN_P1_TO_PROJ
	LOGICAL*4	CANT_JOIN_P1_TO_VRTX
	LOGICAL*4	CANT_JOIN_P1_TO_PERP

	LOGICAL*4	CANT_JOIN_P2_TO_PROJ
	LOGICAL*4	CANT_JOIN_P2_TO_VRTX
	LOGICAL*4	CANT_JOIN_P2_TO_PERP

	LOGICAL*4	CANT_JOIN_Q1_TO_PROJ
	LOGICAL*4	CANT_JOIN_Q1_TO_VRTX
	LOGICAL*4	CANT_JOIN_Q1_TO_PERP

	LOGICAL*4	CANT_JOIN_Q2_TO_PROJ
	LOGICAL*4	CANT_JOIN_Q2_TO_VRTX
	LOGICAL*4	CANT_JOIN_Q2_TO_PERP

	LOGICAL*4	IS_SYMBOL_STRING	! pt from symbol-string?
	LOGICAL*4	CLOSED			! ftr closed loop?
	LOGICAL*4	P_FROM_SYMBOL_STRING
	LOGICAL*4	Q_FROM_SYMBOL_STRING

	INTEGER*4	P1_PRI,P2_PRI
	INTEGER*4	Q1_PRI,Q2_PRI

C Functions
	LOGICAL*4	BOXINT			! do boxes intersect?
	LOGICAL*4	LININT			! do lines intersect?
	LOGICAL*4	CHECK_MAP
	INTEGER*4	LIN_PAC			! get PAC file line number

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	If either vector is a feature-end vector then it is checked
C	to see if it will project onto the other vector with in a
C	projection tolerance of EXTOL for that end.
C
C	If it does, this point is a candidate for the final position
C	of this vector end.
C
C	- Else it is checked to see if the end of the other vector
C	nearest to the point where the lines containing the two vectors
C	intersect is within EXTOL of the end of the vector being
C	projected.
C
C	If it is then this point is a candidate for the final position
C	of this vector end.
C
C	- Else it is checked to see if the point along the other vector
C	nearest to the end of the vector being projected is within JNTOL
C	of this end.
C
C	If it is then this point is a candidate for the final position
C
C	Each feature end point keeps a record of the best candidate
C	for moving onto, and of its distance away.
C
C	The (square) distance away is signed positive for PROJected
C	points and VRTXoints, and negative for PERPendicularly distanced
C	points, so that later on this information can be used to
C	determine the PROJ/VRTX/PERP class of any point.
C
C	Vector projection is given priority over moving onto vector ends
C	which is given priority over moving onto closest point along
C	vector - unless the VERTEX qualifier has been given, in which
C	case moving onto vector ends is given highest PRI
C
C	No end pt will ever be moved onto another pt that is within
C	EXTOL of the end-vector end. PPJOIN will join line ends.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

	LPJSUB = SS$_NORMAL	! assume success

C Set up vector components

	IP2 = IP1+1
	IQ2 = IQ1+1

	P1X = PT(1,IP1)
	P1Y = PT(2,IP1)
	P2X = PT(1,IP2)
	P2Y = PT(2,IP2)

	Q1X = PT(1,IQ1)
	Q1Y = PT(2,IQ1)
	Q2X = PT(1,IQ2)
	Q2Y = PT(2,IQ2)

C If vector boxes do not touch then do nothing

     	IF (.NOT.BOXINT(P1X,P1Y,P2X,P2Y,Q1X,Q1Y,Q2X,Q2Y,EXJNTOL))
     &	  GOTO 700				! return

	SQDIST_P1_PERP = -1
	SQDIST_P2_PERP = -1
	SQDIST_Q1_PERP = -1
	SQDIST_Q2_PERP = -1

	CAN_JOIN_P1_TO_PROJ = .FALSE.
	CAN_JOIN_P1_TO_VRTX = .FALSE.
	CAN_JOIN_P1_TO_PERP = .FALSE.
	
	CAN_JOIN_P2_TO_PROJ = .FALSE.
	CAN_JOIN_P2_TO_VRTX = .FALSE.
	CAN_JOIN_P2_TO_PERP = .FALSE.
	
	CAN_JOIN_Q1_TO_PROJ = .FALSE.
	CAN_JOIN_Q1_TO_VRTX = .FALSE.
	CAN_JOIN_Q1_TO_PERP = .FALSE.
	
	CAN_JOIN_Q2_TO_PROJ = .FALSE.
	CAN_JOIN_Q2_TO_VRTX = .FALSE.
	CAN_JOIN_Q2_TO_PERP = .FALSE.
	
	CANT_JOIN_P1_TO_PROJ = .FALSE.
	CANT_JOIN_P1_TO_VRTX = .FALSE.
	CANT_JOIN_P1_TO_PERP = .FALSE.
	
	CANT_JOIN_P2_TO_PROJ = .FALSE.
	CANT_JOIN_P2_TO_VRTX = .FALSE.
	CANT_JOIN_P2_TO_PERP = .FALSE.
	
	CANT_JOIN_Q1_TO_PROJ = .FALSE.
	CANT_JOIN_Q1_TO_VRTX = .FALSE.
	CANT_JOIN_Q1_TO_PERP = .FALSE.
	
	CANT_JOIN_Q2_TO_PROJ = .FALSE.
	CANT_JOIN_Q2_TO_VRTX = .FALSE.
	CANT_JOIN_Q2_TO_PERP = .FALSE.

C See if either vector is from a SYMBOL_STRING feature

	P_FROM_SYMBOL_STRING = .FALSE.
	Q_FROM_SYMBOL_STRING = .FALSE.

	IF (HAD_SYMBOL_STRING) THEN
	  IN_FTR = FTR_INFTR(PFTR)
	  P_FROM_SYMBOL_STRING = IN_FTR_STATUS(IN_FTR).EQ.SYMBOL_STRING

	  IN_FTR = FTR_INFTR(QFTR)
	  Q_FROM_SYMBOL_STRING = IN_FTR_STATUS(IN_FTR).EQ.SYMBOL_STRING
	END IF

C If both are from symbol_string ftrs then do nothing

	IF (P_FROM_SYMBOL_STRING.AND.Q_FROM_SYMBOL_STRING)
     &	  GOTO 700				! return

	IF (P_FROM_SYMBOL_STRING) THEN

C If IP is from a symbol_string ftr then set it up as an "end-vector"
C with a restricted range of possible joins

	  P1_IS_END = .TRUE.
	  P2_IS_END = .TRUE.

	  CANT_JOIN_P1_TO_PROJ = .TRUE.
	  CANT_JOIN_P1_TO_VRTX = .TRUE.
	  CANT_JOIN_P1_TO_PERP = .TRUE.

	  CANT_JOIN_P2_TO_PROJ = .TRUE.
	  CANT_JOIN_P2_TO_VRTX = .TRUE.
	  CANT_JOIN_P2_TO_PERP = .TRUE.

	  CANT_JOIN_Q1_TO_PROJ = .TRUE.
	  CANT_JOIN_Q1_TO_PERP = .TRUE.

	  CANT_JOIN_Q2_TO_PROJ = .TRUE.
	  CANT_JOIN_Q2_TO_PERP = .TRUE.

	ELSE

C See if vector from IP is at open-ftr end

	  P1_IS_END = PRV(IP1).EQ.NIL
	  P2_IS_END = NXT(IP2).EQ.NIL

	  IF (P1_IS_END.OR.P2_IS_END) THEN
	    IPTSTA = FTR_PTS(1,PFTR)
	    IPTFIN = FTR_PTS(2,PFTR)
	    CLOSED = PT(1,IPTSTA).EQ.PT(1,IPTFIN).AND.
     &	             PT(2,IPTSTA).EQ.PT(2,IPTFIN).AND.
     &	             NXT(IPTSTA).NE.IPTFIN
	    IF (CLOSED) THEN
	      P1_IS_END = .FALSE.
	      P2_IS_END = .FALSE.
	    END IF
	  END IF
	END IF

	IF (Q_FROM_SYMBOL_STRING) THEN

C If IQ is from a symbol_string ftr then set it up as an "end-vector"
C with a restricted range of possible joins

	  Q1_IS_END = .TRUE.
	  Q2_IS_END = .TRUE.

	  CANT_JOIN_Q1_TO_PROJ = .TRUE.
	  CANT_JOIN_Q1_TO_VRTX = .TRUE.
	  CANT_JOIN_Q1_TO_PERP = .TRUE.

	  CANT_JOIN_Q2_TO_PROJ = .TRUE.
	  CANT_JOIN_Q2_TO_VRTX = .TRUE.
	  CANT_JOIN_Q2_TO_PERP = .TRUE.

	  CANT_JOIN_P1_TO_PROJ = .TRUE.
	  CANT_JOIN_P1_TO_PERP = .TRUE.

	  CANT_JOIN_P2_TO_PROJ = .TRUE.
	  CANT_JOIN_P2_TO_PERP = .TRUE.

	ELSE

C See if vector from IQ is at open-ftr end

	  Q1_IS_END = PRV(IQ1).EQ.NIL
	  Q2_IS_END = NXT(IQ2).EQ.NIL

	  IF (Q1_IS_END.OR.Q2_IS_END) THEN
	    IPTSTA = FTR_PTS(1,QFTR)
	    IPTFIN = FTR_PTS(2,QFTR)
	    CLOSED = PT(1,IPTSTA).EQ.PT(1,IPTFIN).AND.
     &	             PT(2,IPTSTA).EQ.PT(2,IPTFIN).AND.
     &	             NXT(IPTSTA).NE.IPTFIN
	    IF (CLOSED) THEN
	      Q1_IS_END = .FALSE.
	      Q2_IS_END = .FALSE.
	    END IF
	  END IF
	END IF

	Q_IS_END = Q1_IS_END.OR.Q2_IS_END
	P_IS_END = P1_IS_END.OR.P2_IS_END

C Do nothing if neither vector is an open-ftr end vector

	IF (.NOT.(P_IS_END.OR.Q_IS_END)) GOTO 700	! return

C See if either ftr is single point ftr

	P_IS_POINT = PNT_FTR(PFTR)
	Q_IS_POINT = PNT_FTR(QFTR)

C If both are single point ftrs then return

	IF (P_IS_POINT.AND.Q_IS_POINT) GOTO 700		! return

C Set up vector lengths

	P1P2X = P2X-P1X			! P1P2
	P1P2Y = P2Y-P1Y
	DP1P2SQ = P1P2X**2+P1P2Y**2
	IF (DP1P2SQ.LT.COORD_TOL**2.AND..NOT.P_IS_POINT) GOTO 700 ! return

	Q1Q2X = Q2X-Q1X			! Q1Q2
	Q1Q2Y = Q2Y-Q1Y
	DQ1Q2SQ = Q1Q2X**2+Q1Q2Y**2
	IF (DQ1Q2SQ.LT.COORD_TOL**2.AND..NOT.Q_IS_POINT) GOTO 700 ! return

	P1Q1X = Q1X-P1X			! P1Q1
	P1Q1Y = Q1Y-P1Y
	DP1Q1SQ = P1Q1X**2+P1Q1Y**2

	P2Q1X = Q1X-P2X			! P2Q1
	P2Q1Y = Q1Y-P2Y
	DP2Q1SQ = P2Q1X**2+P2Q1Y**2

	P2Q2X = Q2X-P2X			! P2Q2
	P2Q2Y = Q2Y-P2Y
	DP2Q2SQ = P2Q2X**2+P2Q2Y**2

	P1Q2X = Q2X-P1X			! P1Q2
	P1Q2Y = Q2Y-P1Y
	DP1Q2SQ = P1Q2X**2+P1Q2Y**2

C If one is 1-pt ftr (& other is not) then only look for VRTXs or PERPs

	IF (P_IS_POINT.OR.Q_IS_POINT) THEN
	  CANT_JOIN_P1_TO_PROJ = .TRUE.
	  CANT_JOIN_P2_TO_PROJ = .TRUE.
	  CANT_JOIN_Q1_TO_PROJ = .TRUE.
	  CANT_JOIN_Q2_TO_PROJ = .TRUE.

	  IF (P_IS_POINT) THEN
	    CANT_JOIN_Q1_TO_VRTX = .TRUE.
	    CANT_JOIN_Q2_TO_VRTX = .TRUE.
	    CANT_JOIN_Q1_TO_PERP = .TRUE.
	    CANT_JOIN_Q2_TO_PERP = .TRUE.
	  ELSE
	    CANT_JOIN_P1_TO_VRTX = .TRUE.
	    CANT_JOIN_P2_TO_VRTX = .TRUE.
	    CANT_JOIN_P1_TO_PERP = .TRUE.
	    CANT_JOIN_P2_TO_PERP = .TRUE.
	  END IF

	  GOTO 100
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C Find intersection between lines containing P12 and Q12

	LINES_INTERSECT
     &	 = LININT(	P1X,P1Y,P2X,P2Y,
     &			Q1X,Q1Y,Q2X,Q2Y,
     &			PF,QF,X,Y,
     &	        	PARALLEL,INT_ON_PVEC,INT_ON_QVEC,
     &			IEND1,IEND2,
     &			E1X,E1Y,E2X,E2Y)

	IF (PARALLEL) THEN
	  CANT_JOIN_P1_TO_PROJ = .TRUE.
	  CANT_JOIN_P2_TO_PROJ = .TRUE.
	  CANT_JOIN_Q1_TO_PROJ = .TRUE.
	  CANT_JOIN_Q2_TO_PROJ = .TRUE.
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C Decide which joins are possible

100	IF (.NOT.P1_IS_END) GOTO 150

C Get end point join- and extension- tolerance

	IPAC = LIN_PAC(CC(IP1))
	P1_JNTOL = PAC_JNTOL(IPAC)
	P1_EXTOL = PAC_EXTOL(IPAC)

C See if P1 will join to PROJ

	IF (INT_ON_QVEC.AND..NOT.CANT_JOIN_P1_TO_PROJ) THEN
	  SQDIST_P1_PROJ = (X-P1X)**2+(Y-P1Y)**2
	  CAN_JOIN_P1_TO_PROJ = SQDIST_P1_PROJ.LE.P1_EXTOL**2.AND.
     &	                        PF.LE.ONEMINUS
	  IF (CAN_JOIN_P1_TO_PROJ) THEN
	    X_P1_PROJ = X
	    Y_P1_PROJ = Y
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if P1 will join to VRTX

	IF (.NOT.CANT_JOIN_P1_TO_VRTX) THEN
	  IF (DP1Q1SQ.LT.DP1Q2SQ) THEN
	    SQDIST_P1_VRTX = DP1Q1SQ
	    X_P1_VRTX = Q1X
	    Y_P1_VRTX = Q1Y
	  ELSE	    
	    SQDIST_P1_VRTX = DP1Q2SQ
	    X_P1_VRTX = Q2X
	    Y_P1_VRTX = Q2Y
	  END IF
	  CAN_JOIN_P1_TO_VRTX = SQDIST_P1_VRTX.LT.P1_JNTOL**2
	END IF

	IF (CAN_JOIN_P1_TO_VRTX) GOTO 150

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if P1 will join to PERP

	IF (.NOT.CANT_JOIN_P1_TO_PERP) THEN
	  TF = -(P1Q1X*Q1Q2X+P1Q1Y*Q1Q2Y)/DQ1Q2SQ
	  IF (TF.GE.ZEROPLUS.AND.TF.LE.ONEMINUS) THEN
	    X_P1_PERP = Q1X+TF*Q1Q2X
	    Y_P1_PERP = Q1Y+TF*Q1Q2Y
	    SQDIST_P1_PERP = (X_P1_PERP-P1X)**2+(Y_P1_PERP-P1Y)**2
	    CAN_JOIN_P1_TO_PERP = SQDIST_P1_PERP.LT.P1_JNTOL**2
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

150	IF (P_IS_POINT.OR..NOT.P2_IS_END) GOTO 200

C Get end point join- and extension- tolerance

	IPAC = LIN_PAC(CC(IP2))
	P2_JNTOL = PAC_JNTOL(IPAC)
	P2_EXTOL = PAC_EXTOL(IPAC)

C See if P2 will join to PROJ

	IF (INT_ON_QVEC.AND..NOT.CANT_JOIN_P2_TO_PROJ) THEN
	  SQDIST_P2_PROJ = (X-P2X)**2+(Y-P2Y)**2
	  CAN_JOIN_P2_TO_PROJ = SQDIST_P2_PROJ.LE.P2_EXTOL**2.AND.
     &	                        PF.GE.ZEROPLUS
	  IF (CAN_JOIN_P2_TO_PROJ) THEN
	    X_P2_PROJ = X
	    Y_P2_PROJ = Y
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if P2 will join to VRTX

	IF (.NOT.CANT_JOIN_P2_TO_VRTX) THEN
	  IF (DP2Q1SQ.LT.DP2Q2SQ) THEN
	    SQDIST_P2_VRTX = DP2Q1SQ
	    X_P2_VRTX = Q1X
	    Y_P2_VRTX = Q1Y
	  ELSE	    
	    SQDIST_P2_VRTX = DP2Q2SQ
	    X_P2_VRTX = Q2X
	    Y_P2_VRTX = Q2Y
	  END IF
	  CAN_JOIN_P2_TO_VRTX = SQDIST_P2_VRTX.LT.P2_JNTOL**2
	END IF

	IF (CAN_JOIN_P2_TO_VRTX) GOTO 200

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if P2 will join to PERP

	IF (.NOT.CANT_JOIN_P2_TO_PERP) THEN
	  TF = -(P2Q1X*Q1Q2X+P2Q1Y*Q1Q2Y)/DQ1Q2SQ
	  IF (TF.GE.ZEROPLUS.AND.TF.LE.ONEMINUS) THEN
	    X_P2_PERP = Q1X+TF*Q1Q2X
	    Y_P2_PERP = Q1Y+TF*Q1Q2Y
	    SQDIST_P2_PERP = (X_P2_PERP-P2X)**2+(Y_P2_PERP-P2Y)**2
	    CAN_JOIN_P2_TO_PERP = SQDIST_P2_PERP.LT.P2_JNTOL**2
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

200	IF (.NOT.Q1_IS_END) GOTO 250

C Get end point join- and extension- tolerance

	IPAC = LIN_PAC(CC(IQ1))
	Q1_JNTOL = PAC_JNTOL(IPAC)
	Q1_EXTOL = PAC_EXTOL(IPAC)

C See if Q1 will join to PROJ

	IF (INT_ON_PVEC.AND..NOT.CANT_JOIN_Q1_TO_PROJ) THEN
	  SQDIST_Q1_PROJ = (X-Q1X)**2+(Y-Q1Y)**2
	  CAN_JOIN_Q1_TO_PROJ = SQDIST_Q1_PROJ.LE.Q1_EXTOL**2.AND.
     &	                        QF.LE.ONEMINUS
	  IF (CAN_JOIN_Q1_TO_PROJ) THEN
	    X_Q1_PROJ = X
	    Y_Q1_PROJ = Y
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if Q1 will join to VRTX

	IF (.NOT.CANT_JOIN_Q1_TO_VRTX) THEN
	  IF (DP1Q1SQ.LT.DP2Q1SQ) THEN
	    SQDIST_Q1_VRTX = DP1Q1SQ
	    X_Q1_VRTX = P1X
	    Y_Q1_VRTX = P1Y
	  ELSE	    
	    SQDIST_Q1_VRTX = DP2Q1SQ
	    X_Q1_VRTX = P2X
	    Y_Q1_VRTX = P2Y
	  END IF
	  CAN_JOIN_Q1_TO_VRTX = SQDIST_Q1_VRTX.LT.Q1_JNTOL**2
	END IF

	IF (CAN_JOIN_Q1_TO_VRTX) GOTO 250

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if Q1 will join to PERP

	IF (.NOT.CANT_JOIN_Q1_TO_PERP) THEN
	  TF = (P1Q1X*P1P2X+P1Q1Y*P1P2Y)/DP1P2SQ
	  IF (TF.GE.ZEROPLUS.AND.TF.LE.ONEMINUS) THEN
	    X_Q1_PERP = P1X+TF*P1P2X
	    Y_Q1_PERP = P1Y+TF*P1P2Y
	    SQDIST_Q1_PERP = (X_Q1_PERP-Q1X)**2+(Y_Q1_PERP-Q1Y)**2
	    CAN_JOIN_Q1_TO_PERP = SQDIST_Q1_PERP.LT.Q1_JNTOL**2
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

250	IF (Q_IS_POINT.OR..NOT.Q2_IS_END) GOTO 300

C Get end point join- and extension- tolerance

	IPAC = LIN_PAC(CC(IQ2))
	Q2_JNTOL = PAC_JNTOL(IPAC)
	Q2_EXTOL = PAC_EXTOL(IPAC)

C See if Q2 will join to PROJ

	IF (INT_ON_PVEC.AND..NOT.CANT_JOIN_Q2_TO_PROJ) THEN
	  SQDIST_Q2_PROJ = (X-Q2X)**2+(Y-Q2Y)**2
	  CAN_JOIN_Q2_TO_PROJ = SQDIST_Q2_PROJ.LE.Q2_EXTOL**2.AND.
     &	                        QF.GE.ZEROPLUS
	  IF (CAN_JOIN_Q2_TO_PROJ) THEN
	    X_Q2_PROJ = X
	    Y_Q2_PROJ = Y
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if Q2 will join to VRTX

	IF (.NOT.CANT_JOIN_Q2_TO_VRTX) THEN
	  IF (DP1Q2SQ.LT.DP2Q2SQ) THEN
	    SQDIST_Q2_VRTX = DP1Q2SQ
	    X_Q2_VRTX = P1X
	    Y_Q2_VRTX = P1Y
	  ELSE	    
	    SQDIST_Q2_VRTX = DP2Q2SQ
	    X_Q2_VRTX = P2X
	    Y_Q2_VRTX = P2Y
	  END IF
	  CAN_JOIN_Q2_TO_VRTX = SQDIST_Q2_VRTX.LT.Q2_JNTOL**2
	END IF

	IF (CAN_JOIN_Q2_TO_VRTX) GOTO 300

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C See if Q2 will join to PERP

	IF (.NOT.CANT_JOIN_Q2_TO_PERP) THEN
	  TF = (P1Q2X*P1P2X+P1Q2Y*P1P2Y)/DP1P2SQ
	  IF (TF.GE.ZEROPLUS.AND.TF.LE.ONEMINUS) THEN
	    X_Q2_PERP = P1X+TF*P1P2X
	    Y_Q2_PERP = P1Y+TF*P1P2Y
	    SQDIST_Q2_PERP = (X_Q2_PERP-Q2X)**2+(Y_Q2_PERP-Q2Y)**2
	    CAN_JOIN_Q2_TO_PERP = SQDIST_Q2_PERP.LT.Q2_JNTOL**2
	  END IF
	END IF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C Decide which points are best to connect to

300	P1_PRI = 0
	P2_PRI = 0
	Q1_PRI = 0
	Q2_PRI = 0

	IF (CAN_JOIN_P1_TO_PROJ) P1_PRI = MAX(P1_PRI,PROJ_PRI)
	IF (CAN_JOIN_P1_TO_VRTX) P1_PRI = MAX(P1_PRI,VRTX_PRI)
	IF (CAN_JOIN_P1_TO_PERP) P1_PRI = MAX(P1_PRI,PERP_PRI)

	IF (CAN_JOIN_P2_TO_PROJ) P2_PRI = MAX(P2_PRI,PROJ_PRI)
	IF (CAN_JOIN_P2_TO_VRTX) P2_PRI = MAX(P2_PRI,VRTX_PRI)
	IF (CAN_JOIN_P2_TO_PERP) P2_PRI = MAX(P2_PRI,PERP_PRI)

	IF (CAN_JOIN_Q1_TO_PROJ) Q1_PRI = MAX(Q1_PRI,PROJ_PRI)
	IF (CAN_JOIN_Q1_TO_VRTX) Q1_PRI = MAX(Q1_PRI,VRTX_PRI)
	IF (CAN_JOIN_Q1_TO_PERP) Q1_PRI = MAX(Q1_PRI,PERP_PRI)

	IF (CAN_JOIN_Q2_TO_PROJ) Q2_PRI = MAX(Q2_PRI,PROJ_PRI)
	IF (CAN_JOIN_Q2_TO_VRTX) Q2_PRI = MAX(Q2_PRI,VRTX_PRI)
	IF (CAN_JOIN_Q2_TO_PERP) Q2_PRI = MAX(Q2_PRI,PERP_PRI)

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

	IF (P1_PRI.EQ.0) GOTO 400

C Select candidate point with highest priority

	IF (P1_PRI.EQ.PROJ_PRI) THEN
	  X = X_P1_PROJ
	  Y = Y_P1_PROJ
	  SQDIST = SQDIST_P1_PROJ
	ELSE IF (P1_PRI.EQ.VRTX_PRI) THEN
	  X = X_P1_VRTX
	  Y = Y_P1_VRTX
	  SQDIST = SQDIST_P1_VRTX
	ELSE IF (P1_PRI.EQ.PERP_PRI) THEN
	  X = X_P1_PERP
	  Y = Y_P1_PERP
	  SQDIST = SQDIST_P1_PERP
	END IF

C Join to new candidate point if first point or better than previous

	LPJSUB = CHECK_MAP(
     &			IP1,IQ1,QFTR,X,Y,P1_PRI,SQDIST,
     &			PT,PRV,NXT,
     &			%VAL(NEAREST_START),
     &			%VAL(MINSQDIST_START),
     &			MAXPTS_CMN)
	IF (.NOT.LPJSUB) GOTO 700

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

400	IF (P2_PRI.EQ.0) GOTO 500

	IF (P2_PRI.EQ.PROJ_PRI) THEN
	  X = X_P2_PROJ
	  Y = Y_P2_PROJ
	  SQDIST = SQDIST_P2_PROJ
	ELSE IF (P2_PRI.EQ.VRTX_PRI) THEN
	  X = X_P2_VRTX
	  Y = Y_P2_VRTX
	  SQDIST = SQDIST_P2_VRTX
	ELSE IF (P2_PRI.EQ.PERP_PRI) THEN
	  X = X_P2_PERP
	  Y = Y_P2_PERP
	  SQDIST = SQDIST_P2_PERP
	END IF

	LPJSUB = CHECK_MAP(
     &			IP2,IQ1,QFTR,X,Y,P2_PRI,SQDIST,
     &			PT,PRV,NXT,
     &			%VAL(NEAREST_START),
     &			%VAL(MINSQDIST_START),
     &			MAXPTS_CMN)
	IF (.NOT.LPJSUB) GOTO 700

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

500	IF (Q1_PRI.EQ.0) GOTO 600

	IF (Q1_PRI.EQ.PROJ_PRI) THEN
	  X = X_Q1_PROJ
	  Y = Y_Q1_PROJ
	  SQDIST = SQDIST_Q1_PROJ
	ELSE IF (Q1_PRI.EQ.VRTX_PRI) THEN
	  X = X_Q1_VRTX
	  Y = Y_Q1_VRTX
	  SQDIST = SQDIST_Q1_VRTX
	ELSE IF (Q1_PRI.EQ.PERP_PRI) THEN
	  X = X_Q1_PERP
	  Y = Y_Q1_PERP
	  SQDIST = SQDIST_Q1_PERP
	END IF

	LPJSUB = CHECK_MAP(
     &			IQ1,IP1,PFTR,X,Y,Q1_PRI,SQDIST,
     &			PT,PRV,NXT,
     &			%VAL(NEAREST_START),
     &			%VAL(MINSQDIST_START),
     &			MAXPTS_CMN)
	IF (.NOT.LPJSUB) GOTO 700

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

600	IF (Q2_PRI.EQ.0) GOTO 700

	IF (Q2_PRI.EQ.PROJ_PRI) THEN
	  X = X_Q2_PROJ
	  Y = Y_Q2_PROJ
	  SQDIST = SQDIST_Q2_PROJ
	ELSE IF (Q2_PRI.EQ.VRTX_PRI) THEN
	  X = X_Q2_VRTX
	  Y = Y_Q2_VRTX
	  SQDIST = SQDIST_Q2_VRTX
	ELSE IF (Q2_PRI.EQ.PERP_PRI) THEN
	  X = X_Q2_PERP
	  Y = Y_Q2_PERP
	  SQDIST = SQDIST_Q2_PERP
	END IF

	LPJSUB = CHECK_MAP(
     &			IQ2,IP1,PFTR,X,Y,Q2_PRI,SQDIST,
     &			PT,PRV,NXT,
     &			%VAL(NEAREST_START),
     &			%VAL(MINSQDIST_START),
     &			MAXPTS_CMN)
	IF (.NOT.LPJSUB) GOTO 700

700	IF (LPJSUB) LPJSUB = SS$_NORMAL
	RETURN
	END

