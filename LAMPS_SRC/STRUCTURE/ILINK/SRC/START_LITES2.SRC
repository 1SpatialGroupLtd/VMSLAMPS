	INTEGER*4 FUNCTION START_LITES2(LUN,DRANGE,CMDSTR,CMDLEN,IERR)
C
***	MODULE	START_LITES2
***	IDENT	13JL92
C
C	Copyright Laser-Scan Ltd., Cambridge, England
C
C	Author						TJH  15-Apr-1987
C
C	Pinched and renamed (from START_LCM) for ILINK to output 
C	ABSOLUTE coords	 				 JB  04-Nov-1991
C
C Function to create a standard IMP pattern log file header.
C
C Function returns one of:
C
C		LSL__NORMAL  - all is well
C		LSL__SYSERR  - failed - system message in IERR
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER*2	LUN	! the LUN of the output file
	REAL		DRANGE(4)! data extent
	CHARACTER*(*)	CMDSTR	! the command line to be printed out
C
C Optional arguments:
	INTEGER	        CMDLEN	! length of command line
	INTEGER	        IERR	! system error return
C
C Parameters:
	INCLUDE '($SSDEF)'
	INCLUDE 'LSL$CMNLSL:LSLLIBMSG.PAR'
	INCLUDE 'LSL$CMNIFF:MD2DES.CMN'
	INCLUDE	'LSL$CMNILINK:ILINK.CMN'
C
C Workspace:
	INTEGER		CLEN	! temp. cmd line length
	CHARACTER*80	TITSTR	! title string
	INTEGER	        TITLEN	! length of title string
	CHARACTER*80	JPISTR	! the GETJPI line to be printed out
	INTEGER	        JPILEN	! length of GETJPI line
	INTEGER 	ERRET	! error return
	INTEGER		I,J	! temporary variables
	INTEGER	ISTART,IEND	! temp. vars.
C
C Functions:
	INTEGER EXPAND
	LOGICAL HAVE_I_AN_ARG	! is optional argument present?
	INTEGER SYS$GETJPIW	! get Job/Process Information
	INTEGER PREP_INFO	! prepares data for header
C
C ......................................................................
C
	TITLEN=70
	IF (HAVE_I_AN_ARG(4)) THEN
	   CLEN=CMDLEN
	ELSE
	   CLEN=LEN(CMDSTR)
	ENDIF
C
C Prepare all the data for output - get process info and uppercase and
C remove any trailing spaces from cmd line string
	START_LITES2=PREP_INFO(CMDSTR,CLEN,TITSTR,TITLEN,
     &					JPISTR,JPILEN,ERRET)
	IF (.NOT.START_LITES2) GOTO 40
C
C If optional 4th argument supplied, return cmd string length less any
C trailing spaces
	IF (HAVE_I_AN_ARG(4)) THEN
	   CMDLEN=CLEN
	ENDIF
C
C and write out all the info
	CALL FLWSEL(LUN)
C
	IF (HAD_ABS) THEN
	  CALL FLWRTF('%%ABSOLUTE %^D%F %^D%F',DRANGE(1)+MD2LOC(1),
     &					       DRANGE(3)+MD2LOC(2))
	  CALL FLWRTF('%%ABSOLUTE %^D%F %^D%F',DRANGE(2)+MD2LOC(1),
     &					       DRANGE(4)+MD2LOC(2))
	ELSE
	  CALL FLWRTF('%%POSITION %F %F',DRANGE(1),DRANGE(3))
	  CALL FLWRTF('%%POSITION %F %F',DRANGE(2),DRANGE(4))
	ENDIF
C
	CALL FLWRTF('%%ABANDON')
	CALL FLWRTF('%%MESSAGE ')
	CALL FLWRTF('%%MESSAGE                L I T E S 2   '//
     &			'C O M M A N D   F I L E')
	CALL FLWRTF('%%MESSAGE ')
	CALL FLWRTF('%%MESSAGE                              created by')
	CALL FLWRTF('%%MESSAGE ')
	TITSTR='%MESSAGE '//TITSTR(:TITLEN)
	TITLEN=TITLEN+9
	CALL FLWSTR(TITSTR,TITLEN)
	CALL FLWRTF('%%MESSAGE ')
	JPISTR='%MESSAGE '//JPISTR(:JPILEN)
	JPILEN=JPILEN+9
	CALL FLWSTR(JPISTR,JPILEN)
C
	CALL FLWRTF('%%MESSAGE  ')
	CALL FLWRTF('%%MESSAGE Command line:')
	CALL FLWRTF('%%MESSAGE  ')
C
C Now output the command line. Look for suitable breaks if more than
C 68 characters long.
	IEND=0
	ISTART=1
10	DO 20 I=MIN(CLEN,IEND+69)+1,ISTART,-1
	   J=I
	   IF(CMDSTR(I:I).EQ.' '.OR.CMDSTR(I:I).EQ.','.OR.I.EQ.CLEN)THEN
	      GOTO 30
     	   ELSEIF (CMDSTR(I:I).EQ.'/') THEN
	      J=J-1
	      GOTO 30
	   ENDIF
20	CONTINUE
C
C And output each chunck
30	IEND=J
	CALL FLWRTF('%%MESSAGE %S',CMDSTR(ISTART:IEND))
	ISTART=IEND+1
C
C and possibly loop back for the rest of the command line
	IF (ISTART.LT.CLEN) GOTO 10
	CALL FLWRTF('%%MESSAGE ')
	CALL FLWRTF('%%MESSAGE ======================================'//
     &			'================================')
	CALL FLWRTF('%%MESSAGE ')
	CALL FLWRTF('%%ABANDON')
	CALL FLWRTF('%%ABANDON')
C
C ......................................................................
C
40	IF (START_LITES2) THEN
	   START_LITES2=LSL__NORMAL
	   IF (HAVE_I_AN_ARG(5)) THEN
	      IERR=SS$_NORMAL
	   ENDIF
	ELSE
	   START_LITES2=LSL__SYSERR
	   IF (HAVE_I_AN_ARG(5)) THEN
	      IERR=ERRET
	   ENDIF
	ENDIF
C
	RETURN
	END
C
