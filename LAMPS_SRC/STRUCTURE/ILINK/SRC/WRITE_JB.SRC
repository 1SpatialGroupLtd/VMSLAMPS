	LOGICAL FUNCTION WRITE_JB(
     &		FTR_PTS,FTR_DAT,PNT_FTR,
     &		NPT,NOD_ADDR,HEADARM,ARM,
     &		MAXOUTFTRS,MAXNODES,MAXARMS)

***	MODULE	WRITE_JB
***	IDENT	22MR93

C	Copyright : Laser-Scan Ltd., Cambridge, England

CMOD1210 Find address of final CB properly (Notts U)	PGH 22-Mar-1993
CMOD1060 Use absolute coords if requested		 JB 07-Nov-1991
CMOD	Use MAXAPJ to limit arms to IFF junction limit	WJJ 02-Feb-1990
CMOD	Introduced FREE_ENDS qualifier,
C	superseding ONEARM				ACM 12-Dec-1988
CMOD	Changed to fail if number of arms found at a
C	junction is > MAXAPN				ACM 18-Aug-1987
CMOD	Changes to point to particular ST in which junction
C	lies, rather than simply to the first ST in the
C	feature.					ACM 18-Aug-1987
CMOD	Now outputs a LITES2 message if /ONEARM
C	specified and node has only one arm		TJH 12-Jun-1987
CMOD	ADC inclusions now done with Fortran INCLUDE	TJH 29-May-1987

C	Created   : ACM					     Month 1986

	IMPLICIT NONE

C Parameters
	INCLUDE		'($SSDEF)'


	INCLUDE		'LSL$CMNILINK:ILINKMSG.PAR'

	INTEGER*4	MAXPTS
	INTEGER*4	ST_HDR_LEN
	INTEGER*4	MAX_ST_LEN

	PARAMETER(	MAXPTS = 200)
	PARAMETER(	ST_HDR_LEN = 2)
	PARAMETER(	MAX_ST_LEN = ST_HDR_LEN+4*MAXPTS)

C Commons
	INCLUDE		'LSL$CMNIFF:IFFHAN.CMN'
	INCLUDE		'LSL$CMNIFF:IFFJUN.CMN'
	INCLUDE		'LSL$CMNIFF:MD2DES.CMN'
	INCLUDE		'LSL$CMNILINK:ILINK.CMN'

C Data in
	INTEGER*4	MAXOUTFTRS,MAXARMS,MAXNODES
	INTEGER*4	FTR_PTS(2,MAXOUTFTRS)
	INTEGER*4	FTR_DAT(2,MAXOUTFTRS)
	INTEGER*4	NOD_ADDR(2,MAXNODES)
	INTEGER*4	HEADARM(MAXNODES)
	INTEGER*4	ARM(2,MAXARMS)

	LOGICAL*1	PNT_FTR(MAXOUTFTRS)

	REAL*4		NPT(2,MAXNODES)

C Workspace
	INTEGER*4	I		! loop counter
	INTEGER*4	IPT		! point index
	INTEGER*4	IPTSTA,IPTFIN	! ftr end pts
	INTEGER*4	IFTR,ABSIFTR	! ftr index
	INTEGER*4	STPOS		! ST IFF address in wrds
	INTEGER*4	NPTS		! No. of pts in ftr
	INTEGER*4	IARM,JARM	! arm indices
	INTEGER*4	INODE		! node index
	INTEGER*4	N_PROPER_ARMS	! proper arms at a node
	INTEGER*4	FIRST_ADDR	! address of first ST in ftr
	INTEGER*4	LAST_ADDR	! address of last ST in ftr
	INTEGER*4	REM_PTS		! No of pts in last ST
	INTEGER*4	N_CONTIN_STS	! No of continuation STs
	INTEGER*4	NOPTR		! NO-entry IFF address

	INTEGER*2	IECODE,IELEN	! for IFFPKE
	INTEGER*2	SECTOR		! IFF sector index
	INTEGER*2	MAXSECTOR	! max val for SECTOR
	INTEGER*2	NARMS		! No. of arms at a node
	INTEGER*2	WARMS		! No. of arms written at a node
	INTEGER*2	FSN,ISN		! for IFFNF
	INTEGER*2	ISTAT(4)	! for IFFFS
	DATA 		ISTAT/4*0/

	REAL*4		X,Y			! node coords
	REAL*4		PCENT,LPCENT,PCF	! % process completion

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	If had /STRUCTURE qualifier then
C		writes Junction Block entry containing all node
C		positions and pointers from each node to arms arriving
C		at it.
C	else if had /FREE_ENDS qualifier then
C		writes point features for each free-end (1-arm node)
C		to layer FREE_ENDS_LAYER and with feature code
C		FREE_ENDS_FC.
C
C	Also counts number of arms at each node.
C
C	Note that point-features need to have "Junctions" to point to
C	also, so that:
C	1)	they can be accessed within the link/node structure,
C	2)	a list of all feature start/end points can easily be
C	        generated by going through the JB entry.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

	WRITE_JB = SS$_NORMAL

	IF (.NOT.HAD_VERIFY) CALL IFFSEL(OUTLUN)

	N_NODES_OUTPUT = 0
	N_PROPER_ARMS_OUTPUT = 0
	N_1_NODES = 0
	N_2_NODES = 0
	N_3_NODES = 0
	N_4_NODES = 0
	N_5PLUS_NODES = 0

	MAXSECTOR = NXSECTORS*NYSECTORS

	PCF = 100.0/N_NODES
	PCENT = 0
	LPCENT = 0

	IF (HAD_STRUCTURE) THEN
	  CALL WRITEF('	Writing node-to-link pointers')
	ELSE
	  CALL EXPAND(' Counting arms-per-node')
	  IF (HAD_FREE_ENDS_LAYER)
     &	    CALL APPEND(' and writing FREE_ENDS layer')
	  CALL TTWLIN
	END IF

	IF (HAD_FREE_ENDS_LAYER) THEN
	  NOPTR = LPOSE				! write NO entry
	  CALL IFFNO(FREE_ENDS_LAYER,0,0)
	  ISTAT(1) = FREE_ENDS_FC		! free-ends feature code
	  CBH.FLAGS = 0				! pen up
	  CBH.GTYPE = 7				! point feature
	  CBH.NROW = 1				! one point
	  CBH.NCOL = 2				! 2 coordinates
	  CBH.NATT = 0				! no fixed attributes
	  CBH.COLH(1) = IFF_C_X			! 1st coord is X
	  CBH.COLH(2) = IFF_C_Y			! 2nd coord is Y
	END IF

	IF (HAD_MONITOR) WRITE(*,'(1X,F6.1,''%'')') PCENT

	DO 70 INODE = 1,N_NODES

C Find how many arms this node has

	  NARMS = 0
	  N_PROPER_ARMS = 0
	  IARM = HEADARM(INODE)			! index of 1st arm
	  GOTO 20
10	  IARM = ARM(ARM_NXT,IARM)		! index of next arm
20	  IF (IARM.EQ.NIL) GOTO 30		! no more arms

C Don't count arms corresponding to deleted ftrs

	  IFTR = ABS(ARM(ARM_FTR,IARM))
	  IF (NEED_DATA_PER_POINT) THEN
	    IPTSTA = FTR_PTS(1,IFTR)
	    IF (IPTSTA.EQ.NIL) GOTO 10 		! ftr deleted
	    IPTFIN = FTR_PTS(2,IFTR)
	  END IF
	  NARMS = NARMS+1

C Don't count arms connecting pt-ftrs

	  IF (NEED_DATA_PER_POINT) THEN
	    IF (IPTSTA.EQ.IPTFIN) GOTO 10	! point-ftr
	  END IF
	  IF (PNT_FTR(IFTR)) GOTO 10		! point-ftr
	  N_PROPER_ARMS = N_PROPER_ARMS+1
	  GOTO 10

30	  IF (NARMS.EQ.0) GOTO 70		! ignore 0-arm nodes

C Count nodes of each degree

	  N_PROPER_ARMS_OUTPUT = N_PROPER_ARMS_OUTPUT+N_PROPER_ARMS

	  IF (N_PROPER_ARMS.EQ.0) THEN
	    N_0_NODES = N_0_NODES+1
	  ELSE IF (N_PROPER_ARMS.EQ.1) THEN
	    N_1_NODES = N_1_NODES+1
	  ELSE IF (N_PROPER_ARMS.EQ.2) THEN
	    N_2_NODES = N_2_NODES+1
	  ELSE IF (N_PROPER_ARMS.EQ.3) THEN
	    N_3_NODES = N_3_NODES+1
	  ELSE IF (N_PROPER_ARMS.EQ.4) THEN
	    N_4_NODES = N_4_NODES+1
	  ELSE
	    N_5PLUS_NODES = N_5PLUS_NODES+1
	  END IF

C Count nodes output

	  N_NODES_OUTPUT = N_NODES_OUTPUT+1

C Create new node entry

	  X = NPT(1,INODE)
	  Y = NPT(2,INODE)

	  IF (N_PROPER_ARMS.EQ.1) THEN

C If /FREE_ENDS specified and junction has only one arm then give
C position to user 
	    IF (HAD_FREE_ENDS) THEN
	      CALL LSL_PUTMSG(ILINK__FREE_ENDS,X,Y)

C Report to LITES2 command file if /LITES2 specified

	      IF (HAD_LITES2) THEN
	        CALL FLWSEL(LITES2LUN)
	        CALL FLWRTF('%%MESSAGE Node has only one arm')

		IF (HAD_ABS) THEN
		  CALL FLWRTF('%%ABSOLUTE %^D%F %^D%F',X+MD2LOC(1),
     &						       Y+MD2LOC(2))
		ELSE
		  CALL FLWRTF('%%POSITION %F %F',X,Y)
		ENDIF

	        CALL FLWRTF('%%TEST $CURSINWIN')
	        CALL FLWRTF('%%ELSE %%ZOOM 1')
	        CALL FLWRTF('%%PING')
	        CALL FLWRTF('%%RESPOND')
	        CALL FLWRTF('%%ABANDON')
	        CALL FLWRTF('%%ABANDON')
	      END IF
	    END IF

	    IF (HAD_FREE_ENDS_LAYER) THEN
	      ISN = 0				! NF entry
	      N_OT_FTRS = N_OT_FTRS+1
	      CALL IFFNF(N_OT_FTRS,ISN)
	      CALL IFFFS(ISTAT)			! FS entry
	      CBD.R(1) = X			! CB entry
	      CBD.R(2) = Y
	      CALL IFFCB(CBH,CBD)
	      CALL IFFEF			! EF entry
	    END IF
	  END IF

C Skip next bit if not outputting junctions

	  IF (.NOT.HAD_STRUCTURE) GOTO 60

C Check number of arms is not too excessive

	  IF (NARMS.GT.MAXAPJ) THEN
	    WRITE_JB = ILINK__TOOMNYAPJ
	    CALL LSL_PUTMSG(WRITE_JB,MAXAPJ)
	    GOTO 80				! return
	  END IF

C Find sector index

	  CALL IFJSEC(X,Y,SECTOR)
	  SECTOR = MAX(1,MIN(SECTOR,MAXSECTOR))

C Create junction record

	  CALL IFJCR(SECTOR,X,Y,NARMS)

C Catch any other error which may occur in IFJCR

	  IF (IERCD.NE.0) THEN
	    WRITE_JB = ILINK__INTRNLERR
	    CALL LSL_PUTMSG(WRITE_JB,1,'WRITE_JB')
	    GOTO 80				! return
	  END IF

C Note its JB position and junction offset for use when filling in JP
C entries later on in FILL_OUT_JPS

	  NOD_ADDR(NOD_JB,INODE) = LPOSH
	  NOD_ADDR(NOD_JO,INODE) = IFPOSJ

C Fill out arm fields

	  NARMS = 0
	  IARM = HEADARM(INODE)			! index of 1st arm
	  GOTO 50
40	  IARM = ARM(ARM_NXT,IARM)		! index of next arm
50	  IF (IARM.EQ.NIL) GOTO 60		! no more arms

	  IFTR = ARM(ARM_FTR,IARM)
	  ABSIFTR = ABS(IFTR)

C Ftr deleted?

	  IF (NEED_DATA_PER_POINT.AND.FTR_PTS(1,ABSIFTR).EQ.NIL) GOTO 40

	  NARMS = NARMS+1			! count arms

C IFF address of first ST/CB in feature

	  STPOS = FTR_DAT(FTR_ST,ABSIFTR)
	  IF (IFTR.GT.0) THEN			! ftr leaves node
	    IPT = 1				! 1st pt in ftr
	  ELSE					! ftr enters node
	    NPTS = FTR_DAT(FTR_NP,ABSIFTR)	! Tot No. of pts in ftr
	    N_CONTIN_STS = (NPTS-1)/MAXPTS
	    IPT = NPTS - N_CONTIN_STS*MAXPTS

C Need IFF address of last ST/CB in feature.
C If only one ST or CB, then same as first one.
C If multiple STs, then can calculate address.
C If multiple CBs, then need to look explicitly (SPR1988).

	    IF ((ORVLEV.EQ.0).OR.(N_CONTIN_STS.EQ.0)) THEN
	       STPOS = STPOS + N_CONTIN_STS*MAX_ST_LEN	! STs or just one CB
	    ELSE				! multiple CBs in feature
	       CALL IFFPKE(IECODE,IELEN,STPOS)	! position to first
	       IF (IECODE.NE.'CB') THEN		! screwed up
	          WRITE_JB = ILINK__INTRNLERR
	          CALL LSL_PUTMSG(WRITE_JB,3,'WRITE_JB')
	          GOTO 80
	       END IF
	       DO 55 I=1,N_CONTIN_STS		! we have subsequent CBs
		  CALL IFFNXT(IECODE,IELEN)	! step forwards through CBs
	          IF (IECODE.NE.'CB') THEN	! screwed up
	             WRITE_JB = ILINK__INTRNLERR
	             CALL LSL_PUTMSG(WRITE_JB,4,'WRITE_JB')
	             GOTO 80
	          END IF
55	       CONTINUE
	       STPOS = LPOSH			! pos of last CB of feature
C go home to the junction we were dealing with before we went CB hopping
	       CALL IFJPKJ(X,Y,WARMS,NOD_ADDR(NOD_JB,INODE),
     &                     NOD_ADDR(NOD_JO,INODE))
	       IF (WARMS.LT.0) THEN		! screwed up
	          WRITE_JB = ILINK__INTRNLERR
	          CALL LSL_PUTMSG(WRITE_JB,5,'WRITE_JB')
	          GOTO 80
	       END IF
	     END IF
	  END IF

C finally got our arm information - put it in the junction.

	  CALL JIHW(NARMS,STPOS,IPT)		! fill out arm NARMS
	  GOTO 40				! loop for next arm

C Show progress

60	  IF (.NOT.HAD_MONITOR) GOTO 70
	  PCENT = N_NODES_OUTPUT*PCF
	  IF (PCENT-LPCENT.GT.0.1) THEN
	    WRITE(*,'(1H+,F6.1)')PCENT		! don't WRITE too often
	    LPCENT = PCENT
	  END IF

70	CONTINUE

	PCENT = 100
	IF (HAD_MONITOR) WRITE(*,'(1H+,F6.1)') PCENT

	IF (HAD_FREE_ENDS_LAYER) THEN		! write EO entry
	  CALL IFFPKE(IECODE,IELEN,NOPTR)
	  IF (IECODE.NE.'NO') THEN
	    WRITE_JB = ILINK__INTRNLERR
	    CALL LSL_PUTMSG(WRITE_JB,2,'WRITE_JB')
	    GOTO 80
	  END IF
	  CALL EIHW(LPOSE,2,3)
	  CALL IFFEO
	END IF

80	RETURN
	END
