C-------------------------------------------------------------------------------
C				THE WRAPPER
C-------------------------------------------------------------------------------
C
C
C
C
	LOGICAL*4 FUNCTION ISOLATIONS(CLOCK,HAD_AREA,NISOL)
C
***	MODULE	ISOLATIONS
***	IDENT	30AP92
C
C	Copyright Laser Scan Ltd, Cambridge, England
C
C	Author		Sunil Gupta			30-april-1992
C
C
C	........................................................................
C
	INCLUDE 'LSL$CMNPOLYGONS:ARRAY_PTRS.CMN'
C
C	Arguments:
		LOGICAL	CLOCK		! /OPTIONS=CLOCKWISE specified?
		LOGICAL	HAD_AREA	! /OPTIONS=AREA specified?
		INTEGER	NISOL		! return number of isolations
C
	LOGICAL*4	ACTUAL_ISOLATIONS
C
C	........................................................................
C
	ISOLATIONS = ACTUAL_ISOLATIONS(
     &			CLOCK,HAD_AREA,NISOL,
     &			POLMAX,
     &			%VAL(PTR$_POLY_AREA),
     &			%VAL(PTR$_POLY_START)
     &		  )
C
C	........................................................................
C
	RETURN
	END
C
C-------------------------------------------------------------------------------
C			    THE PROPER FUNCTION
C-------------------------------------------------------------------------------
C
C
C
	LOGICAL*4 FUNCTION ACTUAL_ISOLATIONS(
     &		CLOCK,HAD_AREA,NISOL,
     &		POLMAX, POLY_AREA,POLY_START
     &	)
C
***	MODULE	ACTUAL_ISOLATIONS
***	IDENT	30OC91
C
C	Copyright Laser-Scan Laboratories Ltd., Cambridge, England
C
CMOD	Returns number of ACTUAL_ISOLATIONS found		AC   11-Aug-1988
C	Author						TJH  20-Feb-1987
C
C
C Function to remove all polygons stored in /POLYGONS/ which are:
C     1) clockwise when the user specified anticlockwise formation
C	 order,
C
C     2) anticlockwise when the user specified clockwise formation
C	 order.
C
C Such polygons represent unwanted nested ACTUAL_ISOLATIONS and will result in 
C the "same" polygon appearing twice or even more trickly, an isolated
C polygon (containing ACTUAL_ISOLATIONS) having no seed point.
C                    
C
C Function returns SS$_NORMAL if all is well or one of a variety of
C IPOLYGON error codes on failure.
C ......................................................................
C
	IMPLICIT NONE
C
C Arguments:
	LOGICAL	CLOCK		! /OPTIONS=CLOCKWISE specified?
	LOGICAL	HAD_AREA	! /OPTIONS=AREA specified?
	INTEGER	NISOL		! return number of ACTUAL_ISOLATIONS
C
	INTEGER*4	POLMAX
	REAL		POLY_AREA(POLMAX)
	INTEGER		POLY_START(3,POLMAX)
C
C Parameters:
	INCLUDE 	'LSL$CMNPOLYGONS:PARAMS.PAR'
	INCLUDE 	'LSL$CMNPOLYGONS:POLYGONSMSG.PAR'
	INCLUDE		'($STSDEF)'
	INTEGER		SS$_NORMAL
	EXTERNAL	SS$_NORMAL	! normal successful completion
C
C Common:
	INCLUDE		'LSL$CMNPOLYGONS:FILE.CMN'
	INCLUDE		'LSL$CMNPOLYGONS:POLYGONS.CMN'
	INCLUDE		'LSL$CMNPOLYGONS:TABLES.CMN'
C
C W/s:
	INTEGER	  ISOL		! number of isolated polygons
	INTEGER	  POLY_INDX	! current polygons ident
C
C ......................................................................
C
	ACTUAL_ISOLATIONS=%LOC(SS$_NORMAL)
C
C ......................................................................
C    L O O P    F O R    E  A C H    P O L Y G O N   I N    T U R N
C
	ISOL=0
	DO 10 POLY_INDX=1,NUM_POLY
C
C Carefully avoid processing the bounding polygon, (we need this)
	   IF (POLY_INDX.EQ.BOUND_POL) GOTO 10
C
C If POLY_AREA(POLY_INDX) is +ve polygon POLY_INDX is anticlockwise,
C if -ve polygon POLY_INDX is clockwise. If the polygon direction is
C not that as specified on the cmd. line, flag POLY_START(1,POLY_INDX)
C -ve. In future that polygon can be ignored as necessary. 
	   IF (CLOCK) THEN
	      IF (POLY_AREA(POLY_INDX).GT.0.0) THEN
	         ISOL=ISOL+1
	         POLY_START(1,POLY_INDX)=-POLY_START(1,POLY_INDX)
	      ENDIF
	   ELSE
	      IF (POLY_AREA(POLY_INDX).LT.0.0) THEN
	         ISOL=ISOL+1
	         POLY_START(1,POLY_INDX)=-POLY_START(1,POLY_INDX)
	      ENDIF
	   ENDIF
C
C If /AREA remove the sign of the area for output later
	   IF (HAD_AREA) POLY_AREA(POLY_INDX)=ABS(POLY_AREA(POLY_INDX))
10	CONTINUE
C
C ......................................................................
C
C Tell user what has been done?
	IF (HAD_LOG) THEN
	   CALL EXPAND(
     &	    'Number of polygons examined ......................... %N',
     &							       NUM_POLY)
	   IF (HAD_LIS) THEN
	      CALL FLWLIN
	   ELSE
	      CALL TTWLIN
	   ENDIF
	   CALL EXPAND(
     &	    'Number of isolated polygons ......................... %N',
     &								 ISOL)
	   IF (HAD_LIS) THEN
	      CALL FLWLIN
	   ELSE
	      CALL TTWLIN
	   ENDIF
	ENDIF
	NISOL = ISOL
C
C ......................................................................
C
	RETURN
	END
	
