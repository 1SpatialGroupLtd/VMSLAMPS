C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1986-12-04 22:09:44.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	INTEGER*4 FUNCTION FIXINFO(CMLSTR,CMLEN)
C
***	MODULE	FIXINFO
***	IDENT	04DE86
C
C	Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
CMOD	Made a function, command line output chopped
C       up into 80 byte chuncks				TJH 04-Dec-1986
C	Ripped off SRTINFO in [IFF.IMP.ISORT]		ATT 27-Aug-1986
C
	IMPLICIT NONE
C
C routine to print job information
C
C functions:
	INTEGER SYS$GETJPIW	! Get Job/Process Information
C
C Common:
	INCLUDE	'LSL$CMNIFIXAREA:IFIXAREA.CMN'
C
C parameters:
	INCLUDE '($SSDEF)'
	INCLUDE '($JPIDEF)'
C
C workspace:
	INTEGER   IERR		! Error from queing of System service
	INTEGER   IOSB		! status at completion of Sys service
	INTEGER*2 IOSBW(2)	! bottom word is error code
	EQUIVALENCE (IOSB,IOSBW)
C
	INTEGER   ITMLEN	! size of item list
	PARAMETER (ITMLEN=25)
	INTEGER*4 ITMLST(ITMLEN)
	INTEGER*2 ITMLST2(2*ITMLEN)
	EQUIVALENCE (ITMLST,ITMLST2)
C
	CHARACTER*9   DATSTR	! string for date
	CHARACTER*128 IMAGNAME	! name of image being executed
	INTEGER	      IMAGELEN	! no. of chars
	CHARACTER*15  PRCNAM	! name of process
	INTEGER       PRCLEN	! no. of chars
	CHARACTER*7   TERMINAL	! terminal name
	INTEGER       TERMLEN	! no. of chars
	CHARACTER*8   TIMSTR	! string for time
	CHARACTER*15  USERNAME	! name of user
	INTEGER       USERLEN	! no. of chars
	CHARACTER*1024	CMLSTR	! command line string
	INTEGER*4	CMLEN	! length of command line string
C
	BYTE		CH	! one character
	INTEGER	  I,ISTART,IEND	! temp. vars.
C
C ......................................................................
C
	FIXINFO=SS$_NORMAL		! assume success
C
C set up the item list ( see SYSTEM SERVICES Reference Manual)
C
	ITMLST2(1)   =128
	ITMLST2(2)   =JPI$_IMAGNAME
	ITMLST (3/2+1) =%LOC(IMAGNAME)
	ITMLST (5/2+1) =%LOC(IMAGELEN)
C
	ITMLST2(7)  =7
	ITMLST2(8)  =JPI$_TERMINAL
	ITMLST (9/2+1)=%LOC(TERMINAL)
	ITMLST (11/2+1)=%LOC(TERMLEN)
C
	ITMLST2(13)  =15
	ITMLST2(14)  =JPI$_PRCNAM
	ITMLST (15/2+1)=%LOC(PRCNAM)
	ITMLST (17/2+1)=%LOC(PRCLEN)
C
	ITMLST2(19)  =15
	ITMLST2(20)  =JPI$_USERNAME
	ITMLST (21/2+1)=%LOC(USERNAME)
	ITMLST (23/2+1)=%LOC(USERLEN)
C
	ITMLST (25/2+1) =0		! to terminate it
C
C	queue the request
	IERR=SYS$GETJPIW(,		! efn
     &                   ,		! pid
     &                   ,		! prcnam
     &                   ITMLST,	! itmlst
     &                   IOSB,		! iosb
     &                   ,		! astadr
     &                   ,)		! astprm
C
	IF (IERR.NE.SS$_NORMAL) GOTO 50	! branch if failed to queue
C
C did the request complete OK ? - branch if it failed
	IF (IOSBW(1).NE.SS$_NORMAL) GOTO 40
C
C tidy things up
	USERLEN = INDEX(USERNAME,' ') - 1
	IF (USERLEN.LE.0) USERLEN = 12
C
C Get date
	CALL DATE (DATSTR)
C
C Get time
	CALL TIME(TIMSTR(:8))
C
C print our results
	CALL FLWSEL(OUTLUN)
	CALL FLWRTF
	CALL FLWRTF('================================= IFIXAREA =='//
     &		      '===================================')
	CALL FLWRTF
	CALL FLWRTF('Input file:   %S',INFILE(:FILEN))
	CALL FLWRTF('Output file:  %S',FIXFILE(:FIXLEN))
	CALL FLWRTF
	CALL EXPAND
     &	  ('IFIXAREA invoked by: %S, Process: %S',USERNAME(1:USERLEN),
     &    PRCNAM(1:PRCLEN))
	CALL APPEND(', on: %S %S',DATSTR(:9),TIMSTR(:8))
	CALL FLWSTR
	CALL FLWRTF('Command line:')
C
C Uppercase the command line
C
	DO 10 I=1,CMLEN
	   CH=ICHAR(CMLSTR(I:I))
	   IF (CH.GT.96.AND.CH.LT.123) CMLSTR(I:I)=CHAR(CH-32)
10	CONTINUE
 
C
C Now output the command line. Look for suitable breaks if more than
C 80 characters long.
C
	IEND=0
	ISTART=1
20	DO 30 I=MIN(CMLEN,IEND+80)+1,ISTART,-1
	   IF (CMLSTR(I:I).EQ.' '
     &	   .OR.CMLSTR(I:I).EQ.'/'
     &	   .OR.CMLSTR(I:I).EQ.','
     &	   .OR.I.EQ.CMLEN) GOTO 35
30	CONTINUE
C
C And output each chunck
35	IEND=I
	CALL FLWRTF('%S',CMLSTR(ISTART:IEND))
	ISTART=IEND+1
C
C and possibly loop back for the rest of the command line
	IF (ISTART.LT.CMLEN) GOTO 20
	CALL FLWRTF(' ')
	GOTO 50
C
C here if GETJPI failed to queue - should never happen so don't know 
C what to do except return
40	FIXINFO = IOSBW(1)
50	RETURN
	END
