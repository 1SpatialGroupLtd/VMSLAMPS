	INTEGER*4 FUNCTION OPEN_DTI_FILE(DTI_LUN)
C
***	IDENT	28NO88
***	MODULE	OPEN_DTI_FILE
C
C	Copyright : Laser-Scan Laboratories, Cambridge, England
C	Author    : D R Catlow
C	
	IMPLICIT NONE
C
C------------------------------------------------------------------------
C
C	Function to open a DTI file on the requested DTI_LUN.
C	The routine closes any file currently opened on DTI_LUN.
C	The filename specified on the command line (optionally contained
C	within quotation marks) is parsed against the default 
C	LSL$DTI:DTI.DTI
C	The routine calls DTI_OPEN to open and map the file.
C
C	The function returns TRUE if a file is successfully opened, and
C	FALSE if an error has occured.
C
C-------------------------------------------------------------------------
C
C	DTILIB commons and parameter files
***	COMMON/LSL$CMNDTI:DTIHDR/
C
***	PARAMETER/LSL$CMNDTI:DTIPAR/
***	PARAMETER/LSL$CMNDTI:DTILIBMSG/
C
C 	LSLLIB parameter files
***	COMMON/LSL$CMNLSL:READSTR.PAR/
***	COMMON/LSL$CMNLSL:LSLLIBMSG.PAR/
C
***	COMMON/HERE:VEC/
C
C arguments
	INTEGER*4	DTI_LUN		! channel number
C
C workspace
C
	INTEGER*4	ERROR		! function system errir code
	INTEGER*4	RETVAL		! function return code
	INTEGER*4	FAKSTR(2)	! fake string
	INTEGER*2	FAKLEN		! fake string length
	BYTE		FAKBUF(128)
	BYTE		CH		! single character
C
	EQUIVALENCE	(FAKLEN,FAKSTR(1))
C
C DTILIB functions
	INTEGER*4	DTI_OPEN	! open and map a file
	INTEGER*4	DTI_CLOSE	! to unmap and close a file
	INTEGER*4	DTI_UNITS	! get default units
C
C LSLLIB functions
	INTEGER*4	READSTR		! read string
	LOGICAL		PARFILN		! parse filename
	LOGICAL		RDCHS		! read character
C
C****************************************************************************
C
	OPEN_DTI_FILE=.FALSE.	! Assume function is unsuccessful
C
C	Close and unmap any file opened on this channel
	IF(DTILUN_INUSE(DTI_LUN))THEN
	  RETVAL = DTI_CLOSE (DTI_LUN, .FALSE., .TRUE., ERROR)	
	  IF(RETVAL.NE.DTI__NORMAL)THEN
	     CALL LSL_PUTMSG(RETVAL)
	     IF(RETVAL.EQ.DTI__SYSERR)CALL LSL_PUTMSG(ERROR)
	     GOTO 999			!return
	  ENDIF	  
	ENDIF
C
	FAKSTR(2)=%LOC(FAKBUF)	! set up fake string descriptor
C
C	Check for optional quotes around the filename
	IF(RDCHS(CH))THEN
	  CALL WRITEF('%S DTI Filename missing',ERROR_BELL)
	  CALL BSLN
	  GOTO 999	  
	ELSE
	  FAKLEN=128
	  IF(CH.EQ.34.OR.CH.EQ.39)THEN
	    FAKLEN=READSTR(FAKSTR,CH,ON_CHAR2,.FALSE.)
	  ELSE
	    CALL BSCH
	    FAKLEN=READSTR(FAKSTR,' ',ON_CHAR2,.FALSE.)
	  ENDIF
	ENDIF
C
C	Parse the input file name against LSL$DTI:.DTI
	RETVAL=PARFILN(DTI_NAME(DTI_LUN),
     &                 DTI_NAME_LENGTH(DTI_LUN),
     &	               FAKSTR,
     &	               'LSL$DTI:.DTI',
     &	               .TRUE.)
	IF(RETVAL.NE.LSL__NORMAL)THEN
	  CALL LSL_PUTMSG(RETVAL)
	  GOTO 999			!return
	ENDIF
C
C------------------------------------------------------------------------
C	Open and map the file
	RETVAL = DTI_OPEN (DTI_LUN, 
     &                     DTI_NAME(DTI_LUN), 
     &                     DTI_NAME_LENGTH(DTI_LUN),
     &                     .FALSE.,
     &	                   ERROR,
     &                     .TRUE.)
C
	IF(RETVAL.NE.DTI__NORMAL)THEN
	  CALL LSL_PUTMSG(RETVAL)
	  IF(RETVAL.EQ.DTI__SYSERR)CALL LSL_PUTMSG(ERROR)
	  GOTO 999			!return
	ENDIF
C
C	Check for WORD data type - other types not yet allowed
C	IF(DATA_TYPE(DTI_LUN).NE.DATA_WORD)THEN
C	  CALL WRITEF
C     &	  ('%S DTI Data type not valid',ERROR_BELL)
C	  CALL WRITEF
C     &    ('VECTORISE currently accepts only WORD data')
C	Unmap file and return
C	  RETVAL = DTI_CLOSE (DTI_LUN, .FALSE., .TRUE., ERROR)	
C	  IF(RETVAL.NE.DTI__NORMAL)THEN
C	     CALL LSL_PUTMSG(RETVAL)
C	     IF(RETVAL.EQ.DTI__SYSERR)CALL LSL_PUTMSG(ERROR)
C	  ENDIF
C	  GOTO 999
C	ENDIF
C
C	Set the defaults UNITS value,
	UNITS=0
	RETVAL=DTI_UNITS(DTI_LUN,UNITS)	
	IF(.NOT.RETVAL)CALL LSL_PUTMSG(RETVAL)	  
C
	OPEN_DTI_FILE=.TRUE.		!signal success
C
999	RETURN
C
	END
