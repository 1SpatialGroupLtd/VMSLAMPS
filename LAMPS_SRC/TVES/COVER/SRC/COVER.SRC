C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1993-04-06 11:59:04.000000000 +0100
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	PROGRAM COVER
C
***	MODULE COVER
***	IDENT  06AP93
C
	IMPLICIT NONE
C
C	Copyright Laser-Scan Ltd., Cambridge, England
C	Author: 	D R Catlow.
C	Created:	August 85
C
CMOD1189 18FE93 JB	Use REAL's for observer position and height 
c			(not MATRIX values), and use bilinear 
C			interpolation between the 4 surrounding pixels
C			to get accurate a more height to preserve accuracy
C			- keep targets as integer
CMOD	 17FE93 JB	Add ENABLE BILINEAR to use above
C
CMOD	 16SE91 JB	Rearrange FILEIN actions to OPEN_FILE
CMOD	 18JL90 PP	Increase text line buffer from 80 to 255
CMOD	 20JA89 MWSR	Specified HEIGHTs not added to previous
C			specified HEIGHT
CMOD	 20JA89 MWSR	Introduce GO and FILEOUT commands
CMOD	 02DE88 DRC	Use with ENABLE TABLE, ENABLE ASBOLUTE
CMOD	 17JL87 DRC	To utilise new LSL libraries (LSLLIB,DTILIB)
CMOD	 23MY87 DRC	PLOT SIGMA and PLOT DTI commands added
CMOD	 12AU86 DRC	Auxiliary Matrix Offset Command added
C
C Include LSLLIB common blocks
***	COMMON/LSL$CMNLSL:CMDCOM/
***	COMMON/LSL$CMNLSL:TXTC/
C
C Include DTILIB common blocks
***	COMMON/LSL$CMNDTI:DTIHDR/
***	COMMON/LSL$CMNDTI:DTIPROJ/
C
C COVER commons:
***	COMMON/HERE:TAB/		! Table monitor values
***	COMMON/HERE:TRANS/
***	COMMON/HERE:COVQIO/		! QIO values
***	COMMON/HERE:OBSERVER/		! Observer values
***	COMMON/HERE:COVER /		! 
***	COMMON/HERE:DRWCMN/		! contains INIT_SIGMA
C
C Include any required parameter files
***	PARAMETER/LSL$CMNLSL:LSLLIBMSG/
***	PARAMETER/LSL$CMNDTI:DTILIBMSG/
***	PARAMETER/LSL$CMNDTI:DTIPAR/
C
	INCLUDE 	'($DVIDEF)'
	INCLUDE		'($DCDEF)'
C
C workspace
	REAL		DIFFX,DIFFY	! delta values
	REAL		RAD_ANGLE	! angle in radians
	REAL		R1,R2,R3,R4	! 4 temporary reals
	REAL		X1,Y1		! DTI observer positions
	REAL		DX,DY
	REAL		LAST_POS_TARGET(2)
	REAL		INT_GND_HEIGHT(MAX_OBSERVERS)
	REAL		GROUND_HEIGHT(MAX_OBSERVERS)
C					! ground height of observers
C
	INTEGER*4	DTI_POINT(2)	! X,Y position of POINT
	INTEGER*4	RETVAL		! function return code
	INTEGER*4	ERRCOD
	INTEGER*4	NCHS		! no. of charcters
	INTEGER*4	ERROR		! system error code
	INTEGER*4	SAVED_UNITS	! saved units value
	INTEGER*4	LLDEGS(4)
	INTEGER*4	CMD		! decoded command number
	INTEGER*4	I,J		! loop variable
	INTEGER*4	IX,IY		! integer version of X1,Y1
	INTEGER*4	X2,Y2		! two DTI points
	INTEGER*4	X_TAB,Y_TAB	! table coords
	INTEGER*4	DEGR,MINU,SECO
	INTEGER*4	VAL		! for GETDVI
	INTEGER*4	LOWX,HIGHX	! integer posn's around the
	INTEGER*4	LOWY,HIGHY	! observer position
C
	INTEGER*2	HEIGHT		! DTI heights
	INTEGER*2	HEIGHT1,HEIGHT2
	INTEGER*2	HEIGHT3,HEIGHT4
	REAL		RHEIGHT
C
	LOGICAL		DEFAULT_WINDOW
	LOGICAL		HADNEG
	LOGICAL		NEGA
	LOGICAL		FIRST_FILE	! first DTI file
	LOGICAL		DIRECT		! .f. if from command file
C
	BYTE		CH
	CHARACTER*255	LINE
	CHARACTER*1	TRANSLATION	! translation of logical name
C
	CHARACTER*128	ICFNAM		! indirect command file name
	INTEGER*4	ICFLEN		! command file name length
C
	PARAMETER	PI=3.141592654
C
C primary command tables
	EXTERNAL	COVER_CMD_TABLE
C
C secondary command tables
	EXTERNAL	SHOW_CMD_TABLE
	EXTERNAL	UNIT_CMD_TABLE
	EXTERNAL	ENABLE_CMD_TABLE
	EXTERNAL	DEFINE_CMD_TABLE
	EXTERNAL	SET_CMD_TABLE
	EXTERNAL	SETUP_CMD_TABLE
	EXTERNAL	SELECT_CMD_TABLE
C
	EXTERNAL	CTRLCAST
	EXTERNAL 	PUT_OUTPUT
C
C functions called
	LOGICAL		DTMJPI		! process info introduction
	LOGICAL		GET_FILENAME	! parse a filespec
C
C DTILIB functions called
	INTEGER*4	DTI_PRINT_HEADER	! to print header details
	INTEGER*4	DTI_CLOSE		! to close a DTI file
	INTEGER*4	DTI_READ_WORD_DATA 	! returns cell height
	INTEGER*4	DTI_UNITS		! test whether units are valid
C
C LSLLIB functions called
	REAL		RDREAL		! read real value
	INTEGER*4	RDLONG		! read longword
	INTEGER*4	RDCOMM		! read keyboard command line
	INTEGER*4	TTRSTR		! read a command
	LOGICAL		RDCHS		! read character
	LOGICAL		RDCH		! read character
	INTEGER*4	TRNALL		! translate logical name
	INTEGER*4	GETFILNAM	! parse filename
	INTEGER*4	FLRLIN		! read line from command file
	INTEGER*4 	FLROPN		! to open the command file
	INTEGER*4 	FLRCLO		! to close the command file
C
C System Library functions
	INTEGER*4	SYS$ASSIGN	! assign I/O channels
	INTEGER*4	LIB$SPAWN	! spawns DCL operations
	INTEGER*4	LIB$GETDVI	! get term characteristics etc.
C
C COVER functions
	INTEGER*4	COVER_INIT	! to initialise various variables
					! for COVER
	INTEGER*4	TEST_TERM	!input a terminal?
	LOGICAL		OPEN_FILE	! routine to map DTI file
	LOGICAL		GET_TAB_COORDS	! get a point in table coords
	LOGICAL		HAD_PUCK	! had puck input?
	LOGICAL		READ_PUCK	! read puck input
	LOGICAL		INIT_TAB	! initialise table monitor
	LOGICAL		WAIT_INPUT	! wait for kybd or table input
	LOGICAL		READLL		! reads lat/long
C
C***********************************************************************
C	Initialise libraries
C
	CALL LSL_INIT(.TRUE.)		! initialise LSLLIB
	CALL SET_TXTLIM(255)		! set max line length
	CALL LSL_SET_OUTPUT(PUT_OUTPUT)
C
	CALL DTI_INIT			! initialise DTILIB
C
	RETVAL=DTMJPI()
C
C Initialise COVER variables
	CALL COVER_INIT
C
C Other default values
	UNITS   = 1			! matrix units by default
	REFRACT = 0.125			! coefficient of refraction
C
	ECURVE  = .FALSE.		! earth curvature not included
C					! in cover calculations	
	ADD_CULT_HEIGHT = .FALSE.
	HAD_FILEOUT	= .FALSE.	! no fileout command
C
	DIAG		= .TRUE.
	PLOT_GRAPHICS	= .TRUE.
	PLOT_DTI	= .FALSE.
	INIT_GRAPHICS	= .FALSE.	! graphics device not yet initialised
	MAP_SET		= .FALSE.	! map not yet located on table
	FIRST_FILE	= .TRUE.
	ABSOLUTE   	= .TRUE.
	BILINEAR	= .FALSE.
C
C See if input is from command file
	CMDFIL = .TRUE.			! assume so
	RETVAL = TEST_TERM('SYS$INPUT',TERM,IERR)
	IF (.NOT.RETVAL) THEN
	   IF (RETVAL.EQ.LSL__SYSERR) THEN
	      CALL LSL_PUTMSG(IERR)
	   ELSE
	      CALL LSL_PUTMSG(RETVAL)
	   ENDIF
	ELSE
	   CMDFIL = .NOT.TERM		! input from command file
	ENDIF
C
C assign input channel, and set up control/C handler
	CTRLC = .FALSE.
	IF (.NOT.CMDFIL) THEN
	  IERR = SYS$ASSIGN('SYS$INPUT',IN_CHAN,,)
	  IF (.NOT.IERR) THEN
	    CALL LSL_PUTMSG(IERR)
	    GOTO 9000			! exit
	  ENDIF
	  CALL SET_OUTBAND_AST(CTRLCAST,8)
	ENDIF
	HADQIO = .FALSE.		! no QIO active
C
C see if output is to a terminal
	IERR=LIB$GETDVI(DVI$_DEVCLASS,,'SYS$OUTPUT',VAL,,)
	IF (IERR) THEN				! success
	   IF (VAL.EQ.DC$_TERM)TERM=.TRUE. 	! it is a terminal
	ELSE
	   CALL LIB$SIGNAL(%VAL(IERR))
	ENDIF
C
	IF(TERM)THEN
	  IERR=LIB$GETDVI(DVI$_TT_SCOPE,,'SYS$OUTPUT',VAL,,)
	  IF (IERR) THEN
	     CRT=VAL.EQ.1
	  ELSE
	   CALL LIB$SIGNAL(%VAL(IERR))
	  ENDIF	
C
C assign output channel
	  IERR = SYS$ASSIGN('SYS$OUTPUT',OUT_CHAN,,)
	  IF (.NOT.IERR) THEN
	    CALL LSL_PUTMSG(IERR)
	    GOTO 9000		! exit
	  ENDIF
	ELSE
	  CRT=.FALSE.
	ENDIF
C
C----------------------------------------------------------------------
C initialise digitising table
	RETVAL = TRNALL('LSL$AUTO_ENABLE_TABLE',TRANSLATION)
	IF(.NOT.RETVAL.OR.TRANSLATION.NE.'1')THEN
	   TABLE = .FALSE.
	   GOTO 8
	ELSE
	   TABLE = .TRUE.
	ENDIF
C
	IF(TABLE) THEN
	  IF (INIT_TAB(,IERR)) THEN
	    CALL WRITEF('%S Unable to initialise the table monitor',
     &                WARN_BELL)
	    CALL WRITEF('COVER will assume no table is available')
	    TABLE=.FALSE.			! disallow table input
	    GOTO 8
	  ENDIF
	ENDIF
C
C 	Set event flag numbers
	CALL RETURN_EFN(EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
	GOTO 9
C
8	EF_VDU=1
C
C set up text pointers for WAIT_INPUT
9	TXTPTR = 255
	CALL WRITEF(' ')
C
	DIRECT=.TRUE.
C
C***********************************************************************
C get next command from keyboard or table puck
C
10	IF(DIRECT)THEN
	  CTRLC = .FALSE.			! clear any CTRL/C
	  IF (.NOT.WAIT_INPUT('COVER',.TRUE.,.TRUE.)) GOTO 9000
	ELSE
C
C	Read a line from the command file
	  RETVAL = FLRLIN()
	  IF(RETVAL.NE.LSL__NORMAL)THEN
	     IF(RETVAL.NE.LSL__EOF)THEN
	       CALL WRITEF('%S Reading from command file',ERROR_BELL)
               CALL WRITEF('Returning to terminal input')
	     ELSE
	       CALL WRITEF('%S Reading from command file',ERROR_BELL)
	       CALL WRITEF('End of command file detected')
	     ENDIF
	     GOTO 2750			! to close the file 
	  ELSE
C
C Echo the command on the terminal
	     CALL BSLN
	     CALL EXPAND('COVER> ')
	     CALL APPEND(TXTDSC)
	     CALL TTWSTR
	     HAD_VDU=.TRUE.
	  ENDIF
	ENDIF
C
	IF (HAD_VDU) THEN	! keyboard input
	  NOMESS=.FALSE.
	  IF (RDCHS(CH)) GOTO 10	! substantially empty line
	  IF (CH.EQ.'!') GOTO 10	! comment!
	  IF (CH.EQ.'@') GOTO 50	! read file spec
	  CALL BSLN
C
	  CMD = RDCOMM(COVER_CMD_TABLE)	! read keyboard command line
	  IF(CMD.LE.0)THEN
	    CALL WRITEF('%S Specifying COVER command',ERROR_BELL)
            GOTO 10			! unrecognised command
	  ENDIF
C
	  NOMESS=.TRUE.
C
C execute command from keyboard
C
	  GOTO (
     &	   100 , 200,  300,  400, 	! filein, help, show, window
     &	   500,  600,  700,  800,	! setup, set, units, spawn
     &	   900, 9000, 1000, 1100,	! position, exit, height, cone
     &	  1200, 1300, 1400, 1500,	! direct, dist, target, display
     &	  1600, 1700, 1800, 1900,	! fileou, create, select, redisp
     &	  2000, 2100, 2200, 2300, 	! wait, enable, disable, define
     &    2400, 2500, 2700, 2800 )CMD	! write, point, return, go
C
	ELSEIF (HAD_PUCK(IERR)) THEN
	  IF (READ_PUCK(BUTTON,X_TAB,Y_TAB,IERR)) THEN
	    CALL SHOW_ERROR(IERR)
	  ELSE 
	    GOTO(850,2350,2350,2350,2350,2350,2350,2350,2350,
     &           1380,2450,390),BUTTON+1
C
C		  0    1    2   3     4    5    6    7    8
C	          9    A    B 
C	         pos, ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8,
C                tar, point,win
	  ENDIF
C
	ENDIF
	GOTO 10				! get next command
C
C-------------------------------------------------------------------
C	@ command
C
50	IF(.NOT.DIRECT)THEN
	  CALL WRITEF('%S Specifying command @',ERROR_BELL)
	  CALL WRITEF('Nested command files not supported')
	  GOTO 10
	ENDIF
C
	IF(RDCHS(CH))THEN
	  CALL WRITEF('%S Specifying command @',ERROR_BELL)
	  CALL WRITEF('Command file specification is missing')
	  GOTO 10
	ENDIF
C
	CALL BSCH
C
C	Parse the filename
	RETVAL = GETFILNAM(ICFNAM,ICFLEN,'SYS$DISK:[].COM;0',.TRUE.)
	IF (.NOT.RETVAL) THEN
	  CALL LSL_PUTMSG(RETVAL)
	  GOTO 10
	ENDIF
C
C 	Open the indirect command file
	RETVAL = FLROPN(1,ICFNAM,IERR)
	IF(.NOT. RETVAL)THEN
	  CALL WRITEF
     &    ('%S Unable to open indirect command file %S',
     &    ERROR_BELL,ICFNAM(1:ICFLEN))
	  CALL LSL_PUTMSG(RETVAL)
	  GOTO 10		!get next command from terminal
	ENDIF
C
	DIRECT = .FALSE.	!signal that input is from a command file
	GOTO 10			!get next command from the file
C
C-----------------------------------------------------------------------
C	FILEIN - Input DTI file is opened on 1
C	Call Function OPEN_DTI_FILE to read DTI input filename,
C	and map it into memory.
C	
100	IF (.NOT.OPEN_FILE(1)) THEN		! Error already output 
102	  CALL BSLN
	  IF (.NOT.WAIT_INPUT('Input DTI filename',.FALSE.,.TRUE.))
     &    GOTO 10
	  GOTO 100
	ENDIF
C
C	Set default area of interest in input DTI file
C	only if logical name LSL$MATRIX_DEFAULT_WINDOW has a
C	value of 1
C	Translate logical
C
	IERR = TRNALL('LSL$MATRIX_DEFAULT_WINDOW',TRANSLATION)
	IF(.NOT.IERR.OR.TRANSLATION.NE.'1')THEN
	  DEFAULT_WINDOW = .FALSE.
	ELSE
	  DEFAULT_WINDOW = .TRUE.
	ENDIF
C
	DTI_WINDOW_SWX(1) = 1
	DTI_WINDOW_SWY(1) = 1
	IF(DEFAULT_WINDOW)THEN
	  DTI_WINDOW_NEX(1) = MIN(200,X_EXTENT(1))
	  DTI_WINDOW_NEY(1) = MIN(200,Y_EXTENT(1))
	ELSE
	  DTI_WINDOW_NEX(1) = X_EXTENT(1)
	  DTI_WINDOW_NEY(1) = Y_EXTENT(1)
	ENDIF	
C
	XOFFSET    = 0			! since window SW
	YOFFSET    = 0			! corner is 1,1
	MATSIZ(1)  = DTI_WINDOW_NEX(1)
	MATSIZ(2)  = DTI_WINDOW_NEY(1)
	MAT_XOFFSET= 0			! by default, assume
	MAT_YOFFSET= 0			! input DTM and auxilliary
C					! matrix have same origin
C	Initialise all observer values
C
	IF(.NOT.FIRST_FILE)CALL COVER_INIT
	FIRST_FILE=.FALSE.
C
	GOTO 10
C
C-----------------------------------------------------------------------
C	HELP				
C
200	CALL HELP			! use system on-line help
	GOTO 10
C
C-----------------------------------------------------------------------
C       SHOW - 	Which topic? - use secondary command table
C
300	CMD = RDCOMM(SHOW_CMD_TABLE)	
	IF (CMD.LE.0) THEN	! qualifier unrecognised
	  CALL WRITEF('%S Specifying command SHOW',ERROR_BELL)
	  CALL WRITEF('SHOW options are
     & ENABLE, FILES, OBSERVERS, SETTINGS or TARGETS')
C
	  GOTO 10 
	ENDIF
C
	GOTO (310,320,330,340,350)CMD	
C	     observers,files,targets,enable,settings 
C
C-------------------------------------------------------------------------
C       SHOW OBSERVERS - Have any observers been defined
C
310	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF(' ')
	  CALL WRITEF
     &  ('*** WARNING *** No observers are currently selected')
	  CALL WRITEF(' ')
	  GOTO 10
	ENDIF
C
C	Print out observer details
	CALL COVER_PRINT_OBSERVERS
C
	GOTO 10
C
C-----------------------------------------------------------------------
C       SHOW FILES - Is a DTI file opened on the LUN?
C
320	IF(.NOT.DTILUN_INUSE(1))THEN
	  CALL WRITEF(' ')
	  CALL WRITEF('*** WARNING *** The input DTI file is undefined')
	  CALL WRITEF(' ')
C
	ELSE
C Print out what we know about the input file
C
	  CALL WRITEF(' ')
	  RETVAL=DTI_PRINT_HEADER(1,UNITS,ABSOLUTE)
	  IF(.NOT.RETVAL)CALL LSL_PUTMSG(RETVAL)
	ENDIF
C 
	IF (HAD_FILEOUT) THEN
	   CALL WRITEF('File %S selected for output',
     &     VIS_NAME(:VIS_NAME_LENGTH))
	ENDIF
C
 	IF(CULTRE)THEN
	   CALL WRITEF(' ')
	   CALL WRITEF('Culture')
	   RETVAL = DTI_PRINT_HEADER(7,UNITS,ABSOLUTE)
	   IF(.NOT.RETVAL)CALL LSL_PUTMSG(RETVAL)
	ENDIF  
C
	GOTO 10
C
C-----------------------------------------------------------------------
C	SHOW TARGET - 	Are any observers currently selected?
C
330	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF(' ')
	  CALL WRITEF('*** WARNING *** No observers are currently selected')
	  CALL WRITEF(' ')
	  GOTO 10
	ENDIF
C
C	Print out details of targets settings
	CALL COVER_PRINT_TARGETS
	GOTO 10
C
C-----------------------------------------------------------------------
C	SHOW ENABLE
C
340	CALL WRITEF(' ')
	CALL WRITEF('Current status:')
	CALL WRITEF(' ')
C
	CALL EXPAND('ABSOLUTE       ')
	IF(ABSOLUTE)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
C
	CALL APPEND('ADD_TARGET     ')
	IF(ADD_CULT_HEIGHT)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
C
	CALL APPEND('CULTURE        ')
	IF(CULTRE)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
	CALL TTWLIN
C
	CALL EXPAND('DIAGNOSTICS    ')
	IF(DIAG)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
C
	CALL APPEND('EARTH_CURVATURE')
	IF(ECURVE)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
C
	CALL APPEND('TABLE          ')
	IF(TABLE)THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
	CALL TTWLIN
C
	CALL EXPAND('BILINEAR       ')
	IF (BILINEAR) THEN
	  CALL APPEND('   On       ')
	ELSE
	  CALL APPEND('  Off       ')
	ENDIF
C
	CALL TTWLIN
	CALL WRITEF(' ')
	GOTO 10
C
C----------------------------------------------------------------------
350	CALL WRITEF(' ')
	CALL WRITEF('Current Settings:')
	CALL WRITEF(' ')
	CALL EXPAND('OFFSET ')
	CALL APPEND('%^W%I5 ',MAT_XOFFSET)
	CALL APPEND('%^W%I5  ',MAT_YOFFSET)
	CALL APPEND('REFRACTION_COEFFICIENT  ')
	CALL APPEND('%F7.4',REFRACT)
	CALL TTWLIN
	CALL WRITEF(' ')
	GOTO 10
C
C***********************************************************************
C	WINDOW defined from puck button
C
390	IF(.NOT.MAP_SET)THEN
	  CALL WRITEF
     &    ('%S Specifying command WINDOW using puck button',ERROR_BELL)
	  CALL WRITEF('No map set up has been performed')
	  GOTO 10
	ENDIF
C
	CALL WRITEF('%S',BELL)
	IF(.NOT.GET_TAB_COORDS(X_TAB,Y_TAB,'Window SW corner')) GOTO 10
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
	REALAR(1)=R3
	REALAR(2)=R4
C
	CALL WRITEF('%S',BELL)
 	IF(.NOT.GET_TAB_COORDS(X_TAB,Y_TAB,'Window NE corner')) GOTO 10
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
	REALAR(3)=R3
	REALAR(4)=R4
C	
	CMDRCT=4
	SAVED_UNITS=UNITS	!save units before call to COVER_SET_WINDOW
	UNITS=1
	CALL COVER_SET_WINDOW(1)
	UNITS=SAVED_UNITS	!reset to units
C
C	Confirm window values
	IERR=DTI_PRINT_HEADER(1,UNITS,ABSOLUTE)
	IF(.NOT.IERR)CALL LSL_PUTMSG(IERR)
C
	GOTO 10
C-----------------------------------------------------------------------
C	WINDOW - select area of interest
C
400	IF(.NOT.DTILUN_INUSE(1))THEN
	  CALL WRITEF('%S Specifying command WINDOW',ERROR_BELL)	  
	  CALL WRITEF('The input DTM must be specified before WINDOW')
	  GOTO 10
	ENDIF
C
460	CALL COVER_SET_WINDOW(1)
	GOTO 10
C
C***********************************************************************
C       SETUP - Check the qualifier.  Currently only map is valid
C
500	CMD = RDCOMM(SETUP_CMD_TABLE)	
	IF (CMD.LE.0) THEN	! qualifier unrecognised
	  CALL WRITEF('%S Specifying command SETUP',ERROR_BELL)
	  CALL WRITEF('Command qualifier is MAP')
	  GOTO 10 
	ENDIF
C
	IF(CMD.EQ.1)THEN		!MAP
          IF(.NOT.TABLE)THEN
	    CALL WRITEF('%S Specifying command SETUP MAP',ERROR_BELL)
	    CALL WRITEF
     &	    ('Command is invalid if the table has not been initialised')
	    GOTO 10
	  ENDIF
C
	  IF(.NOT.DTILUN_INUSE(1))THEN
	    CALL WRITEF('%S Specifying command SETUP MAP',ERROR_BELL)
	    CALL WRITEF('The input DTM must be specified before SETUP MAP')
	    GOTO 10
	  ENDIF
C
	  CALL SET_MAP
C
	ENDIF
	GOTO 10
C
C--------------------------------------------------------------------------
C	SET command - 	Get the associated qualifier
C
600	CMD = RDCOMM(SET_CMD_TABLE)	
	IF (CMD.LE.0) THEN	! qualifier unrecognised
	  CALL WRITEF('%S Specifying command SET',ERROR_BELL)
	  CALL WRITEF
     &    ('Command qualifiers are OFFSET or REFRACTION_COEFFICIENT')
	  GOTO 10 
	ENDIF
C
	IF(CMD.EQ.1)THEN	! MATRIX offset
	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF('%S Specifying command SET OFFSET',ERROR_BELL)
	    CALL WRITEF('Command requires 2 integer arguments')
	    GOTO 10
	  ENDIF
C
	  IF(INTARG(1).GT.X_EXTENT(1).OR.INTARG(2).GT.Y_EXTENT(1))THEN
	    CALL WRITEF('%S Specifying command SET OFFSET',ERROR_BELL)
	    CALL WRITEF
     &	    ('Offset column and row values may not exceed DTM bounds')
	    GOTO 10
	  ENDIF
C
	  MAT_XOFFSET=INTARG(1)
	  MAT_YOFFSET=INTARG(2)
	  GOTO 10
	ENDIF
C
	IF(CMD.EQ.2)THEN		!Refraction_coefficient
	  IF(CMDRCT.NE.1)THEN
	    CALL WRITEF(
     & '%S Specifying command SET REFRACTION_COEFFICIENT',ERROR_BELL)
	    CALL WRITEF('Command requires 1 real argument')
	    GOTO 10
	  ENDIF
C
	  REFRACT = REALAR(1)
	  GOTO 10
	ENDIF
C
	GOTO 10
C
C----------------------------------------------------------------------------
C	UNITS
C
700	CMD=RDCOMM(UNIT_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  CALL WRITEF('%S Specifying command UNITS',ERROR_BELL)
	  CALL WRITEF('Command qualifiers are: 
     & MATRIX, METRES, PROJECTION, SECONDS, or LATLONG ')
	  GOTO 10
	ENDIF
C
C	Test whether units is valid
	IERR = DTI_UNITS(1,CMD)
	IF(.NOT.IERR)THEN
	  IF(IERR.EQ.DTI__INVUNITS)THEN
	    CALL WRITEF('%S Specifying command UNITS',ERROR_BELL)
	    CALL WRITEF('Command qualifier is invalid for the input file')
	  ELSE
	    UNITS=1		!matrix units
	  ENDIF
	  GOTO 10
	ENDIF
C
	UNITS=CMD
	GOTO 10
C
C----------------------------------------------------------------------------
C	SPAWN DCL process - primarily designed for file management
C
800	I=0
C
810	IF(RDCH(CH))THEN
	  GOTO 820
	ELSE	
	  I=I+1
	  LINE(I:I)=CHAR(CH)
	  GOTO 810
	ENDIF
C
820	IF(I.EQ.0)THEN
	  CALL WRITEF('%S Specifying command SPAWN',ERROR_BELL)
	  CALL WRITEF('Command requires a valid DCL command')
	  GOTO 10
	ENDIF
C
C cancel CTRL/C recognition during spawn
	IF (.NOT.CMDFIL) CALL SET_OUTBAND_AST
	IERR= LIB$SPAWN ( LINE(1:MIN(I,255)))
	IF (.NOT.CMDFIL) CALL SET_OUTBAND_AST(CTRLCAST,8)
	IF(.NOT.IERR)THEN
          CALL LIB$SIGNAL(%VAL(IERR)) 		!error
	  CALL WRITEF('%S Unable to spawn command, returning to COVER',
     &              ERROR_BELL)
	ELSE
	  CALL WRITEF(' ')
	ENDIF
C
	GOTO 10
C
C------------------------------------------------------------------------
C	table POSITION
C
850	IF (.NOT.MAP_SET)THEN
	  CALL WRITEF(
     & '%S Specifying command POSITION using puck button',ERROR_BELL)
	  CALL WRITEF('No map set up has been performed')
	  GOTO 10
	ENDIF
C
	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
C
C	X1=NINT(R3)
C	Y1=NINT(R4)
C
	X1=R3
	Y1=R4
C
C	Check that the point lies within the bounds of the DTM
	IF (X1.LT.1 .OR. X1.GT.X_EXTENT(1) .OR.
     &      Y1.LT.1 .OR. Y1.GT.Y_EXTENT(1)) THEN
	   CALL WRITEF(
     & '%S Specifying command POSITION from the puck button',ERROR_BELL)
	   CALL WRITEF('Point must lie within DTM bounds')
	   GOTO 10
	ENDIF
C
	DTI_OBSERVERS(NUM_OBSERVERS,1) = X1
	DTI_OBSERVERS(NUM_OBSERVERS,2) = Y1
C
	POS_OBSERVERS(NUM_OBSERVERS,1) =
     &		(DTI_OBSERVERS(NUM_OBSERVERS,1)-1) * X_GRID(1)
	POS_OBSERVERS(NUM_OBSERVERS,2)=
     &		(DTI_OBSERVERS(NUM_OBSERVERS,2)-1) * Y_GRID(1)
C
	GOTO 950
C
C-----------------------------------------------------------------------
C	POSITION	- get observer position
C
900	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
C
	  GOTO 10
	ENDIF
C
	IF (.NOT.DTILUN_INUSE(1)) THEN
	  CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	  CALL WRITEF('The input DTM is undefined')
	  GOTO 10
	ENDIF
C
	IF (CMDRCT.NE.2) THEN
	  CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	  CALL WRITEF('Command requires 2 x y coordinate values')
	  GOTO 10
	ENDIF
C
C	Branch according to current UNITS setting
	GOTO (910,920,930,940,945) UNITS
C
C----------------------------------------------------------------------
C	Matrix 
C
910	CONTINUE
C
C	DTI_OBSERVERS(NUM_OBSERVERS,1) = NINT(REALAR(1))
C	DTI_OBSERVERS(NUM_OBSERVERS,2) = NINT(REALAR(2))
C
	DTI_OBSERVERS(NUM_OBSERVERS,1) = REALAR(1)
	DTI_OBSERVERS(NUM_OBSERVERS,2) = REALAR(2)
C
        POS_OBSERVERS(NUM_OBSERVERS,1) =
     &          (DTI_OBSERVERS(NUM_OBSERVERS,1)-1) * X_GRID(1)
	POS_OBSERVERS(NUM_OBSERVERS,2) =
     &	        (DTI_OBSERVERS(NUM_OBSERVERS,2)-1) * Y_GRID(1)
C
	GOTO 950
C
C----------------------------------------------------------------------
C	Metres
C
920     CONTINUE
C
	IF (ABSOLUTE) THEN
	  POS_OBSERVERS(NUM_OBSERVERS,1) = REALAR(1)-X_OFFSET(1)
          POS_OBSERVERS(NUM_OBSERVERS,2) = REALAR(2)-Y_OFFSET(1)
C
C	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
C     &  	NINT(POS_OBSERVERS(NUM_OBSERVERS,1)/X_GRID(1)) + 1
C	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
C     &		NINT(POS_OBSERVERS(NUM_OBSERVERS,2)/Y_GRID(1)) + 1
C
	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
     &  	POS_OBSERVERS(NUM_OBSERVERS,1)/X_GRID(1) + 1
	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
     &		POS_OBSERVERS(NUM_OBSERVERS,2)/Y_GRID(1) + 1

	ELSE
	  POS_OBSERVERS(NUM_OBSERVERS,1)=REALAR(1)
          POS_OBSERVERS(NUM_OBSERVERS,2)=REALAR(2)
C
C	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
C     &  	NINT(POS_OBSERVERS(NUM_OBSERVERS,1)/X_GRID(1)) + 1
C	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
C     &		NINT(POS_OBSERVERS(NUM_OBSERVERS,2)/Y_GRID(1)) + 1
C
          DTI_OBSERVERS(NUM_OBSERVERS,1) =
     &  	POS_OBSERVERS(NUM_OBSERVERS,1)/X_GRID(1) + 1
	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
     &		POS_OBSERVERS(NUM_OBSERVERS,2)/Y_GRID(1) + 1
	ENDIF
C
	GOTO 950
C
C----------------------------------------------------------------------
C	Seconds
C
930	CONTINUE
C
	R1 = (REALAR(1)*10)-LATREC(1,1)
	R2 = (REALAR(2)*10)-LONREC(1,1)
C
C	DTI_OBSERVERS(NUM_OBSERVERS,1) = 1 + NINT(R2/LONINT(1))
C	DTI_OBSERVERS(NUM_OBSERVERS,2) = 1 + NINT(R1/LATINT(1))
C
	DTI_OBSERVERS(NUM_OBSERVERS,1) = 1 + R2/LONINT(1)
	DTI_OBSERVERS(NUM_OBSERVERS,2) = 1 + R1/LATINT(1)
C
  	POS_OBSERVERS(NUM_OBSERVERS,1) =
     &		DTI_OBSERVERS(NUM_OBSERVERS,1)*X_GRID(1)
  	POS_OBSERVERS(NUM_OBSERVERS,2) =
     &		DTI_OBSERVERS(NUM_OBSERVERS,2)*Y_GRID(1)
C
	GOTO 950
C
C----------------------------------------------------------------------
C	Degrees, Minutes & Seconds - Call READLL to convert to .1 seconds
C
940     CONTINUE
C
	IF (READLL(LLDEGS,2))THEN
          CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	  CALL WRITEF
     &	    ('Latitude and longitude values supplied in wrong format')
	  GOTO 10
	ELSE			!convert from seconds of arc to DTI matrix
	  Y1=LLDEGS(1)*10
	  X1=LLDEGS(2)*10
C
	  DTI_OBSERVERS(NUM_OBSERVERS,1)=((X1-LONREC(1,1))/LONINT(1))+1
	  DTI_OBSERVERS(NUM_OBSERVERS,2)=((Y1-LATREC(1,1))/LATINT(1))+1
C
  	  POS_OBSERVERS(NUM_OBSERVERS,1) =
     &		DTI_OBSERVERS(NUM_OBSERVERS,1)*X_GRID(1)
  	  POS_OBSERVERS(NUM_OBSERVERS,2) =
     &		DTI_OBSERVERS(NUM_OBSERVERS,2)*Y_GRID(1)
	ENDIF
C
	GOTO 950
C
C-----------------------------------------------------------------------
C	Projection units
C
945     IF (ABSOLUTE)THEN
	  POS_OBSERVERS(NUM_OBSERVERS,1)=REALAR(1)-DTIPROJ_ORIGIN(1,1)
          POS_OBSERVERS(NUM_OBSERVERS,2)=REALAR(2)-DTIPROJ_ORIGIN(2,1)
C
C	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
C     &      NINT(POS_OBSERVERS(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1)) + 1
C	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
C     &	     NINT(POS_OBSERVERS(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1)) + 1
C
	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
     &		POS_OBSERVERS(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1) + 1
	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
     &		POS_OBSERVERS(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1) + 1
C
	ELSE
	  POS_OBSERVERS(NUM_OBSERVERS,1) = REALAR(1)
          POS_OBSERVERS(NUM_OBSERVERS,2) = REALAR(2)
C
C	  DTI_OBSERVERS(NUM_OBSERVERS,1)=
C     &  	NINT(POS_OBSERVERS(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1))+1
C	  DTI_OBSERVERS(NUM_OBSERVERS,2)=
C     &		NINT(POS_OBSERVERS(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1))+1
C
	  DTI_OBSERVERS(NUM_OBSERVERS,1) =
     &  	POS_OBSERVERS(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1) + 1
	  DTI_OBSERVERS(NUM_OBSERVERS,2) =
     &		POS_OBSERVERS(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1) + 1
	ENDIF
C
C--------------------------------------------------------------------
C	Warning if outside window or outside DTM
C
950	IF (DTI_OBSERVERS(NUM_OBSERVERS,1).LT.1 .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,1).GT.X_EXTENT(1) .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,2).LT.1 .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,2).GT.Y_EXTENT(1))THEN
	  CALL WRITEF('%S Observer position outside DTM bounds',WARN_BELL)
	  GOTO 955
	ENDIF
C	  
	IF (DTI_OBSERVERS(NUM_OBSERVERS,1).LT.DTI_WINDOW_SWX(1) .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,1).GT.DTI_WINDOW_NEX(1) .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,2).LT.DTI_WINDOW_SWY(1) .OR.
     &      DTI_OBSERVERS(NUM_OBSERVERS,2).GT.DTI_WINDOW_NEY(1)) THEN
	  CALL WRITEF
     & 	     ('%S Observer position outside current area of interest',
     &  	  WARN_BELL)
	ENDIF
C
C	Now set distance in metres ...
C
955	IF (HAD_TARGET(NUM_OBSERVERS)) THEN
	  DIFFX = POS_TARGET(NUM_OBSERVERS,1) -
     &		  POS_OBSERVERS(NUM_OBSERVERS,1)
	  DIFFY = POS_TARGET(NUM_OBSERVERS,2) -
     &		  POS_OBSERVERS(NUM_OBSERVERS,2)
C
	  IF (DIFFX.EQ.0 .AND. DIFFY.EQ.0) THEN
	    DIS_OBSERVERS(NUM_OBSERVERS,2) = 0.0
	    DIS_OBSERVERS(NUM_OBSERVERS,1) = 0.0
	    GOTO 960
	  ENDIF
C
     	  DIS_OBSERVERS(NUM_OBSERVERS,2) =		! in metres
     &			 SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
C
C and direction....
C
	  DIR_OBSERVERS(NUM_OBSERVERS) = ATAN2(DIFFX,DIFFY)*180.0/PI
C
	  IF (DIR_OBSERVERS(NUM_OBSERVERS).LT.0.0)
     &	  		DIR_OBSERVERS(NUM_OBSERVERS) =
     &	                DIR_OBSERVERS(NUM_OBSERVERS) + 360.0
C
C ... and DTI units
C
C	  DIFFX = FLOAT( DTI_TARGET(NUM_OBSERVERS,1) -
C     &		         DTI_OBSERVERS(NUM_OBSERVERS,1))
C	  DIFFY = FLOAT( DTI_TARGET(NUM_OBSERVERS,2) -
C     &		         DTI_OBSERVERS(NUM_OBSERVERS,2))
C
	  DIFFX = (DTI_TARGET(NUM_OBSERVERS,1) -
     &		         DTI_OBSERVERS(NUM_OBSERVERS,1))
	  DIFFY = (DTI_TARGET(NUM_OBSERVERS,2) -
     &		         DTI_OBSERVERS(NUM_OBSERVERS,2))
C
	  DIS_OBSERVERS(NUM_OBSERVERS,1) =
     &		 	SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
C
	ENDIF
C	
C Test if inside or ouside the matrix
C
960	INSIDE_MAT(NUM_OBSERVERS) = .FALSE.
C
	IF (DTI_OBSERVERS(NUM_OBSERVERS,1).LT.1 .OR.
     &	    DTI_OBSERVERS(NUM_OBSERVERS,1).GT.X_EXTENT(1) .OR.
     &	    DTI_OBSERVERS(NUM_OBSERVERS,2).LT.1 .OR.
     &	    DTI_OBSERVERS(NUM_OBSERVERS,2).GT.Y_EXTENT(1)) THEN
C
	  CALL COVER_PRINT_OBSERVERS
	  GOTO 10
	ENDIF
C
	INSIDE_MAT(NUM_OBSERVERS)   = .TRUE.
C
	X1 = DTI_OBSERVERS(NUM_OBSERVERS,1)
	Y1 = DTI_OBSERVERS(NUM_OBSERVERS,2)
C
C Since inside, get the height of the observer from the DTM
C If BILINEAR, interpolate from 4 neighbours
C
C Get the nearest pixel height in case 	BILINEAR is disabled later,
C or vice-versa
C
	  IX = NINT(X1)
	  IY = NINT(Y1)
C
	  RETVAL = DTI_READ_WORD_DATA  (1,
     &					HEIGHT,
     &					IX,
     &					IY)
C
	  IF (RETVAL.NE.DTI__NORMAL) THEN
	    CALL LSL_PUTMSG(RETVAL)
	    GOTO 9000
	  ENDIF
C
	  IF (.NOT.BILINEAR .AND. HEIGHT.EQ.-32767) THEN
            CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	    CALL WRITEF('The observer is located in a NULL area')
C
	    DTI_OBSERVERS(NUM_OBSERVERS,1)=0
	    DTI_OBSERVERS(NUM_OBSERVERS,2)=0
	    POS_OBSERVERS(NUM_OBSERVERS,1)=0
	    POS_OBSERVERS(NUM_OBSERVERS,2)=0
C
	    GOTO 10
	  ENDIF
C
C Get the interpolated height from 4 surrounding pixels
C
	  LOWX  = INT(X1)
	  HIGHX = LOWX + 1
	  LOWY  = INT(Y1)
	  HIGHY = LOWY + 1
C
	  RETVAL = DTI_READ_WORD_DATA  (1,
     &					HEIGHT1,
     &					LOWX,
     &					LOWY)
C
	  IF (RETVAL.NE.DTI__NORMAL) THEN
	    CALL LSL_PUTMSG(RETVAL)
	    GOTO 9000
	  ENDIF
C
	  RETVAL = DTI_READ_WORD_DATA  (1,
     &					HEIGHT2,
     &					LOWX,
     &					HIGHY)
C
	  IF (RETVAL.NE.DTI__NORMAL) THEN
	    CALL LSL_PUTMSG(RETVAL)
	    GOTO 9000
	  ENDIF
C
	  RETVAL = DTI_READ_WORD_DATA  (1,
     &					HEIGHT3,
     &					HIGHX,
     &					HIGHY)
C
	  IF (RETVAL.NE.DTI__NORMAL) THEN
	    CALL LSL_PUTMSG(RETVAL)
	    GOTO 9000
	  ENDIF
C
	  RETVAL = DTI_READ_WORD_DATA  (1,
     &					HEIGHT4,
     &					HIGHX,
     &					LOWY)
C
	  IF (RETVAL.NE.DTI__NORMAL) THEN
	    CALL LSL_PUTMSG(RETVAL)
	    GOTO 9000
	  ENDIF
C
	  IF (HEIGHT1.EQ.-32767 .OR. HEIGHT2.EQ.-32767 .OR.
     &	      HEIGHT3.EQ.-32767 .OR. HEIGHT4.EQ.-32767) THEN
 	    CALL WRITEF('%S Specifying command POSITION',ERROR_BELL)
	    CALL WRITEF('The observer is located near a NULL area:')
	    CALL WRITEF('No height interpolation is possible')
C
	    DTI_OBSERVERS(NUM_OBSERVERS,1)=0
	    DTI_OBSERVERS(NUM_OBSERVERS,2)=0
	    POS_OBSERVERS(NUM_OBSERVERS,1)=0
	    POS_OBSERVERS(NUM_OBSERVERS,2)=0
	    GOTO 10
	  ENDIF
C
C Got an interpolated height from the 4 surrounding heights
C
	  DX = X1 - LOWX
	  DY = Y1 - LOWY
C
	  RHEIGHT = HEIGHT1 * (1.0-DX) * (1.0-DY) + 
     &		    HEIGHT2 * (1.0-DX) * DY       +
     &		    HEIGHT3 * DX * DY             +
     &		    HEIGHT4 * DX * (1.0-DY)
C
C Save these heights
C
	  NEAREST_PIXEL_HEIGHT(NUM_OBSERVERS) = FLOAT(HEIGHT)
	  GROUND_HEIGHT(NUM_OBSERVERS)        = FLOAT(HEIGHT)
C
	  INTERPOLATED_HEIGHT(NUM_OBSERVERS)  = RHEIGHT
	  INT_GND_HEIGHT(NUM_OBSERVERS)       = RHEIGHT
C
	  IF (BILINEAR) THEN
	    POS_OBSERVERS(NUM_OBSERVERS,3) = RHEIGHT
	  ELSE
	    POS_OBSERVERS(NUM_OBSERVERS,3) = FLOAT(HEIGHT)
	  ENDIF
C
	CALL COVER_PRINT_OBSERVERS
	GOTO 10
C
C-------------------------------------------------------------------------
C	HEIGHT 	- set the observers height above the terrain surface
C
1000	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command HEIGHT',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (CMDRCT.NE.1) THEN
	  CALL WRITEF('%S Specifying command HEIGHT',ERROR_BELL)
	  CALL WRITEF('Command requires 1 real argument')
	  GOTO 10
	ENDIF
C
	IF (INSIDE_MAT(NUM_OBSERVERS)) THEN
	  INTERPOLATED_HEIGHT(NUM_OBSERVERS) =
     &			INT_GND_HEIGHT(NUM_OBSERVERS) + REALAR(1)
	  NEAREST_PIXEL_HEIGHT(NUM_OBSERVERS) =
     &			GROUND_HEIGHT(NUM_OBSERVERS)  + REALAR(1)
C
	  IF (BILINEAR) THEN
	    POS_OBSERVERS(NUM_OBSERVERS,3) =
     &			INT_GND_HEIGHT(NUM_OBSERVERS) + REALAR(1)
	  ELSE
	    POS_OBSERVERS(NUM_OBSERVERS,3) =
     &			GROUND_HEIGHT(NUM_OBSERVERS)  + REALAR(1)
	  ENDIF
C
	ELSE
	  POS_OBSERVERS(NUM_OBSERVERS,3)      = REALAR(1)
	  INTERPOLATED_HEIGHT(NUM_OBSERVERS)  = REALAR(1)
	  NEAREST_PIXEL_HEIGHT(NUM_OBSERVERS) = REALAR(1)
	ENDIF
C
	GOTO 10
C
C---------------------------------------------------------------------------
C	CONE	- set the observers cone of vision
C
1100	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command CONE',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (CMDRCT.NE.1)THEN
	  CALL WRITEF('%S Specifying command CONE',ERROR_BELL)
	  CALL WRITEF('Command requires 1 real argument')
	  GOTO 10
	ENDIF
C
	IF (REALAR(1).GT.360.0 .OR. REALAR(1).LT.1.0) THEN
	  CALL WRITEF('%S Specifying command CONE',ERROR_BELL)
	  CALL WRITEF('Command argument should be in range 1.0 to 360.0')
	  GOTO 10
	ENDIF
C
	CON_OBSERVERS(NUM_OBSERVERS) = REALAR(1)
C
	IF (CON_OBSERVERS(NUM_OBSERVERS).EQ.360.0)
     &		DIR_OBSERVERS(NUM_OBSERVERS) = 0.0	! default direction
C
	GOTO 10
C
C***********************************************************************
C	DIRECTION 	- set the observers direction of view
C
1200	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command DIRECTION',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (CMDRCT.NE.1) THEN
	  CALL WRITEF('%S Specifying command DIRECTION',ERROR_BELL)
	  CALL WRITEF('Command requires 1 real argument')
	  GOTO 10
	ENDIF
C
	IF (REALAR(1).GT.360.0 .OR. REALAR(1).LT.0.0) THEN
	  CALL WRITEF('%S Specifying command DIRECTION',ERROR_BELL)
	  CALL WRITEF('Command argument should be in range 0.0 to 360.0')
	  GOTO 10
	ENDIF
C
	IF (REALAR(1).EQ.360.0) REALAR(1) = 0.0
	DIR_OBSERVERS(NUM_OBSERVERS) = REALAR(1)
C
	IF (CON_OBSERVERS(NUM_OBSERVERS).EQ.360.0)
     &	    CON_OBSERVERS(NUM_OBSERVERS) = 90.0	! default cone of vision
C						! if direction is specified.
	GOTO 10
C
C***********************************************************************
C	DISTANCE 	- set the observers distance from target site
C
1300	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command DISTANCE',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (CMDRCT.NE.1) THEN
	  CALL WRITEF('%S Specifying command DISTANCE',ERROR_BELL)
	  CALL WRITEF('Command requires 1 real argument')
	  GOTO 10
	ENDIF
C
C	Branch according to UNITS qualifier
C	If UNITS is latlong or seconds, assume distance is specified
C	in metres.
C
	GOTO (1310,1320,1320,1320) UNITS
C
C----------------------------------------------------------------------
C	Distance in matrix units
C
1310	DIS_OBSERVERS(NUM_OBSERVERS,1) = REALAR(1)
C
	IF (DIS_OBSERVERS(NUM_OBSERVERS,1).EQ.0) THEN
	  DTI_TARGET(NUM_OBSERVERS,1)=0
	  DTI_TARGET(NUM_OBSERVERS,2)=0
	  POS_TARGET(NUM_OBSERVERS,1)=0 
	  POS_TARGET(NUM_OBSERVERS,2)=0
	  LAST_DTI_TARGET(1)=DTI_TARGET(NUM_OBSERVERS,1)
	  LAST_DTI_TARGET(2)=DTI_TARGET(NUM_OBSERVERS,2)
	  LAST_POS_TARGET(1)=POS_TARGET(NUM_OBSERVERS,1)	  
	  LAST_POS_TARGET(2)=POS_TARGET(NUM_OBSERVERS,2)
	  GOTO 10
	ENDIF
C
	IF (CON_OBSERVERS(NUM_OBSERVERS).EQ.360.0) THEN
C	calculate distance in x direction (we have to make some	decision)
C
	  DIS_OBSERVERS(NUM_OBSERVERS,2) =
     &	  DIS_OBSERVERS(NUM_OBSERVERS,1)*X_GRID(1)
	ELSE
C
C calculate distance in metres along direction of view	
	  RAD_ANGLE = DIR_OBSERVERS(NUM_OBSERVERS) * PI/180.0
C
	  DTI_TARGET(NUM_OBSERVERS,1) = NINT(
     &		 DTI_OBSERVERS(NUM_OBSERVERS,1) +
     &		(DIS_OBSERVERS(NUM_OBSERVERS,1) * SIN(RAD_ANGLE)) )
	  DTI_TARGET(NUM_OBSERVERS,2) = NINT(
     &		 DTI_OBSERVERS(NUM_OBSERVERS,2) +
     &		(DIS_OBSERVERS(NUM_OBSERVERS,1) * COS(RAD_ANGLE)) )
C
	  POS_TARGET(NUM_OBSERVERS,1) = DTI_TARGET(NUM_OBSERVERS,1) *
     &							X_GRID(1)
	  POS_TARGET(NUM_OBSERVERS,2) = DTI_TARGET(NUM_OBSERVERS,2) *
     &							Y_GRID(1)
C
C make these last target values
	  LAST_DTI_TARGET(1) = DTI_TARGET(NUM_OBSERVERS,1)
	  LAST_DTI_TARGET(2) = DTI_TARGET(NUM_OBSERVERS,2)
	  LAST_POS_TARGET(1) = POS_TARGET(NUM_OBSERVERS,1)
	  LAST_POS_TARGET(2) = POS_TARGET(NUM_OBSERVERS,2)
C
C use pythag
	  DIFFX = POS_TARGET(NUM_OBSERVERS,1) -
     &		  POS_OBSERVERS(NUM_OBSERVERS,1)
	  DIFFY = POS_TARGET(NUM_OBSERVERS,2) -
     &		  POS_OBSERVERS(NUM_OBSERVERS,2)
     	  DIS_OBSERVERS(NUM_OBSERVERS,2) =
     &		      SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
	ENDIF
	GOTO 10
C
C-------------------------------------------------------------------
C	Distance in metres
C
1320	DIS_OBSERVERS(NUM_OBSERVERS,2) = REALAR(1)
C
	IF (DIS_OBSERVERS(NUM_OBSERVERS,2).EQ.0) THEN
	  DTI_TARGET(NUM_OBSERVERS,1)=0
	  DTI_TARGET(NUM_OBSERVERS,2)=0
	  POS_TARGET(NUM_OBSERVERS,1)=0 
	  POS_TARGET(NUM_OBSERVERS,2)=0
	  LAST_DTI_TARGET(1)=DTI_TARGET(NUM_OBSERVERS,1)
	  LAST_DTI_TARGET(2)=DTI_TARGET(NUM_OBSERVERS,2)
	  LAST_POS_TARGET(1)=POS_TARGET(NUM_OBSERVERS,1)	  
	  LAST_POS_TARGET(2)=POS_TARGET(NUM_OBSERVERS,2)
	  GOTO 10
	ENDIF
C
	IF (CON_OBSERVERS(NUM_OBSERVERS).EQ.360.0) THEN
C	  DIS_OBSERVERS(NUM_OBSERVERS,1) =
C     &	  	FLOAT(NINT(DIS_OBSERVERS(NUM_OBSERVERS,2)/X_GRID(1)))
C
	  DIS_OBSERVERS(NUM_OBSERVERS,1) =
     &	  	DIS_OBSERVERS(NUM_OBSERVERS,2)/X_GRID(1)
	ELSE
C
C calculate distance in in DTI units along direction of view
C
	  RAD_ANGLE = DIR_OBSERVERS(NUM_OBSERVERS)*PI/180.0
C
	  POS_TARGET(NUM_OBSERVERS,1) = POS_OBSERVERS(NUM_OBSERVERS,1)
     &		+ (DIS_OBSERVERS(NUM_OBSERVERS,2) * SIN(RAD_ANGLE))
	  POS_TARGET(NUM_OBSERVERS,2) = POS_OBSERVERS(NUM_OBSERVERS,2)
     &		+ (DIS_OBSERVERS(NUM_OBSERVERS,2) * COS(RAD_ANGLE))
C
	  DTI_TARGET(NUM_OBSERVERS,1) = NINT(
     &	    POS_TARGET(NUM_OBSERVERS,1)/X_GRID(1))
	  DTI_TARGET(NUM_OBSERVERS,2) = NINT(
     &	    POS_TARGET(NUM_OBSERVERS,2)/Y_GRID(1))
C
C	Make these last target values
	  LAST_DTI_TARGET(1)=DTI_TARGET(NUM_OBSERVERS,1)
	  LAST_DTI_TARGET(2)=DTI_TARGET(NUM_OBSERVERS,2)
	  LAST_POS_TARGET(1)=POS_TARGET(NUM_OBSERVERS,1)
	  LAST_POS_TARGET(2)=POS_TARGET(NUM_OBSERVERS,2)
C
CC	  HAD_TARGET(NUM_OBSERVERS) = .TRUE.
C
C	  DIFFX=FLOAT(DTI_TARGET(NUM_OBSERVERS,1) -
C     &		      DTI_OBSERVERS(NUM_OBSERVERS,1))
C	  DIFFY=FLOAT(DTI_TARGET(NUM_OBSERVERS,2) -
C     &		      DTI_OBSERVERS(NUM_OBSERVERS,2))
C
	  DIFFX = (DTI_TARGET(NUM_OBSERVERS,1) -
     &		   DTI_OBSERVERS(NUM_OBSERVERS,1))
	  DIFFY = (DTI_TARGET(NUM_OBSERVERS,2) -
     &		   DTI_OBSERVERS(NUM_OBSERVERS,2))
C
     	  DIS_OBSERVERS(NUM_OBSERVERS,1) =
     &		      SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
	ENDIF
C
	GOTO 10
C
C***********************************************************************
C table TARGET
C
1380	IF (.NOT.MAP_SET) THEN
	  CALL WRITEF
     &    ('%S Specifying command TARGET using puck button',ERROR_BELL)
	  CALL WRITEF('No map set up has been performed')
	  GOTO 10
	ENDIF
C
	IF (NUM_OBSERVERS.EQ.0)THEN
	  CALL WRITEF('%S Specifying command TARGET',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
C
	  GOTO 10
	ENDIF
C
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
C
	X1=NINT(R3)
	Y1=NINT(R4)
C
C	Check that the point lies within the bounds of the DTM
	IF (X1.LT.1 .OR. X1.GT.X_EXTENT(1) .OR.
     &      Y1.LT.1 .OR. Y1.GT.Y_EXTENT(1)) THEN
	   CALL WRITEF(
     &   '%S Specifying command TARGET from the puck button',ERROR_BELL)
	   CALL WRITEF('Point must lie within DTM bounds')
	   GOTO 10
	ENDIF
C
	DTI_TARGET(NUM_OBSERVERS,1) = X1
	DTI_TARGET(NUM_OBSERVERS,2) = Y1
	POS_TARGET(NUM_OBSERVERS,1) =
     &		(DTI_TARGET(NUM_OBSERVERS,1)-1)*X_GRID(1)
	POS_TARGET(NUM_OBSERVERS,2)=
     &		(DTI_TARGET(NUM_OBSERVERS,2)-1)*Y_GRID(1)
	GOTO 1450
C
C***********************************************************************
C	TARGET 	- define position of target site
C
1400	IF (.NOT.DTILUN_INUSE(1)) THEN
	  CALL WRITEF('%S Specifying command TARGET',ERROR_BELL)
	  CALL WRITEF('The input DTM is undefined')
	  GOTO 10
	ENDIF
C	
	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command TARGET',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (UNITS.NE.4 .AND. CMDRCT.NE.2) THEN
	  CALL WRITEF('%S Specifying command TARGET',ERROR_BELL)
	  CALL WRITEF('Command requires 2 real arguments')
	  GOTO 10
	ENDIF
C
C	Branch according to units
	GOTO (1410,1420,1430,1440,1445)UNITS
C
C----------------------------------------------------------------------
C	Matrix units
C
1410	DTI_TARGET(NUM_OBSERVERS,1) = NINT(REALAR(1))
	DTI_TARGET(NUM_OBSERVERS,2) = NINT(REALAR(2))
	POS_TARGET(NUM_OBSERVERS,1) =
     &	          (DTI_TARGET(NUM_OBSERVERS,1)-1)*X_GRID(1)
	POS_TARGET(NUM_OBSERVERS,2)=
     &	          (DTI_TARGET(NUM_OBSERVERS,2)-1)*Y_GRID(1)
	GOTO 1450
C
C----------------------------------------------------------------------
C	Metres
C
1420	IF (ABSOLUTE) THEN
	  POS_TARGET(NUM_OBSERVERS,1) = REALAR(1)-X_OFFSET(1)
	  POS_TARGET(NUM_OBSERVERS,2) = REALAR(2)-Y_OFFSET(1)
	  DTI_TARGET(NUM_OBSERVERS,1) =
     &	    NINT(POS_TARGET(NUM_OBSERVERS,1)/X_GRID(1))+1
	  DTI_TARGET(NUM_OBSERVERS,2) =
     &	    NINT(POS_TARGET(NUM_OBSERVERS,2)/Y_GRID(1))+1
	ELSE
	  POS_TARGET(NUM_OBSERVERS,1) = REALAR(1)
	  POS_TARGET(NUM_OBSERVERS,2) = REALAR(2)
	  DTI_TARGET(NUM_OBSERVERS,1) =
     &	    NINT(POS_TARGET(NUM_OBSERVERS,1)/X_GRID(1))+1
	  DTI_TARGET(NUM_OBSERVERS,2) =
     &	    NINT(POS_TARGET(NUM_OBSERVERS,2)/Y_GRID(1))+1
	ENDIF
C
	GOTO 1450
C
C----------------------------------------------------------------------
C	Seconds
C
1430	R1=REALAR(1)*10
	R2=REALAR(2)*10
C
	DTI_TARGET(NUM_OBSERVERS,1) = NINT(
     &	  	  ((R2-LONREC(1,1))/LONINT(1))) + 1
	DTI_TARGET(NUM_OBSERVERS,2) = NINT(
     &	  	  ((R1-LATREC(1,1))/LATINT(1))) + 1
  	POS_TARGET(NUM_OBSERVERS,1) =
     &	   	  DTI_TARGET(NUM_OBSERVERS,1)*X_GRID(1)
  	POS_TARGET(NUM_OBSERVERS,2) =
     &		  DTI_TARGET(NUM_OBSERVERS,2)*Y_GRID(1)
C
	GOTO 1450
C
C-----------------------------------------------------------------------
C	Degrees, Minutes and Seconds - convert to .1 seconds
C
1440	IF (READLL(LLDEGS,2)) THEN
          CALL WRITEF
     &    ('%S Specifying command TARGET',ERROR_BELL)
	  CALL WRITEF
     &	  ('Latitude and longitude values supplied in wrong format')
	  GOTO 10
	ELSE		!convert from seconds of arc to DTI matrix
	  Y1=LLDEGS(1)*10
	  X1=LLDEGS(2)*10
	  DTI_TARGET(NUM_OBSERVERS,1) =
     &	  	((X1-LONREC(1,1))/LONINT(1))+1
	  DTI_TARGET(NUM_OBSERVERS,2) =
     &	  	((Y1-LATREC(1,1))/LATINT(1))+1
  	  POS_TARGET(NUM_OBSERVERS,1) =
     &		DTI_TARGET(NUM_OBSERVERS,1)*X_GRID(1)
  	  POS_TARGET(NUM_OBSERVERS,2) =
     &		DTI_TARGET(NUM_OBSERVERS,2)*Y_GRID(1)
	ENDIF
C
	GOTO 1450
C
C--------------------------------------------------------------------
C	Projection units
C
1445    IF (ABSOLUTE) THEN
	  POS_TARGET(NUM_OBSERVERS,1) = REALAR(1)-DTIPROJ_ORIGIN(1,1)
          POS_TARGET(NUM_OBSERVERS,2) = REALAR(2)-DTIPROJ_ORIGIN(2,1)
          DTI_TARGET(NUM_OBSERVERS,1) =
     &  	NINT(POS_TARGET(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1))+1
	  DTI_TARGET(NUM_OBSERVERS,2) =
     &		NINT(POS_TARGET(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1))+1
	ELSE
	  POS_TARGET(NUM_OBSERVERS,1) = REALAR(1)
          POS_TARGET(NUM_OBSERVERS,2) = REALAR(2)
          DTI_TARGET(NUM_OBSERVERS,1) =
     &  	NINT(POS_TARGET(NUM_OBSERVERS,1)/DTIPROJ_SAMPLE(1,1))+1
	  DTI_TARGET(NUM_OBSERVERS,2) =
     &		NINT(POS_TARGET(NUM_OBSERVERS,2)/DTIPROJ_SAMPLE(2,1))+1
	ENDIF
C
C--------------------------------------------------------------------------
C
1450	HAD_TARGET(NUM_OBSERVERS) = .TRUE.
C
	LAST_DTI_TARGET(1)=DTI_TARGET(NUM_OBSERVERS,1)
	LAST_DTI_TARGET(2)=DTI_TARGET(NUM_OBSERVERS,2)
	LAST_POS_TARGET(1)=POS_TARGET(NUM_OBSERVERS,1)
	LAST_POS_TARGET(2)=POS_TARGET(NUM_OBSERVERS,2)
C
C Now set distance and direction of view
C First in metres
C
	DIFFX = POS_TARGET(NUM_OBSERVERS,1) -
     &		POS_OBSERVERS(NUM_OBSERVERS,1)
	DIFFY = POS_TARGET(NUM_OBSERVERS,2) -
     &		POS_OBSERVERS(NUM_OBSERVERS,2)
C
	IF (DIFFX.EQ.0 .AND. DIFFY.EQ.0)THEN
	  DIS_OBSERVERS(NUM_OBSERVERS,1)=0.0
	  DIS_OBSERVERS(NUM_OBSERVERS,2)=0.0
	  GOTO 10
	ENDIF
C
     	DIS_OBSERVERS(NUM_OBSERVERS,2) =
     &		      SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
C
	DIR_OBSERVERS(NUM_OBSERVERS) = ATAN2(DIFFX,DIFFY) * 180.0/PI
C
	IF (DIR_OBSERVERS(NUM_OBSERVERS).LT.0.0)
     &		DIR_OBSERVERS(NUM_OBSERVERS) = 
     &		DIR_OBSERVERS(NUM_OBSERVERS) + 360.0
C 
	IF (CON_OBSERVERS(NUM_OBSERVERS).EQ.360.0)
     &	    CON_OBSERVERS(NUM_OBSERVERS) = 90.0	! default cone of vision
C						! if direction is specified.
C and then in matrix units
C	DIFFX = FLOAT( DTI_TARGET(NUM_OBSERVERS,1) -
C     &		       DTI_OBSERVERS(NUM_OBSERVERS,1) )
C	DIFFY = FLOAT( DTI_TARGET(NUM_OBSERVERS,2) -
C     &		       DTI_OBSERVERS(NUM_OBSERVERS,2) )
C
	DIFFX = (DTI_TARGET(NUM_OBSERVERS,1) -
     &		 DTI_OBSERVERS(NUM_OBSERVERS,1))
	DIFFY = (DTI_TARGET(NUM_OBSERVERS,2) -
     &		 DTI_OBSERVERS(NUM_OBSERVERS,2))
C
     	DIS_OBSERVERS(NUM_OBSERVERS,1) =
     &		      SQRT(DIFFX*DIFFX + DIFFY*DIFFY)
C
	CALL COVER_PRINT_TARGETS
	CALL COVER_PRINT_OBSERVERS
C
	GOTO 10
C
C***********************************************************************
C	DISPLAY - open and display specified file
C
1500	IF(RDCHS(CH))THEN
	  IF(.NOT.WAIT_INPUT('Cover map filename',.FALSE.,.TRUE.))
     &    GOTO 10
	ELSE
	  CALL BSCH				! backspace
	ENDIF
C       
	CALL DISPLAY(.FALSE.)			! display
	GOTO 10
C
C***********************************************************************
C FILEOUT - specify visibility matrix file
C
1600	IF (.NOT.DTILUN_INUSE(1))THEN
	  CALL WRITEF('%S Specifying command FILEOUT',ERROR_BELL)	  
	  CALL WRITEF('The input DTM is undefined')
	  GOTO 10
	ENDIF
C
	IF(RDCHS(CH))THEN
	  IF(.NOT.WAIT_INPUT('Cover map filename',.FALSE.,.TRUE.))
     &    GOTO 10
	ELSE
	  CALL BSCH
	ENDIF
C
C parse the filespec
	IF (.NOT.GET_FILENAME (VIS_NAME,VIS_NAME_LENGTH,
     &                   .FALSE.,.TRUE.)) GOTO 10
C
	CALL WRITEF('File %S selected for output',
     &  VIS_NAME(:VIS_NAME_LENGTH))
	HAD_FILEOUT = .TRUE.
C
	GOTO 10
C
C***********************************************************************
C	CREATE syntax: INPUT,OUTPUT
C
1700	CALL CREATE
	GOTO 10
C
C***********************************************************************
C	SELECT
C	Check for qualifier OBSERVER or ALL
C
1800	CMD=RDCOMM(SELECT_CMD_TABLE)
	IF (CMD.LE.0) THEN	! qualifier unrecognised
	  CALL WRITEF('%S Specifying command SELECT',ERROR_BELL)
	  CALL WRITEF('Command qualifiers are OBSERVER or ALL')
	  GOTO 10 
	ENDIF
C
	IF(CMD.EQ.2)THEN
	  DO 1810 I=1,8
	     SELOBS(I)=.TRUE.		!set all eight to true
1810      CONTINUE
	ENDIF
C
	IF(CMD.EQ.1)THEN
	  IF(CMDICT.EQ.0.OR.CMDICT.GT.7)THEN
	    CALL WRITEF('%S Specifying command SELECT OBSERVER',ERROR_BELL)
	    CALL WRITEF('Command requires at least 1 integer argument')
	    GOTO 10
	  ENDIF
C
C	Initialise SELOBS 	!since selection is supplied
	  DO 1820 I=1,8
	   SELOBS(I)=.FALSE.
1820	  CONTINUE
C
C	Check that observer values are in correct range
	  DO 1830 I=1,CMDICT
	  IF(INTARG(I).LE.0.OR.INTARG(I).GT.8)THEN
	     CALL WRITEF('%S Specifying command SELECT OBSERVER',ERROR_BELL)
	     CALL WRITEF('Integer values should be in the range 1 to 8')
	  ENDIF
	  SELOBS(INTARG(I))=.TRUE.
1830	  CONTINUE
	ENDIF
C
	GOTO 10
C
C-----------------------------------------------------------------------------
C	REDISPLAY
C
1900	CALL DISPLAY(.TRUE.)
	GOTO 10
C
C********************************************************************
C	WAIT
C	Hibernate for specified number of seconds
C
2000	IF (CMDRCT.NE.1)THEN
	  CALL WRITEF('%S Specifying command WAIT',ERROR_BELL)
	  CALL WRITEF('Command requires a real argument')
	  GOTO 10
	ENDIF
C
	CALL LIB$WAIT (REALAR(1))
	GOTO 10
C
C-------------------------------------------------------------------------
C	ENABLE
C	Get the appropriate qualifier
C
2100	CMD = RDCOMM(ENABLE_CMD_TABLE)
C
	IF (CMD.EQ.1) THEN		! earth curvature
	  ECURVE=.TRUE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.2) THEN		! use of culture data
C
C Check if file not given, and already open by default
C
	  IF (RDCHS(CH)) THEN		! no file given
	    IF (HAD_CULFIL) THEN
	      CULTRE=.TRUE.		! select, using existing file
	      CALL WRITEF
     &      	('Use of height values in file %S enabled',
     &	    	  DTI_NAME(7)(1:DTI_NAME_LENGTH(7)))
	      GOTO 10
	    ENDIF
C
	    CALL WRITEF('%S Specifying ENABLE CULTURE command',ERROR_BELL)
	    CALL WRITEF('Matrix filename is missing')
            GOTO 2120
	  ENDIF
C
	  CALL BSCH
C
2110	  IF (OPEN_FILE(7)) GOTO 10	! error already output 
2120	  IF (WAIT_INPUT('Matrix filename',.FALSE.,.TRUE.)) GOTO 2110
	  GOTO 10
C
	ELSEIF (CMD.EQ.3) THEN		! add target option
C
C	Add height in auxiliary matrix to the target position.
C	By default the auxiliary height values are only added to
C	the positions between the observer and target.
C
          ADD_CULT_HEIGHT=.TRUE.
	  IF (.NOT.CULTRE) CALL WRITEF
     & 		   ('*** WARNING *** CULTURE is currently not enabled')
	  GOTO 10
C
	ELSEIF (CMD.EQ.4)THEN		! diagnostics
	  DIAG=.TRUE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.5)THEN		! absolute
	  ABSOLUTE=.TRUE.
	  GOTO 10
C
	ELSEIF(CMD.EQ.6)THEN		! table
	  IF (.NOT.TABLE) THEN
	    IF (INIT_TAB(,IERR)) THEN
	      CALL WRITEF('%S Specifying command ENABLE TABLE',ERROR_BELL)
	      CALL WRITEF('Unable to initialise the table monitor')
	      TABLE=.FALSE.
	      GOTO 10
	    ENDIF
	    TABLE = .TRUE.
C
C 	Set event flag numbers
C
	    CALL RETURN_EFN(EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
	    GOTO 10
	  ENDIF
C
	ELSEIF(CMD.EQ.7) THEN		! bilinear
	   BILINEAR = .TRUE.
	   POS_OBSERVERS(NUM_OBSERVERS,3) = 
     &			INTERPOLATED_HEIGHT(NUM_OBSERVERS) 
C
	   GOTO 10
	ENDIF
C
	CALL WRITEF('%S Specifying command ENABLE',ERROR_BELL)
	CALL WRITEF(
     & 'Command qualifiers are: ABSOLUTE, ADD_TARGET, BILINEAR, ')
	CALL WRITEF(
     & '                        CULTURE, DIAGNOSTICS, EARTH_CURVATURE ')
	CALL WRITEF(
     & '                        or TABLE')
C
	GOTO 10
C
C--------------------------------------------------------------------------
C	DISABLE
C	Get the appropriate qualifier
C
2200	CMD = RDCOMM(ENABLE_CMD_TABLE)
C
	IF (CMD.EQ.1) THEN
	  ECURVE=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.2)THEN
	  CULTRE=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.3) THEN	
	  ADD_CULT_HEIGHT=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.4) THEN
	  DIAG=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.5) THEN
	  ABSOLUTE=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.6) THEN
          IF (TABLE)CALL CLOSE_TAB (IERR)
	  TABLE = .FALSE.
C
C	Reset event flag, and cancel any existing QIOS
	  EF_VDU=1
	  CALL SYS$CANCEL(%VAL(IN_CHAN))
	  HADQIO=.FALSE.
	  GOTO 10
C
	ELSEIF (CMD.EQ.7) THEN
	  BILINEAR = .FALSE.
	  POS_OBSERVERS(NUM_OBSERVERS,3) = 
     &				NEAREST_PIXEL_HEIGHT(NUM_OBSERVERS)
	  GOTO 10
	ENDIF
C
	CALL WRITEF('%S Specifying command DISABLE',ERROR_BELL)
	CALL WRITEF(
     & 'Command qualifiers are: ABSOLUTE, ADD_TARGET, BILINEAR, ')
	CALL WRITEF(
     & '                        CULTURE, DIAGNOSTICS, EARTH_CURVATURE ')
	CALL WRITEF(
     & '                        or TABLE')
C
	GOTO 10
C
C----------------------------------------------------------------------
C	DEFINE
C
2300	CMD = RDCOMM(DEFINE_CMD_TABLE)
	IF (CMD.NE.1)THEN
	  CALL WRITEF('%S Specifying command DEFINE',ERROR_BELL)
	  CALL WRITEF('Command qualifier is OBSERVER')
	  GOTO 10
	ENDIF
C
	IF (CMDICT.NE.1) THEN
	  CALL WRITEF
     &    	('%S Specifying command DEFINE OBSERVER',ERROR_BELL)
	  CALL WRITEF('Command requires 1 integer argument')
	  GOTO 10
	ENDIF
	  
C	Observer selection
	IF (INTARG(1).LT.1 .OR. INTARG(1).GT.MAX_OBSERVERS) THEN
	  CALL WRITEF('%S Specifying command DEFINE OBSERVER',ERROR_BELL)
	  CALL WRITEF(
     & 'Command requires an integer argument in the range 1 to %N',
     & 	MAX_OBSERVERS)
C
	  GOTO 10
	ENDIF
C
	NUM_OBSERVERS=INTARG(1)		!redefine current observer
	HAD_OBSERVERS(INTARG(1))=.TRUE.
	SELOBS(INTARG(1))=.TRUE.	!turned selection of this
C					!observer on by default
C
	IF (LAST_DTI_TARGET(1).EQ.-32767)GOTO 10
C
C	Otherwise preset target position values with previous target pos
C
	DTI_TARGET(NUM_OBSERVERS,1)=LAST_DTI_TARGET(1)
	DTI_TARGET(NUM_OBSERVERS,2)=LAST_DTI_TARGET(2)
	POS_TARGET(NUM_OBSERVERS,1)=LAST_POS_TARGET(1)
	POS_TARGET(NUM_OBSERVERS,2)=LAST_POS_TARGET(2)
	HAD_TARGET(NUM_OBSERVERS)=.TRUE.
	GOTO 10
C
C	Observer selected and position defined using table puck
C
2350	IF (.NOT.MAP_SET) THEN
	  CALL WRITEF
     &    ('%S Defining OBSERVER POSITION using puck button',ERROR_BELL)
	  CALL WRITEF('No map set up has been performed')
	  GOTO 10
	ENDIF
C
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
	X1=NINT(R3)
	Y1=NINT(R4)
C
C	Test point lies inside the DTM
	IF (X1.LT.1 .OR. X1.GT.X_EXTENT(1) .OR.
     &	    Y1.LT.1 .OR. Y1.GT.Y_EXTENT(1)) THEN
	   CALL WRITEF
     &    ('%S Defining OBSERVER POSITION using puck button',ERROR_BELL)
	   CALL WRITEF('Observer position must lie within DTM bounds')
	   GOTO 10
	ENDIF
C
	NUM_OBSERVERS=BUTTON		!redefine current observer
	HAD_OBSERVERS(BUTTON)=.TRUE.
	SELOBS(BUTTON)=.TRUE.		!turn selection of this
C					!observer on by default
C
C	Transfer position values
	DTI_OBSERVERS(NUM_OBSERVERS,1)=NINT(R3)
	DTI_OBSERVERS(NUM_OBSERVERS,2)=NINT(R4)
	POS_OBSERVERS(NUM_OBSERVERS,1)=
     &		(DTI_OBSERVERS(NUM_OBSERVERS,1)-1)*X_GRID(1)
	POS_OBSERVERS(NUM_OBSERVERS,2)=
     &		(DTI_OBSERVERS(NUM_OBSERVERS,2)-1)*Y_GRID(1)
C
C	Preset target position values with previous target pos
C
	IF (LAST_DTI_TARGET(1).NE.-32767) THEN
	  DTI_TARGET(NUM_OBSERVERS,1)=LAST_DTI_TARGET(1)
	  DTI_TARGET(NUM_OBSERVERS,2)=LAST_DTI_TARGET(2)
	  POS_TARGET(NUM_OBSERVERS,1)=LAST_POS_TARGET(1)
	  POS_TARGET(NUM_OBSERVERS,2)=LAST_POS_TARGET(2)
	  HAD_TARGET(NUM_OBSERVERS) = .TRUE.
	ENDIF
C
C	Remaining viewing parameters and height is extracted
C	using POSITION command code
C
	GOTO 950
C	
C-----------------------------------------------------------------------
C	WRITE
C
2400	CALL WRITE_DTI
	GOTO 10
C
C-----------------------------------------------------------------------
C table	POINT
C
2450	IF (.NOT.MAP_SET) THEN
	   CALL WRITEF
     &    ('%S Specifying command POINT using puck button',ERROR_BELL)
	   CALL WRITEF('No map set up has been performed')
	   GOTO 10
	ENDIF
C
	IF (NUM_OBSERVERS.EQ.0) THEN
	   CALL WRITEF('%S Specifying command POINT',ERROR_BELL)
	   CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	   GOTO 10
	ENDIF
C
	R1=X_TAB
	R2=Y_TAB
	CALL TRANSF(TAB_DTI,R1,R2,R3,R4)
C
	DTI_POINT(1) = NINT(R3)
	DTI_POINT(2) = NINT(R4)
	GOTO 2550
C
C 	POINT 	- define position of point whose visibility
C	is to be determined
C
2500	IF (NUM_OBSERVERS.EQ.0) THEN
	  CALL WRITEF('%S Specifying command POINT',ERROR_BELL)
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF(.NOT.DTILUN_INUSE(1))THEN
	  CALL WRITEF('%S Specifying command POINT',ERROR_BELL)	  
	  CALL WRITEF('The input DTM must be specified before POINT')
	  GOTO 10
	ENDIF
C
	IF (UNITS.NE.4 .AND. CMDRCT.NE.2) THEN
	  CALL WRITEF('%S Specifying command POINT',ERROR_BELL)
	  CALL WRITEF('Command requires 2 arguments')
	  GOTO 10
	ENDIF
C
C	Branch according to units
	GOTO (2510,2520,2530,2540,2545)UNITS
C
C----------------------------------------------------------------------
C	Matrix units
C
2510	DTI_POINT(1) = NINT(REALAR(1))
	DTI_POINT(2) = NINT(REALAR(2))
	GOTO 2550
C
C----------------------------------------------------------------------
C	Metres
C
2520	IF (ABSOLUTE) THEN
	  DTI_POINT(1)=NINT((REALAR(1)-X_OFFSET(1))/X_GRID(1))+1
	  DTI_POINT(2)=NINT((REALAR(2)-Y_OFFSET(1))/Y_GRID(1))+1
	ELSE
	  DTI_POINT(1)=NINT(REALAR(1)/X_GRID(1))+1
	  DTI_POINT(2)=NINT(REALAR(2)/Y_GRID(1))+1
	ENDIF
	GOTO 2550
C
C----------------------------------------------------------------------
C	Seconds
C
2530	R1=REALAR(1)*10
	R2=REALAR(2)*10
	DTI_POINT(1)=NINT(((R2-LONREC(1,1))/LONINT(1)))+1
        DTI_POINT(2)=NINT(((R1-LATREC(1,1))/LATINT(1)))+1
	GOTO 2550
C
C-----------------------------------------------------------------------
C	Degrees, Minutes and Seconds - convert to .1 seconds
C
2540	IF (READLL(LLDEGS,2)) THEN
          CALL WRITEF('%S Specifying command POINT',ERROR_BELL)
	  CALL WRITEF
     &	    ('Latitude and longitude values supplied in wrong format')
	  GOTO 10
	ELSE			!convert from seconds of arc to DTI matrix
	  Y1=LLDEGS(1)*10
	  X1=LLDEGS(2)*10
	  DTI_POINT(1)=((X1-LONREC(1,1))/LONINT(1))+1
	  DTI_POINT(2)=((Y1-LATREC(1,1))/LATINT(1))+1
	ENDIF
	GOTO 2550
C
C--------------------------------------------------------------------
C	Projection units
C
2545	IF (ABSOLUTE) THEN
	  DTI_POINT(1)=NINT((REALAR(1)-DTIPROJ_ORIGIN(1,1))
     &   	 /DTIPROJ_ORIGIN(1,1))+1
	  DTI_POINT(2)=NINT((REALAR(2)-DTIPROJ_ORIGIN(2,1))
     &   	 /DTIPROJ_ORIGIN(2,1))+1
	ELSE
	  DTI_POINT(1)=NINT(REALAR(1)/DTIPROJ_ORIGIN(1,1))+1
	  DTI_POINT(2)=NINT(REALAR(2)/DTIPROJ_ORIGIN(2,1))+1
	ENDIF
C
C---------------------------------------------------------------------
C	Test point lies inside the DTM
C
2550	IF (DTI_POINT(1).LT.1 .OR. DTI_POINT(1).GT.X_EXTENT(1).OR.
     &	    DTI_POINT(2).LT.1 .OR. DTI_POINT(2).GT.Y_EXTENT(1))THEN
	   CALL WRITEF('%S Specifying command POINT',ERROR_BELL)
	   CALL WRITEF('Point must lie within DTM bounds')
	   GOTO 10
	ENDIF
C
C	call point to determine visibility, and print out statistics.
C
	CALL POINT(DTI_POINT(1),DTI_POINT(2))
C
	GOTO 10
C
C-----------------------------------------------------------------------
C	RETURN
C
2700	IF (DIRECT)THEN
	  CALL WRITEF('%S Specifying command RETURN',ERROR_BELL)
	  CALL WRITEF('The RETURN command is only valid in a command file')
	  GOTO 10
	ENDIF
C
	CALL WRITEF('Returning to terminal input')
C
2750	RETVAL=FLRCLO(1)
	IF (.NOT.RETVAL) CALL LSL_PUTMSG(RETVAL)
	DIRECT=.TRUE.
	GOTO 10
C
C-------------------------------------------------------------------
C GO command
C
2800	IF (.NOT.DTILUN_INUSE(1))THEN
	  CALL WRITEF('%S Specifying command GO',ERROR_BELL)	  
	  CALL WRITEF('The input DTM is undefined')
	  GOTO 10
	ENDIF
C
	IF (NUM_OBSERVERS.EQ.0)THEN
	  CALL WRITEF('%S Specifying command GO',ERROR_BELL)	  
	  CALL WRITEF(
     &'No observer has been selected with the DEFINE OBSERVER command')
	  GOTO 10
	ENDIF
C
	IF (.NOT. HAD_FILEOUT) THEN
	   CALL WRITEF('%S Specifying command GO',ERROR_BELL)
	   CALL WRITEF('The output visibility matrix has not been defined')
	   GOTO 10
	ENDIF
C
	CALL VISBLE			! calculate intervisibility
	GOTO 10
C
C---------------------------------------------------------------------
C	EXIT/QUIT  	- Close and unmap all open DTIs
C
9000	DO 9100 I=1,MAX_DTI
	   IF (.NOT.DTILUN_INUSE(I)) GOTO 9100
	   RETVAL= DTI_CLOSE(I,.FALSE.,.FALSE.,ERROR)
	   IF (RETVAL.NE.DTI__NORMAL) THEN
	     CALL LSL_PUTMSG(RETVAL)
	     IF (RETVAL.EQ.DTI__SYSERR) CALL LSL_ADDMSG(ERROR)
	   ENDIF
9100	CONTINUE
C
	IF (TABLE) CALL CLOSE_TAB (IERR)
C
	END
C
