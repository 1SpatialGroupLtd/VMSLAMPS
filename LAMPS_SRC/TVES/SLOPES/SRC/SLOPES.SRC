	PROGRAM SLOPES
C
***	MODULE SLOPES
***	IDENT  24AP91
C
C	Copyright Laser-Scan Laboratories Ltd., Cambridge, England
C	Author  D R Catlow 
C
CMOD	More GUWK calls after graphics		     CCB    24-Apr-1991
CMOD	Revamp for new style commands		     MWSR   01-Mar-1989
CMOD	Add +/- PERCENT	command			     MWSR   27-Feb-1989
CMOD    To use LSLLIB RDCOMM error messages          DRC    21-Apr-1988
CMOD    To utilise LSLLIB and extended GKSLDLIB      DRC    11-Nov-1987
CMOD	SPAWN facility added			     DRC    19-May-1987
CMOD	ADD +/- CLASSIFY for DTI file output	     MWSR   20-Mar-1987
CMOD	New slope algorithms incorporated	     DRC       Dec-1986
CMOD	Enlarge/Reduce Mechanism changed	     DRC    11-Jul-1986
CMOD    New menu 				     MWSR      Jul-1986
CMOD	PLOT,ASPECT,COLOUR commands added
C	and other  minor enhancements                MWSR      Jan-1986
CMOD    Tidied up a little, and a few more comments  DRC    09-Dec-1985	
C	Created                                      DRC       Jan-1985
C
C	Program to generate and display either a slope map,
C	aspect map or a shaded overlay. Output is to either
C	a DTI disk file or to the SIGMA ARGS 7000.
C	The display may be annotated with a legend and text.
C	Colour table used may be selected via LUT command.
C
	IMPLICIT NONE
C
	INCLUDE 	'($DVIDEF)'
	INCLUDE		'($DCDEF)'
C
***	PARAMETER/LSL$CMNDTI:DTILIBMSG/
***	PARAMETER/LSL$CMNDTI:DTIPAR/
***	PARAMETER/HERE:GKSPAR/
C
***	COMMON/LSL$CMNLSL:CMDCOM/
***	COMMON/LSL$CMNLSL:TXTC/
***	COMMON/LSL$CMNDTI:DTIHDR/
***	COMMON/HERE:GKS/
***	COMMON/HERE:TRANS/		!tranformation matrices
***	COMMON/HERE:SLPCMN/
***	COMMON/HERE:TAB/		!table common
***	COMMON/HERE:DTIQIO/		!QIO common
C
***	PARAMETER/LSL$CMNLSL:LSLLIBMSG/
C
C ********************************************************************
C Functions called
	LOGICAL		RDREAL
	INTEGER*4	RDCOMM
	LOGICAL		RDLONG
	INTEGER*4	LIB$SPAWN	! spawns DCL operations
	INTEGER*4	SYS$ASSIGN
	LOGICAL		RDCHS
	LOGICAL		RDCH
	INTEGER*4	LIB$GETDVI	! get term characteristics etc.
	INTEGER*4	TEST_TERM
	LOGICAL		GET_DTI_COORDS
	LOGICAL		HAD_PUCK
	LOGICAL		READ_PUCK
	LOGICAL		IN_MENU
	LOGICAL		INIT_TAB
	LOGICAL		WAIT_INPUT
	LOGICAL		OPNFIL		!to open and map DTI file
	LOGICAL		READLL		! reads lat/long
	LOGICAL		PARSE_FILENAME	!to parse output filename
	LOGICAL		TRNALL		!logical name translation
	LOGICAL		DTI_UNITS	!tests UNITS qualifier
	LOGICAL		DISPLAY_INIT	!initialises graphics
	LOGICAL		ASPECT1
	LOGICAL		GRADIENT1
	LOGICAL		GRADIENT2
	LOGICAL		GRADIENT3
	LOGICAL		GRADIENT4
	LOGICAL		ROUGH
	LOGICAL		SHADES
C
C Local
	REAL		X(4),Y(4)
	REAL		R1,R2,R3,R4	!transform values
	REAL		SUN		!sun position
	REAL		DIFFX,DIFFY	! delta value
	INTEGER*4	DTI_NUMBER	!number of mapped DTI file
	INTEGER*4	COMAND		!command number
	INTEGER*4	I		!counter
	INTEGER*4	TOTAL		!used in STEP
	INTEGER*4	X_TAB,Y_TAB	!table coords
	INTEGER*4	X1,Y1,X2,Y2	!temp. DTI coord values
	INTEGER*2	IELEN
	INTEGER*4	CMD		!decoded command number
	LOGICAL		MCMD		!TRUE if command is from menu
	LOGICAL		HAD_ASPECT	!Aspect map chosen
	LOGICAL		HADNEG		!saved CMDNEG value
	LOGICAL		INIT_GRAPHICS	!Graphics initialised
	BYTE		CH		!character variable
	INTEGER*4	WHAT		!what default command ?
C
	INTEGER*4	VAL		! for GETDVI
	LOGICAL		CRT
C
	CHARACTER*34	UNITS(5)	!coord unit definition
	CHARACTER*80	LINE            !holds DCL command line
	CHARACTER*1	TRANSLATION	! log name translation
	CHARACTER*6	PROMPT		! program prompt
	LOGICAL		DISABLE		! DISABLE command ?
	LOGICAL		OK
	INTEGER*4	RET		!return code
C
C	Control C handler
	EXTERNAL	CTRLCAST
	EXTERNAL 	PUT_OUTPUT
C
	EXTERNAL	ENABLE_CMD_TABLE
	EXTERNAL	SLOPE_CMD_TABLE !command table
	INTEGER*4	SLOPE_CMD_TABLE
	EXTERNAL	SHOW _CMD_TABLE
	INTEGER*4	SHOW _CMD_TABLE
	EXTERNAL 	DEVICE_CMD_TABLE
	INTEGER*4	DEVICE_CMD_TABLE
	EXTERNAL	UNIT_CMD_TABLE
	INTEGER*4	UNIT_CMD_TABLE
	EXTERNAL	LAB_CMD_TABLE
	INTEGER*4	LAB_CMD_TABLE
	EXTERNAL	CLR_CMD_TABLE
	INTEGER*4	CLR_CMD_TABLE
	EXTERNAL	LEG_CMD_TABLE
	INTEGER*4	LEG_CMD_TABLE
	EXTERNAL	SETUP_CMD_TABLE
	INTEGER*4	SETUP_CMD_TABLE
	EXTERNAL	DRAW_CMD_TABLE
	INTEGER*4	DRAW_CMD_TABLE
C
C	new MENU data statement
	DATA BOXMAP/ 0,  0,  0,  0,  0,  0,  0,
     &	 	     0,  0,  1,  2,  3,  4,  5,
     &		     0,  0,  0,  0,  0,  0,  0,
     &		     0,  0,  6,  7,  8,  9, 10,
     &		     0,  0,  0,  0,  0,  0,  0,
     &		    11, 12, 13, 14, 15, 16, 17,
     &		     0,  0,  0,  0,  0,  0, 18,
     &		    19, 20, 21, 22, 23, 24, 25, 
     &		    0,  0,  0,  0,  0,  0,   0,
     &		    26, 27, 28, 29, 30, 31, 32,
     &		     0,  0, 33, 34,  0,  0,  0,
     &		    35, 36, 37, 38, 39, 40, 41,
     &		     0,  0,  0,  0, 42, 43,  0,
     &		    44, 45, 46, 47,  0,  0,  0,
     &		     0,  0, 48, 49, 50, 51, 52,
     &		    53, 54, 55, 56, 57, 58, 59/ 
C***********************************************************************
C
C	Initialise libraries
	CALL LSL_INIT(.TRUE.)		! initialise LSLLIB
	CALL DTI_INIT			! initialise DTILIB
	CALL SET_TXTLIM(1024)		! set max line length
	CALL LSL_SET_OUTPUT(PUT_OUTPUT)
C
	PROMPT = 'SLOPES'
	UNITS(1)='MATRIX'
	UNITS(2)='METRES'
	UNITS(3)='LATLONG'
	UNITS(4)='SECONDS'
	UNITS(5)='PROJECTION'
C
	NOMESS=.TRUE.
C
C	Set default values
	ZOOMF=0				!no enlargement
	HADDTI=.FALSE.			!no DTI file mapped yet
	HADOUT=.FALSE.		        !no output file yet
	MENU_SET=.FALSE.		!MENU not yet set
 	NX_MNU = 7			!menu has 7 columns
	NY_MNU = 16			!menu has 16 rows
        MAP_SET =.FALSE.		!MAP not yet located
	PLOT_DTI=.FALSE.	        !Output file not selected
	GRAPHICS=.FALSE.		!Graphics not enabled
	INIT_GRAPHICS=.FALSE.		!Graphics dev not initialised
	PLOT_LEG= .TRUE.		!Display legend
	CLEAR=.TRUE.			!Clear screen before display
	HAD_ASPECT=.FALSE. 		!Aspect map not chosen
	GREY_ASPECT=.FALSE.		!Use colour scale to draw aspect
C					!map
	RECENT=.TRUE.			!Recentre display before
C					!next image
	TEXTON=.TRUE.			!display text
	CLASSIFY = .FALSE.		!don't classify on output to DTI
	NULL_EDGE =.FALSE.		!default is not to gen. 
C					!null border
	HAD_PERCENT = .FALSE.		!output as degrees
	HAD_ABSOLUTE= .TRUE.		!absolute coords by default
C
C	Default hill shading, aspect and slope parameters
	SUNANG=45.0			!sun angle
	SUNPOS=135.0			!sun position 
	REFMAP=2			!reflectance map
	GUPPER=60.0			!show only gradients between
	GLOWER=0.0			!0 and 60 degrees
	GRAD_TYPE=1			!gradient algorithm 1
	ASP_TYPE=1			!aspect algorithm 1
	DIFF_MIN=0			!height min and
	DIFF_MAX=60			!max difference limits
	AVERAGE_HDIFF=.TRUE.		!default is to calculate
C					!average height difference
	NSTEP=12			!number of steps
	ASPSTE=30			!aspect angle step 30 degrees
	ASTEP=12		        !number of aspect steps
	GREYSTEP=11			!used by aspect
	UNTYPE=1
	OUTPUT_DATA_TYPE = DATA_WORD	!word output file
	ZSCALE = 1			!no vertical exag
C
	DO 5 I=1,90
	  GSTEP(I) = 5*I		!5 degree steps
	  STEPS(I) = 5
5	CONTINUE	
C
	DO 6 I= 1,25			!Default colour selection
	   COLTAB(I)=I			!as in colour table
6	CONTINUE
C
C label and legend
	HADLAB=.FALSE.			!no positioning commands
	HADLEG=.FALSE.			!yet given so use defaults
	LABSIZ=2			!label size
	LABX =150			!x label position (pixel units)
	LABY =75			!y label position (pixel units)
	LEGX =50			!legend x position (pixel units)
	LEGY =150			!legend y position (pixel units)
C
C set up default colour tables
	SLOPE_LUT_NAME	= 'LSL$LOOKUP:SLOPES.DAT'
	SLOPE_LUT_LEN = 21
	ASPECT_LUT_NAME = 'LSL$LOOKUP:SLOPES.DAT'
	ASPECT_LUT_LEN = 21
	HEIGHT_LUT_NAME = 'LSL$LOOKUP:SLOPES.DAT'
	HEIGHT_LUT_LEN = 21
	SHADE_LUT_NAME = 'LSL$LOOKUP:GREY.DAT'
	SHADE_LUT_LEN = 19
C
C***********************************************************************
C
C See if input is from command file
	CMDFIL = .TRUE.			! assume so
	ERR = TEST_TERM('SYS$INPUT',OTERM,IERR)
	IF (.NOT.ERR) THEN
	   IF (ERR.EQ.LSL__SYSERR) THEN
	      CALL LSL_PUTMSG(IERR)
	   ELSE
	      CALL LSL_PUTMSG(ERR)
	   ENDIF
	ELSE
	   CMDFIL = .NOT.OTERM		! input from command file
	ENDIF
C
C assign input channel, and set up control/C handler
	CTRLC = .FALSE.
	IF (.NOT.CMDFIL) THEN
	  IERR = SYS$ASSIGN('SYS$INPUT',IN_CHAN,,)
	  IF (.NOT.IERR) THEN
	    CALL LSL_PUTMSG(IERR)
	    GOTO 9999		! exit
	  ENDIF
	  CALL SET_OUTBAND_AST(CTRLCAST,8)
	ENDIF
	HADQIO = .FALSE.	! no QIO active
C
C See if output is to a terminal
	IERR=LIB$GETDVI(DVI$_DEVCLASS,,'SYS$OUTPUT',VAL,,)
	IF (IERR) THEN			! success
	   IF (VAL.EQ.DC$_TERM)OTERM=.TRUE. ! it is a terminal
	ELSE
	   CALL LIB$SIGNAL(%VAL(IERR))
	ENDIF
C
	IF(OTERM)THEN
	  IERR=LIB$GETDVI(DVI$_TT_SCOPE,,'SYS$OUTPUT',VAL,,)
	  IF (IERR) THEN
	     CRT=VAL.EQ.1
	  ELSE
	   CALL LIB$SIGNAL(%VAL(IERR))
	  ENDIF	
C
C assign output channel
	  IERR = SYS$ASSIGN('SYS$OUTPUT',OUT_CHAN,,)
	  IF (.NOT.IERR) THEN
	    CALL LSL_PUTMSG(IERR)
	    GOTO 9999		! exit
	  ENDIF
	ELSE
	  CRT=.FALSE.
	ENDIF
C
C announce the program
	CALL DTMJPI
C
C initialise digitising table
C
	TABLE=.TRUE.			! initial assumption
	RET = TRNALL('LSL$AUTO_ENABLE_TABLE',TRANSLATION)
	IF(.NOT.RET.OR.TRANSLATION.NE.'1')THEN
	   TABLE = .FALSE.
	ELSE
	   TABLE = .TRUE.
	   IF(TABLE) THEN
	      IF (INIT_TAB(,IERR)) THEN
	         CALL WRITEF
     &	         ('%S Failed To initialise table monitor',WBELL)
	         CALL WRITEF
     &           ('Program will assume no table is available')
	         CALL WRITEF(' ')		! needed inexplicably
	         TABLE = .FALSE.
	      END IF	
	   ENDIF
	ENDIF
C
C----------------------------------------------------------------------
C set event flag numbers
	IF (TABLE) THEN
	   CALL RETURN_EFN(EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
	ENDIF
C
C set up text pointers for WAIT_INPUT
	TXTPTR = 80
C
C
C***********************************************************************
C
C get next command from keyboard or table puck
10	CTRLC = .FALSE.			! clear any CTRL/C
	IF (.NOT.WAIT_INPUT(PROMPT,.TRUE.,.TRUE.)) GOTO 9999
C
	IF (HAD_VDU) THEN	! keyboard input
	  IF (RDCHS(CH)) GOTO 10	! substantially empty line
	  IF (CH.EQ.'!') GOTO 10	! comment!
	  IF (CH.EQ.'@') GOTO 6200	! read from command file
C
	  MCMD=.FALSE.	!therfore not from the table menu
	  CALL BSLN				!set to beg of line
	  NOMESS=.FALSE.
C
	  COMAND = RDCOMM(SLOPE_CMD_TABLE) ! read keyboard command line
	  IF(COMAND.LE.0)THEN
	    CALL WRITEF('%S Specifying SLOPES command',EBELL)
            GOTO 10		! unrecognised command
	  ENDIF
C
	  NOMESS=.TRUE.		! turn off RDCOMM messages from now on
C
C execute command from keyboard
C
	  GOTO ( 100, 150, 550, 250, 	! FILEIN  WINDOW  ZLIMIT STEP 
     &          1045, 390, 400, 450,	! LEGEND  ZSCALE  SLOPES ENLARGE
     &           470,5700, 600,9999,	! REDUCE  CLEAR   SHOW   EXIT
     &           650, 850, 700, 750,	! HELP    CENTRE  SUN_AN SHADED
     &           775, 730, 740, 660,	! ASPECT  SUN_POS REFLEC DEFAULT
     &          6100,3000,3600,3605,    ! LABEL   LUT     UNITS  COLOUR
     &          3700,3800,4500,4900,	! ANGLE   WAIT    HEIGHT SPAWN
     &          5600,5650,5400,5500,	! ENABLE  DISABLE SETUP  DRAW
     &          3530, 200,6300		! FILEOUT VALUE_R DATA_T
     &          ),COMAND
C
	ELSEIF (HAD_PUCK(IERR)) THEN
	  ERR= READ_PUCK(BUTTON,X_TAB,Y_TAB,IERR)
	  IF(ERR)THEN
            CALL SHOW_ERROR(IERR)
	    GOTO 10
	  ENDIF
C
	  IF(IN_MENU(X_TAB,Y_TAB,COMAND))THEN
	    MCMD=.TRUE.
C
C			   FILEI  FILEO  WINDO  SETUP  EXIT
	    GOTO (            90,  3530,   150,  800, 9999,
C			           UNITS
C			   MATRI  METRE  LATLO  SECON PROJE
     &	                    3670,  3670,  3670, 3670, 3670,
C			         SHOW
C		FILES SLOPE SHADE  ASPEC  LABEL HEIGH ENABL
     &		 600,  600,  600,   600,   600,  600,  600,
C		  	        IMAGE                 SHADE
     &                                                 750,
C		SL1   SL2    SL3    SL4    SL5  HEIGT ASPEC  
     &		 400,  400,  400,   400,   400, 4500,  775, 
C				DISPLAY     ASPECT
C		ENLAR REDUC CENTR  LUT    CLEAR ANGLE DEFAU
     &		 450,  470,  830,  3000,  5700, 3700,  660,
C		SLOPE       DEFAU  ZSCALE    ANNOTATION
     &                       660,   390,
C		ZLIMI VALUE  STEP  COLOU  DRLA  LABPO LABSI
     &		 550,  200,  250,  3605,  2000,   340, 310,
C				          CLEL   LEGP
     &                                     380,  1050,
C		     SHADE
C		REFLE SUN_P SUN_A DEFAU  
     &		 740,  730,  700,   660, 
C		 ENABLE     GRAPH ABSOL   CLEAR LEGEN RECEN
     &  	            5000,  5800,  5900,  300, 3900, 
C		GREY  CLASS NULL_ PERCE    TEXT AVERA TABLE
     &		4700, 4800, 5200,  5300,  4000, 4200, 6000 )
     &         ,COMAND
C
	  ELSE
	    COMAND=BUTTON+1		!puck button input
	    GOTO(10,830,450,470)COMAND	    
C		 No action,CENTRE,ENLARGE,REDUCE
	  ENDIF
C
	ENDIF
	GOTO 10				! get next command
C
C**********************************************************************
C
C	FILEIN  get file and map into memory
90	IF(MCMD)THEN
          CALL WRITEF('%S> FILEIN',PROMPT)
	  CALL BSLN
	  IF(.NOT.WAIT_INPUT('Input DTI filename',.FALSE.,.TRUE.))
     &    GOTO 10
	ENDIF
C
100	CALL OPNFIL
	GOTO 10
C
C**********************************************************************
C
C	WINDOW define area of interest
150	IF(MCMD)CALL WRITEF('%S> WINDOW',PROMPT)
	CALL WINDOW_CMD(MCMD.OR.MAP_SET)
	GOTO 10
C
C**********************************************************************
C
C	UNITS
C
3600	CMD=RDCOMM(UNIT_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  CALL WRITEF('%S specifying command UNITS',EBELL)
	  CALL WRITEF('Command should be followed by MATRIX, METRES, '
     &	  //'LATLONG, SECONDS or PROJECTION')
	  GOTO 10
	END IF
C
3670	IF (MCMD) THEN
	  CMD=COMAND-5
          CALL WRITEF('%S> UNITS %S',PROMPT,UNITS(CMD))
	ENDIF
C
	RET = DTI_UNITS(DTICHAN,CMD)
	IF (.NOT. RET) THEN
	   IF (RET .EQ. DTI__INVUNITS) THEN
	      CALL WRITEF('%S Specifying command UNITS',EBELL)
	      CALL WRITEF
     &        ('Command qualifier is invalid for the input file')
	   ELSE
	       CALL LSL_PUTMSG(RET)
	   ENDIF
	   GOTO 10
	ENDIF
C
	UNTYPE=CMD
	GOTO 10
C
C***********************************************************************
C
C	VALUE_RANGE set gradient range limits
C
200	IF(MCMD)THEN				!prompt
	  CALL WRITEF('%S> VALUE_RANGE',PROMPT)
210	  IF(.NOT.WAIT_INPUT('Lower value',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 210
C	
230	  IF(.NOT.WAIT_INPUT('Upper value',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(2)))GOTO 230
	ELSE
	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF
     &	    ('%S Specifying command VALUE_RANGE',EBELL)
	    CALL WRITEF('Command requires 2 integer values')
	    GOTO 10
	  ENDIF
	ENDIF
C
C	Test input range values....
245	IF(INTARG(1).GT.INTARG(2))THEN		!allow 0 range!!!
	   CALL WRITEF
     &	   ('%S Specifying command VALUE_RANGE',EBELL)
	   CALL WRITEF('Lower value exceeds upper value')
	  GOTO 10
	ENDIF
C
C	Range O.K.
	GLOWER=INTARG(1)
	GUPPER=INTARG(2)
C
C	Adjust number of steps and step interval values accordingly
C	This is a bit of a fudge!
	CMDICT=0
	NSTEP=0
	TOTAL=GLOWER
	I=1
	GOTO 285
C
C**********************************************************************
C
C	STEP set value step interval  (for gradient and height range)
C
250	IF(MCMD)THEN
	  CALL WRITEF('%S> STEP',PROMPT)
260	  IF(.NOT.WAIT_INPUT('Step intervals',.FALSE.,.TRUE.))GOTO 10
C
	  DO 270 I=1,7			!up to 7 steps may be specified
C					!CMDLIB doesn't allow any more
	  IF(RDLONG(INTARG(I)))GOTO 272
270	  CONTINUE
272	  CMDICT=I-1
	ENDIF
C
	IF(CMDICT.LT.1)THEN
	  CALL WRITEF('%S Specifying command STEP',EBELL)
	  CALL WRITEF('Command requires between 1 and 7 integer values')
	  GOTO 10
	ENDIF
C
C	Test step values
	DO 275 I=1,CMDICT
	  IF(INTARG(I).LT.1.OR.INTARG(I).GT.GUPPER)THEN
	    CALL WRITEF
     &	    ('%S Specifying command STEP',EBELL)
	    CALL WRITEF
     &      ('Command requires integer values in the range 1 to %N'
     &			,GUPPER)
	    GOTO 10
	  ENDIF
275	CONTINUE
C
C	OK so transfer to STEPS array
	DO 276 I=1,CMDICT
	   STEPS(I)=INTARG(I)
276	CONTINUE
C
C	Fill out remainder with last step value
	DO 277 I=CMDICT+1,90
	   STEPS(I)=INTARG(CMDICT)
277	CONTINUE
	NSTEP=CMDICT
C
C	Variable step mechanisim.
278	TOTAL=GLOWER
	DO 280 I=1,NSTEP
	  TOTAL=TOTAL+STEPS(I)
	  IF(TOTAL.EQ.GUPPER)THEN
	    GSTEP(I)=GUPPER
	    NSTEP=I
	    GOTO 10
	  ENDIF
	  IF(TOTAL.GT.GUPPER)THEN
	    NSTEP=I
	    CALL WRITEF('%S Value range exceeded',WBELL)
	    CALL WRITEF('Step %N is truncated to %N',I,
     &	GUPPER-GSTEP(I-1))
	    GSTEP(I)=GUPPER
	    IF(I.NE.CMDICT)THEN
	      CALL WRITEF('and remaining steps are ignored.')
	    ENDIF
	    GOTO 10
	  ENDIF
	  GSTEP(I)=TOTAL
280	CONTINUE	
C
285	IF(TOTAL.LT.GUPPER)THEN	
	  GSTEP(I)=MIN(GUPPER,(TOTAL+STEPS(I)))
	  TOTAL=GSTEP(I)
	  NSTEP=NSTEP+1
	  I=I+1
	  GOTO 285
	ENDIF
C
	GOTO 10
C
C*********************************************************************
C
C ENABLE/DISABLE LEGEND
C
C	Has the graphics device  been initialised, if not do so....
300     IF (MCMD) THEN
	   DISABLE = PLOT_LEG
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE LEGEND',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE LEGEND',PROMPT)
	   ENDIF
	ENDIF  
	IF (DISABLE) THEN
	   PLOT_LEG= .FALSE.
	ELSE
	   PLOT_LEG= .TRUE.
	ENDIF
       	GOTO 10
C
C**********************************************************************
C LABEL SIZE
C	LABSIZ		Set label size (1 to 4)
310	IF(MCMD)THEN
	  CALL WRITEF('%S> LABEL SIZE',PROMPT)
315	  IF(.NOT.WAIT_INPUT('Label size',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 315
	ELSE
	  IF(CMDICT.NE.1)THEN
	    CALL WRITEF
     &	    ('%S Specifying command LABEL SIZE',EBELL)
	    CALL WRITEF
     &      ('Command requires an integer in the range 1 to 4')
	    GOTO 10
	  ENDIF
	ENDIF
C
330	IF(INTARG(1).LT.1.OR.INTARG(1).GT.4)THEN
	  CALL WRITEF('%S Specifying command LABEL SIZE',EBELL)
	  CALL WRITEF('Command requires an integer in the range 1 to 4')
	ELSE
	  LABSIZ=INTARG(1)
	ENDIF
C
	GOTO 10
C
C***********************************************************************
C LABEL POSITION
340	IF(MCMD)THEN
	  CALL WRITEF('%S> LABEL POSITION',PROMPT)
345	  IF(.NOT.WAIT_INPUT('Text x position',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 345
C
360	  IF(.NOT.WAIT_INPUT('Text y position',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(2)))GOTO 360
C
	ELSE
	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF
     &	    ('%S Specifying command LABEL POSITION',EBELL)
	    CALL WRITEF
     &      ('Command requires a x and y screen coordinate value')
	    GOTO 10
	  ENDIF
	ENDIF
C
        LABX=INTARG(1)
        LABY=INTARG(2)
	HADLAB=.TRUE.
C
	GOTO 10
C
C**********************************************************************
C CLEAR LABEL
380	IF(MCMD)CALL WRITEF('%S> CLEAR LABEL',PROMPT)
	IF (GRAPHICS) THEN
	   CALL LSG_PLANE_SELECT(WKID,.NOT.(PLANE_MASK))
	   CALL LSG_PLANE_OFFSET(WKID,NOPLNS)
	   CALL GSFACI(0)		! fill area colour 0 (background)
	   CALL GSFAIS(GSOLID)		! solid fill
	   X(1) = 0.0
	   X(2) = RASTSZ(1)-1
	   Y(1) = 0.0
	   Y(2) = RASTSZ(2)-1
	   CALL LSG_FILL_RECTANGLE(X,Y)
	   CALL GUWK(WKID,GSUPP)
	ENDIF
	GOTO 10
C
C**********************************************************************
C ZSCALE 
390	IF (MCMD) THEN
	  CALL WRITEF('%S> ZSCALE',PROMPT)
395	  IF(.NOT.WAIT_INPUT('Z Scale',.FALSE.,.TRUE.))GOTO 10
	  IF(RDREAL(REALAR(1)))GOTO 395
	ELSE
	   IF (CMDRCT .LT. 1) THEN
	      CALL WRITEF('%S Specifying command ZSCALE',EBELL)
	      CALL WRITEF('Command requires a real argument')
	   ENDIF
	ENDIF
C
	IF(REALAR(1).LT.0.0)THEN
	   CALL WRITEF('%S Specifying command ZSCALE',EBELL)
	  CALL WRITEF('Value should exceed 0')
	  GOTO 10
	ENDIF
C
	ZSCALE=REALAR(1)
	GOTO 10
C
C***********************************************************************
C SLOPE  calculate gradient and display or output to DTI file
C
400	IF ((.NOT. GRAPHICS) .AND. (.NOT. PLOT_DTI)) THEN
	   CALL WRITEF('%S specifying command SLOPE',EBELL)
	   CALL WRITEF ('Output medium not specified')
	   CALL WRITEF('Use ENABLE GRAPHICS or FILEOUT commands')
	   GOTO 10
      	ENDIF	
C
	IF (.NOT.HADDTI)THEN
	   CALL WRITEF('%S specifying command SLOPE',EBELL)
	   CALL WRITEF('No input DTI file had been specified')
	   GOTO 10
	ENDIF
C
        IF (GRAPHICS) THEN
	   HAD_ASPECT= .FALSE.
           CALL LSG_SET_LUT(WKID,SLOPE_LUT_NAME(1:SLOPE_LUT_LEN))
	ENDIF	
	WHITE=64
	DO_GRADIENT=.TRUE.
C
C Which algorithm?
	IF (MCMD) THEN
	   GRAD_TYPE = COMAND-18
           CALL WRITEF('%S> SLOPE %N',PROMPT,GRAD_TYPE)
	ELSE 
	   IF(CMDICT.EQ.1)THEN
	      IF(INTARG(1).LT.1.OR.INTARG(1).GT.5)THEN
	         CALL WRITEF('%S specifying command SLOPE',WBELL)
	         CALL WRITEF
     &           ('Gradient algorithm should be in the range 1 to 5')
	         CALL WRITEF
     &           ('Current gradient algorithm (%N) will be used',
     &           GRAD_TYPE)
	      ELSE
	         GRAD_TYPE=INTARG(1)
	      ENDIF
	   ELSE
	      CALL WRITEF
     &        ('Current gradient algorithm (%N) will be used',
     &        GRAD_TYPE)
	   ENDIF
	ENDIF
C
	IF(GRAD_TYPE.EQ.1)THEN
	   OK = GRADIENT1()
C
	ELSEIF(GRAD_TYPE.EQ.2)THEN
	   OK = GRADIENT2()
C
	ELSEIF(GRAD_TYPE.EQ.3)THEN
	   OK = GRADIENT3()
C
	ELSEIF(GRAD_TYPE.EQ.4)THEN
	   OK = GRADIENT4(.FALSE.)	!mean slope
C
	ELSEIF(GRAD_TYPE.EQ.5)THEN
	   OK = GRADIENT4(.TRUE.)	!maximum slope
	ENDIF
C
	IF (.NOT.OK) GOTO 9999
C
	IF (GRAPHICS) CALL GUWK(WKID,GSUPP)
	GRAD_TYPE=1
	DO_GRADIENT=.FALSE.
C
	GOTO 10
C
C***********************************************************************
C
C	ENLARGE 
450     IF(MCMD) CALL WRITEF('%S> ENLARGE',PROMPT)
	IF(.NOT.GRAPHICS)THEN
	  CALL WRITEF('%S specifying command ENLARGE ',EBELL)
	  CALL WRITEF('A graphics device is not selected')
	  GOTO 10
	ENDIF
C
 	ZOOMF=ZOOMF+2
	IF(ZOOMF.GT.16)THEN
	  CALL WRITEF('%S specifying command ENLARGE ',EBELL)
	  CALL WRITEF('Display is at maximum magnification')
	  ZOOMF=16
	ELSE
C zoom around current cursor position
          IF (GRAPHICS) THEN
	     CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	  ENDIF
	ENDIF
C
	GOTO 10
C
C*****************************************************************
C
C	REDUCE
470     IF(MCMD) CALL WRITEF('%S> REDUCE',PROMPT)
	IF(.NOT.GRAPHICS)THEN
	  CALL WRITEF('%S specifying command REDUCE',EBELL)
	  CALL WRITEF('A graphics device is not selected')
	  GOTO 10
	ENDIF
C
 	ZOOMF=ZOOMF-2			!decrement zoom factor
	IF(ZOOMF.LT.0)THEN		!already at minimum zoom
	  CALL WRITEF('%S specifying command REDUCE',EBELL)
	  CALL WRITEF('Display is at minimum magnification')
	  ZOOMF=0
	  GOTO 10
	ELSE
	  IF (GRAPHICS) THEN
	     CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	  ENDIF
	ENDIF
	GOTO 10
C
C**********************************************************************
C
C ZLIMITS specify range of heights we are interested in
C
550	IF(MCMD)THEN
	  CALL WRITEF('%S> ZLIMITS',PROMPT)
555	  IF(.NOT.WAIT_INPUT('Lower height',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 555
C	  
560	  IF(.NOT.WAIT_INPUT('Upper height',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(2)))GOTO 560
	ELSE
	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF('%S ERROR *** Specifying command ZRANGE',EBELL)
	    CALL WRITEF('Command requires 2 integer height values')
	    GOTO 10
	  ENDIF
	ENDIF
C
C	Test height values....
590	IF(INTARG(1).GT.INTARG(2))THEN
	  CALL WRITEF('%S Specifying command ZLIMITS',EBELL)
	  CALL WRITEF('Lower value exceeds upper value')
	  GOTO 10
	ENDIF
C
C	O.K.
	HLOWER=INTARG(1)
	HUPPER=INTARG(2)
	GOTO 10
C
C**********************************************************************
C
C SHOW show info. 
C
600	CALL SHOW_CMD(MCMD,COMAND-10)
C
	GOTO 10
C***********************************************************************
C	HELP
650	CALL HELP			!on-line system help
	GOTO 10
C
C**********************************************************************
C	DEFAULT
660	IF(MCMD) THEN
	   IF (COMAND .EQ.33) THEN
	      WHAT = 1
	   ELSEIF (COMAND .EQ. 47) THEN
	      WHAT = 2
	   ELSEIF(COMAND .EQ. 32) THEN
	      WHAT = 3
	   ENDIF
	ENDIF
	CALL DEFAULT_CMD(MCMD,WHAT)
	GOTO 10
C
C**********************************************************************
C
C SUN_ANGLE
700	IF(MCMD)THEN
	  CALL WRITEF('%S> SUN_ANGLE',PROMPT)
705	  IF(.NOT.WAIT_INPUT('Sun angle',.FALSE.,.TRUE.))GOTO 10
	  IF(RDREAL(REALAR(1)))GOTO 705
	  GOTO 707
	ENDIF
C
	IF(CMDACT.NE.1)THEN
	  CALL WRITEF('%S Specifying command SUN_ANGLE',EBELL)
	  CALL WRITEF('Command requires a real value between 0 and 90')
	  GOTO 10
	ENDIF
C
707	IF(REALAR(1).LT.0.OR.REALAR(1).GT.90)THEN
	  CALL WRITEF('%S Specifying command SUN_ANGLE',EBELL)
	  CALL WRITEF('Command requires a real value between 0 and 90')
	  GOTO 10
	ENDIF
C
	IF(SUNANG.EQ.0.0) SUNANG=0.1
	IF(SUNANG.EQ.90.0)SUNPOS=89.9
C
	SUNANG=REALAR(1)
	IF(SUNANG.GT.45.0)THEN
	  SUNANG=45.0-(SUNANG-45.0)
	ELSE
	  SUNANG=45.0+(45.0-SUNANG)
	ENDIF
	GOTO 10
C
C***********************************************************************
C
C	Sun Position
730	IF(MCMD)THEN
	  CALL WRITEF('%S> SUN_POSITION',PROMPT)
735	  IF(.NOT.WAIT_INPUT('Sun position',.FALSE.,.TRUE.))GOTO 10
	  IF(RDREAL(REALAR(1)))GOTO 735
	  GOTO 737
	ENDIF
C
	IF(CMDACT.NE.1)THEN
	  CALL WRITEF('%S Specifying command SUN_POSITION ',EBELL)
	  CALL WRITEF
     &    ('Command requires a real value between 0 and 360')
	  GOTO 10
	ENDIF
C
737	IF(REALAR(1).GT.360.OR.REALAR(1).LT.0)THEN
	  CALL WRITEF('%S Specifying command SUN_POSITION ',EBELL)
	  CALL WRITEF
     &    ('Command requires a real value between 0 and 360')
	  GOTO 10
	ENDIF
C
	SUNPOS=REALAR(1)
	IF(SUNPOS.EQ.360)SUNPOS=0.0
C
	IF(SUNPOS.GE.180)THEN
	  SUNPOS=SUNPOS-180.0
	ELSE
	  SUNPOS=SUNPOS+180.0
	ENDIF
C
	GOTO 10
C
C**********************************************************************
C REFLECTANCE_MAP
C
740	IF(MCMD)THEN
	  CALL WRITEF('%S> REFLECTANCE_MAP',PROMPT)
745	  IF(.NOT.WAIT_INPUT('Reflectance map',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 745
	  GOTO 747
	ENDIF
C
C Test reflectance map value....
	IF(CMDICT.NE.1)THEN
	  CALL WRITEF('%S Specifying command REFLECTION_MAP',EBELL)
	  CALL WRITEF('Command requires an integer between 1 and 3')
	  GOTO 10
	ENDIF
C
747	IF(INTARG(1).GT.3.OR.INTARG(1).LT.1)THEN
	  CALL WRITEF('%S Specifying command REFLECTION_MAP',EBELL)
	  CALL WRITEF('Command requires an integer between 1 and 3')
	  GOTO 10
	ENDIF
C
	REFMAP=INTARG(1)
	GOTO 10
C
C***********************************************************************
C SHADE
C Generate shaded map
C
750     IF(MCMD) CALL WRITEF('%S> SHADE',PROMPT)
        IF ((.NOT. GRAPHICS) .AND. (.NOT. PLOT_DTI)) THEN
	   CALL WRITEF('%S specifying command SHADED',EBELL)
	   CALL WRITEF ('Output medium not specified')
	   CALL WRITEF('Use ENABLE GRAPHICS or FILEOUT commands')
	   GOTO 10
      	ENDIF	
C
	IF (.NOT.HADDTI)THEN
	   CALL WRITEF('%S specifying command SHADED',EBELL)
	   CALL WRITEF('No input DTI file had been specified')
	   GOTO 10
	ENDIF
C
	HAD_ASPECT= .FALSE.
	IF(GRAPHICS) THEN
C default lut
          CALL LSG_SET_LUT(WKID,SHADE_LUT_NAME(1:SHADE_LUT_LEN)) 
	ENDIF
C
	WHITE=128
	OK = SHADES()
	IF (.NOT.OK) GOTO 9999
C
	IF (GRAPHICS) CALL GUWK(WKID,GSUPP)
C
	GOTO 10
C
C***********************************************************************
C
C	ASPECT
C	Generate aspect map
775     IF(MCMD) CALL WRITEF('%S> ASPECT',PROMPT)
	IF((.NOT. GRAPHICS) .AND. (.NOT. PLOT_DTI)) THEN
	   CALL WRITEF('%S specifying command ASPECT',EBELL)
	   CALL WRITEF ('Output medium not specified')
	   CALL WRITEF('Use ENABLE GRAPHICS or FILEOUT commands')
	   GOTO 10
      	ENDIF	
C
	IF (.NOT.HADDTI)THEN
	   CALL WRITEF('%S specifying command ASPECT',EBELL)
	   CALL WRITEF('No input DTI file had been specified')
	   GOTO 10
	ENDIF
C
	IF(PLOT_DTI) THEN
	   IF (.NOT.CLASSIFY) THEN
	      IF(OUTPUT_DATA_TYPE .EQ. DATA_BYTE) THEN
	         CALL WRITEF('%S specifying command ASPECT',EBELL)
	         CALL WRITEF('DATA_TYPE BYTE illegal for ASPECT output')
	      ENDIF
	   ENDIF
	ENDIF
C
	HAD_ASPECT = .TRUE.	
	IF (GRAPHICS)THEN
	   IF(GREY_ASPECT)THEN
             CALL LSG_SET_LUT(WKID,SHADE_LUT_NAME(1:SHADE_LUT_LEN)) 
	   ELSE
             CALL LSG_SET_LUT(WKID,ASPECT_LUT_NAME(1:ASPECT_LUT_LEN)) 
	   ENDIF
	WHITE=128
	ENDIF
C
	OK = ASPECT1()
	IF (.NOT.OK) GOTO 9999
C
	IF (GRAPHICS) CALL GUWK(WKID,GSUPP)
	GOTO 10
C
C***********************************************************************
C SETUP MAP
C
800     IF(MCMD)CALL WRITEF('%S> SETUP MAP',PROMPT)
	IF(.NOT.TABLE)THEN		!not valid without table
          CALL WRITEF('%S specifying command SETUP MAP',EBELL)
	  CALL WRITEF
     &	  ('Command not valid without Table')
	  GOTO 10
	ENDIF
C
	IF(.NOT.HADDTI)THEN		!not valid if DTM not selected
          CALL WRITEF('%S specifying command SETUP MAP',EBELL)
	  CALL WRITEF
     &    ('Input DTI file not yet selected')
	ELSE
	  CALL SET_MAP			!prompt for registration points
	ENDIF
	GOTO 10
C
C***********************************************************************
C SETUP MENU
C	MENU position menu
820     IF(.NOT.TABLE)THEN		!not valid without table
          CALL WRITEF('%S specifying command SETUP MENU',EBELL)
	  CALL WRITEF
     &	  ('Command not valid without Table')
	  GOTO 10
	ENDIF
C
	CALL SET_MENU			!prompt for menu registration
	GOTO 10
C
C***********************************************************************
C
C	CENTRE display around specified x,y position
C	From puck button:
830     IF(MCMD) CALL WRITEF('%S> CENTRE',PROMPT)
	IF (.NOT.MAP_SET) THEN		!can't translate table coord
C					!to DTM coordinate, so treat
C					!as menu command
	   GOTO 850			
	ELSE
	   R1 = FLOAT(X_TAB)
           R2 = FLOAT(Y_TAB)
           CALL TRANSF(TAB_DTI,R1,R2,R3,R4)	!transform
           X1 = NINT(R3)
           Y1 = NINT(R4)
	   GOTO 860
	ENDIF
C
850     IF(.NOT.GRAPHICS)THEN
	  CALL WRITEF('%S Specifying command CENTRE',EBELL)
	  CALL WRITEF('A graphics device is not selected')
	  GOTO 10
	ENDIF
C
	IF(MCMD)THEN			!prompt
	  IF(GET_DTI_COORDS(R1,R2,'x y point'))THEN
	    X1=NINT(R1)
	    Y1=NINT(R2)
	    GOTO 860
	  ELSE
	    GOTO 10
	  ENDIF
	ELSE
	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF('%S Specifying command CENTRE',EBELL)
	    CALL WRITEF('Command requires 1 DTI x,y coord pair')
	    GOTO 10
	  ELSE
	    X1=INTARG(1)
	    Y1=INTARG(2)
	  ENDIF
	ENDIF
C
C	Ensure point is inside current DTI window
860	IF(HADDTI)THEN
	  X1=MAX(DTI_WINDOW_SWX(DTICHAN),X1)
	  Y1=MAX(DTI_WINDOW_SWY(DTICHAN),Y1)
	  X1=MIN(DTI_WINDOW_NEX(DTICHAN),X1)
	  Y1=MIN(DTI_WINDOW_NEY(DTICHAN),Y1)
C
C	Convert from DTI to screen coordinates and centre around point
C	Zoom around the invisible cursor
C
	  ZOOMX=SIGSWX+((X1-DTI_WINDOW_SWX(DTICHAN))*SF)
	  ZOOMY=SIGSWY+((Y1-DTI_WINDOW_SWY(DTICHAN))*SF)
	ELSE
	  ZOOMX=X1		!treat as pixel
	  ZOOMY=Y1		!rather than DTI values
	ENDIF
C
	CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	GOTO 10
C
C-----------------------------------------------------------------------
C  LEGEND command
1045	CMD = RDCOMM(LEG_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command LEGEND',EBELL)
	   CALL WRITEF('Valid qualifier is POSITION')
	   GOTO 10
	END IF
C
C LEGEND POSITION command
1050	IF(MCMD)THEN
	  CALL WRITEF('%S> LEGEND POSITION',PROMPT)
1055	  IF(.NOT.WAIT_INPUT('Legend x position',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 1055
C
1070	  IF(.NOT.WAIT_INPUT('Legend y position',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(2)))GOTO 1070
	ELSE
1090	  IF(CMDICT.NE.2)THEN
	    CALL WRITEF
     &	    ('%S Specifying command LEGEND POSITION',EBELL)
	    CALL WRITEF
     &      ('Command requires a x and y screen coordinate value')
	    GOTO 10
	  ENDIF
	ENDIF
C
	LEGX=INTARG(1)
	LEGY=INTARG(2)
	HADLEG=.TRUE.
C
	GOTO 10
C
C***********************************************************************
C DRAW LABEL
C
2000    IF(MCMD)THEN
	  CALL WRITEF('%S> DRAW LABEL',PROMPT)
2100	  IF(.NOT.WAIT_INPUT('Enter text',.FALSE.,.TRUE.))GOTO 10
	ENDIF
C
2105	IF (.NOT.GRAPHICS) THEN
	   CALL WRITEF
     &	   ('%S Specifying command LABEL ',EBELL)
	   CALL WRITEF('GRAPHICS are not enabled')
	   GOTO 10
	ENDIF
C
	IF(RDCHS(CH))THEN
	  CALL WRITEF('%S Specifying command DRAW LABEL ',EBELL)
	  CALL WRITEF('No text supplied with the command DRAW LABEL')
	  GOTO 2100
	ELSE
	  CALL BSCH
	ENDIF
C
	CALL ANOTATE	  
C	Reset to picture 1
	CALL LSG_PLANE_SELECT ( WKID, PLANE_MASK)	!picture 1
	CALL LSG_PLANE_OFFSET ( WKID, 0)		!no offset
C
	GOTO 10
C
C**********************************************************************
C	Define colour LUT
3000	IF(MCMD) CALL WRITEF('%S> LUT',PROMPT)
	CALL LUT_CMD(MCMD)
	GOTO 10
C
C***********************************************************************
C FILEOUT
C
3530	IF(MCMD)THEN
          CALL WRITEF('%S> FILEOUT',PROMPT)
	  CALL BSLN
	  IF(.NOT.WAIT_INPUT('Output DTI filename',.FALSE.,.TRUE.))
     &    GOTO 10
	ENDIF
	IF(PARSE_FILENAME())GOTO 10
C
	PLOT_DTI= .TRUE.
	GOTO 10
C
C----------------------------------------------------------------------
C**********************************************************************
C 	COLOUR allows user to specify colours
C
3605	IF (MCMD)THEN
	   CALL WRITEF('%S> COLOURS',PROMPT)
	   IF(.NOT.WAIT_INPUT('Colour indices',.FALSE.,.TRUE.))GOTO 10
	   I = 1
3620	   IF(RDLONG(INTARG(I)))GOTO 3640
	   I = I+1
	   GOTO 3620
3640	   CMDICT=I-1
	   GOTO 3645
	ENDIF
C
	IF(CMDACT.EQ.0)THEN	
	  CALL WRITEF('%S Specifying command COLOURS',EBELL)
	  CALL WRITEF
     &    ('Command requires between 1 and 7 colour index values')
	  GOTO 10
	ENDIF
C
3645	DO 3650 I=1,CMDICT
	   IF((INTARG(I) .LT. 1) .OR. (INTARG(I) .GT.127)) THEN
	     CALL WRITEF('%S Specifying command COLOURS',EBELL)
	     CALL WRITEF
     &       ('Colour values should be in the range 1 to 127')
	     GOTO 10
	   ENDIF
3650	CONTINUE
C
C OK So transfer to colour array
	DO 3660 I= 1,CMDICT
	   COLTAB(I+1)=INTARG(I)
3660	CONTINUE
C
	GOTO 10
C		   
C**********************************************************************
C ANGLE_INTERVAL for ASPECT
C
3700	IF(MCMD)THEN
	  IF(MCMD) CALL WRITEF('%S> ANGLE_INTERVAL',PROMPT)
3715	  IF(.NOT.WAIT_INPUT('Aspect step',.FALSE.,.TRUE.))GOTO 10
	  IF(RDLONG(INTARG(1)))GOTO 3715
	ELSE
	  IF(CMDICT.NE.1)THEN
	    CALL WRITEF
     &      ('%S Specifying command ANGLE_INTERVAL',EBELL)
	    CALL WRITEF
     &      ('Command requires an integer value between 3 and 360')
	    GOTO 10
	  ENDIF
	ENDIF
C
	IF(INTARG(1).LT.3.OR.INTARG(1).GT.360)THEN
	    CALL WRITEF
     &      ('%S Specifying command ANGLE_INTERVAL',EBELL)
	  CALL WRITEF
     &    ('Command requires an integer value between 3 and 360')
	  GOTO 10
	ENDIF
C
	ASPSTE=INTARG(1)
C
	ASTEP = (360/ASPSTE)
	IF(MOD(360,ASPSTE).NE.0)ASTEP=ASTEP+1
C
        GREYSTEP=INT(127/(ASTEP-1))
C
	GOTO 10
C
C**********************************************************************
C	WAIT
3800	IF (CMDRCT .NE. 1.OR. REALAR(1).LT. 1 .OR. REALAR(1) .GT. 1000)
     &   THEN
	   CALL WRITEF('%S Specifying command WAIT',EBELL)
	   CALL WRITEF('Command requires a real in the range 1 to 1000')
	ELSE
	   CALL LIB$WAIT (REALAR(1))
	ENDIF
	GOTO 10
C
C**********************************************************************
C	ENABLE/DISABLE RECENTRE
3900	IF (MCMD) THEN
	   DISABLE =  RECENT
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE RECENTRE',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE RECENTRE',PROMPT)
	   ENDIF
	ENDIF
C	 
	RECENT = .NOT. DISABLE
	GOTO 10
C
C**********************************************************************
C	ENABLE/DISABLE TEXT
4000	IF (MCMD) THEN
	   DISABLE = TEXTON
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE TEXT',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE TEXT',PROMPT)
	   ENDIF
	ENDIF
	TEXTON = .NOT. DISABLE
	GOTO 10
C
C**********************************************************************
C ENABLE/DISABLE AVERAGE
C	Average or Maximum Height Difference  (flip/flop)
4200	IF(MCMD)THEN
	   DISABLE =  AVERAGE_HDIFF
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE AVERAGE',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE AVERAGE',PROMPT)
	   ENDIF
	ENDIF  
C
	AVERAGE_HDIFF  = .NOT. DISABLE
C
	GOTO 10
C
C***********************************************************************
C
C	Height Difference Display
4500    IF(MCMD) CALL WRITEF('%S> HEIGHT_DIFFERENCE',PROMPT)
	IF ((.NOT. GRAPHICS) .AND. (.NOT. PLOT_DTI)) THEN
	   CALL WRITEF('%S specifying command HEIGHT_DIFFERENCE',EBELL)
	   CALL WRITEF ('Output medium not specified')
	   CALL WRITEF('Use ENABLE GRAPHICS or FILEOUT commands')
	   GOTO 10
      	ENDIF	
C
	IF (.NOT.HADDTI)THEN
	   CALL WRITEF('%S specifying command HEIGHT_DIFFERENCE',EBELL)
	   CALL WRITEF('No input DTI file had been specified')
	   GOTO 10
	ENDIF
C
        IF (GRAPHICS) THEN
	   HAD_ASPECT= .FALSE.
           CALL LSG_SET_LUT(WKID,HEIGHT_LUT_NAME(1:HEIGHT_LUT_LEN))
	ENDIF	
C
	WHITE=64
	HEIGHT_DIFF=.TRUE.
	OK = ROUGH()
	IF (.NOT.OK) GOTO 9999
C
	IF (GRAPHICS) CALL GUWK(WKID,GSUPP)
	HEIGHT_DIFF=.FALSE.
C
	GOTO 10
C	
C**********************************************************************
C ENABLE/DISABLE GREYSCALE
4700	IF(MCMD) THEN
           DISABLE = GREY_ASPECT
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE GREYSCALE',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE GREYSCALE',PROMPT)
	   ENDIF
	ENDIF
	GREY_ASPECT = .NOT. DISABLE
	GOTO 10
C
C
C**********************************************************************
C ENABLE/DISABLE CLASSIFY
4800	IF(MCMD) THEN
           DISABLE = CLASSIFY
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE CLASSIFY',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE CLASSIFY',PROMPT)
	   ENDIF
	ENDIF
	CLASSIFY = .NOT. DISABLE
	GOTO 10
C
C**********************************************************************
C	SPAWN
4900	I=0
4910	IF(RDCH(CH))THEN
	  GOTO 4920
	ELSE	
	  I=I+1
	  LINE(I:I)=CHAR(CH)
	  GOTO 4910
	ENDIF
C
4920	IF(I.EQ.0)THEN
	  CALL WRITEF('%S Specifying command SPAWN',EBELL)
	  CALL WRITEF('SPAWN requires a valid DCL command')
	  GOTO 10
	ENDIF
C
	IERR= LIB$SPAWN ( LINE(1:MIN(I,80)))
	CALL WRITEF(' ')
	IF(.NOT.IERR)CALL LIB$STOP(%VAL(IERR)) !error
	GOTO 10
C-----------------------------------------------------------------------
C	ENABLE /DISABLE GRAPHICS
5000	IF (MCMD) THEN
	   DISABLE =  GRAPHICS
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE GRAPHICS',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE GRAPHICS',PROMPT)
	   ENDIF
	ENDIF
C
	GRAPHICS=.NOT. DISABLE
C
	IF (GRAPHICS) THEN
	   IF (.NOT.INIT_GRAPHICS) THEN
	      IF (DISPLAY_INIT()) THEN
	         INIT_GRAPHICS=.TRUE.
C check the window size for display on screen
	         CALL CHKWIN
	      ELSE
		 GRAPHICS = .FALSE.
	      ENDIF
	   ENDIF
	ENDIF
C
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE NULL_BORDER
5200	IF(MCMD) THEN
           DISABLE = NULL_EDGE
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE NULL_BORDER',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE NULL_BORDER',PROMPT)
	   ENDIF
	ENDIF
	NULL_EDGE = .NOT. DISABLE
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE PERCENT
5300	IF (MCMD) THEN
           DISABLE = HAD_PERCENT
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE PERCENT',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE PERCENT',PROMPT)
	   ENDIF
	ENDIF
	IF(DISABLE)THEN
	  HAD_PERCENT =.FALSE.
	  GLOWER = 0.0
	  GUPPER = 60.0
	ELSE
	  HAD_PERCENT =.TRUE.
	  GLOWER = 0.0
	  GUPPER = 100.0
	ENDIF
C
C	Adjust number of steps 
	CMDICT=0
	NSTEP=0
	TOTAL=GLOWER
	I=1
	GOTO 285
C
C-----------------------------------------------------------------------
C	SETUP command
5400	CMD = RDCOMM(SETUP_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command SETUP',EBELL)
	   CALL WRITEF('Valid qualifiers are MAP or MENU')
	   GOTO 10
	END IF
C
	GOTO (800,820) CMD
C
C-----------------------------------------------------------------------
C	DRAW command
5500	CMD = RDCOMM(DRAW_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command DRAW',EBELL)
	   CALL WRITEF('DRAW qualifier is LABEL')
	   GOTO 10
	END IF
	GOTO 2000
C-----------------------------------------------------------------------
C ENABLE - enable options
C
5600	DISABLE = .FALSE.
	GOTO 5675
C
C***********************************************************************
C
C DISABLE
C Disallow options
C
5650	DISABLE = .TRUE.
5675	CMD = RDCOMM(ENABLE_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  IF (DISABLE) THEN
	     CALL WRITEF('%S Specifying command DISABLE',EBELL)
	  ELSE
	     CALL WRITEF('%S Specifying command ENABLE',EBELL)
	  ENDIF
C
	  CALL WRITEF
     &    ('Command qualifiers are ABSOLUTE, AVERAGE, CLEAR, ')
	  CALL WRITEF
     &    ('                       CLASSIFY, GRAPHICS, GREYSCALE, ')
	  CALL WRITEF
     &    ('                       LEGEND, NULL_BORDER, PERCENT, ')
	  CALL WRITEF
     &    ('                       RECENTRE, TABLE or TEXT')
	  GOTO 10
	ENDIF
C
	GOTO ( 5000,	! GRAPHICS
     &         5800,    ! ABSOLUTE
     &	       5900,	! CLEAR
     &	        300,	! LEGEND
     &         3900,	! RECENTRE
     &	       4700,	! GREYSCALE
     &	       4800,	! CLASSIFY
     &	       5200,	! NULL_BORDER
     &	       5300,	! PERCENT
     &	       4000,	! TEXT
     &	       4200,	! AVERAGE
     &	       6000	! TABLE
     &	) CMD

C-----------------------------------------------------------------------
C	CLEAR command 
5700	IF(RDCHS(CH).OR.MCMD)THEN
C
	   IF(MCMD) CALL WRITEF('%S> CLEAR',PROMPT)
C CLEAR on its own clears the screen
	   IF (GRAPHICS) THEN
	      CALL GCLRWK(WKID,GALWAY)
	   ENDIF
	   GOTO 10 
	ENDIF
C
	CALL BSCH
	CMD = RDCOMM(CLR_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command CLEAR',EBELL)
	   CALL WRITEF('Valid qualifier is LABEL')
	   GOTO 10
	END IF
C
	GOTO (380) CMD
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE ABSOLUTE
5800	IF (MCMD) THEN
	   DISABLE = HAD_ABSOLUTE
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE ABSOLUTE',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE ABSOLUTE',PROMPT)
	   ENDIF
	ENDIF
	HAD_ABSOLUTE = .NOT.DISABLE
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE CLEAR
5900	IF(MCMD) THEN
	   DISABLE = CLEAR
	   IF (DISABLE) THEN
	      CALL WRITEF('%S> DISABLE CLEAR',PROMPT)
	   ELSE
	      CALL WRITEF('%S> ENABLE CLEAR',PROMPT)
	   ENDIF
	ENDIF
	CLEAR = .NOT. DISABLE
	GOTO 10
C-----------------------------------------------------------------------
6000	IF (DISABLE) THEN
	   IF(TABLE)CALL CLOSE_TAB (IERR)
C
C cancel the qio on the terminal
	   CALL SYS$CANCEL(%VAL(IN_CHAN))
	   HADQIO = .FALSE.
C
	   TABLE = .FALSE.
	ELSE
	   IF (.NOT. TABLE) THEN
	      IF (INIT_TAB(,IERR)) THEN
	         CALL WRITEF
     &	         ('%S Error initialising table monitor',WBELL)
	         CALL WRITEF
     &           ('Program will assume no table is available')
	         TABLE=.FALSE.
	         GOTO 10
	      ENDIF
	      TABLE = .TRUE.
C
C Set event flag numbers
	      CALL RETURN_EFN
     &        (EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
C
C cancel the qio on the terminal
	      CALL SYS$CANCEL(%VAL(IN_CHAN))
	      HADQIO = .FALSE.
	   ENDIF
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C LABEL command
6100	CMD = RDCOMM(LAB_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command LABEL',EBELL)
	   CALL WRITEF('Valid qualifiers are POSITION or SIZE')
	   GOTO 10
	END IF
C
	GOTO (340,310) CMD	
C
C-----------------------------------------------------------------------
C @ command
6200	CALL AT_CMD
	GOTO 10
C-----------------------------------------------------------------------
C DATA_TYPE command
6300	CALL DATA_TYPE_CMD
	GOTO 10
C
C-----------------------------------------------------------------------
C	EXIT exit from program
C
9999	IF (MCMD) CALL WRITEF('%S> EXIT',PROMPT)
	CALL TIDY_UP
C
999	END
C
