C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1994-11-16 18:31:02.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
	PROGRAM ROVER
C
***	MODULE	ROVER
***	IDENT	16NO94
C
C Copyright Laser-Scan Ltd., Cambridge, England
C Created					MWSR    27-May-1986
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	Program for raster display and editing, with vector IFF overlay
C	and registration faciliies. 
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
CMOD	 Rotate command added			DRC 02-Sep-1986
CMOD	 Registration facilities added		ACM    Feb 1988
CMOD	 ROVER EXIT handler added to close down
C	 RCP files  				DRC    Mar 1989
C
CMOD 872 Check for infile specified before 'ENABLE SAMPLE'
C
CMOD1427 Use FRTSHR, FRT_GRAPH_INIT		 JB 16-Nov-1994
C
	IMPLICIT NONE
C
	INCLUDE	'LSL$CMNROVER:GKSPAR.PAR'
	INCLUDE	'LSL$CMNLSL:LSLLIBMSG.PAR'
	INCLUDE	'LSL$CMNDTI:DTILIBMSG.PAR'
	INCLUDE	'LSL$CMNDTI:DTIPAR.PAR'
C
	INCLUDE	'LSL$CMNROVER:RCP.CMN'
	INCLUDE	'LSL$CMNROVER:ROVCMN.CMN'
	INCLUDE	'LSL$CMNROVER:DTICMN.CMN'
	INCLUDE	'LSL$CMNROVER:TAB.CMN'		!table common
	INCLUDE	'LSL$CMNROVER:DTIQIO.CMN'
	INCLUDE	'LSL$CMNROVER:TRANS.CMN'
	INCLUDE	'LSL$CMNLSL:CMDCOM.CMN'
	INCLUDE	'LSL$CMNLSL:TXTC.CMN'
	INCLUDE	'LSL$CMNLSL:FILENAME.CMN'
	INCLUDE	'LSL$CMNROVER:COLCMN.CMN'
	INCLUDE	'LSL$CMNROVER:SELECT.CMN' 	! has IFF feat selectns
	INCLUDE	'LSL$CMNROVER:IFFCMN.CMN'
	INCLUDE	'LSL$CMNROVER:SCLDAT.CMN'
	INCLUDE	'LSL$CMNROVER:LABEL.CMN'
	INCLUDE	'LSL$CMNROVER:CONT.CMN'
	INCLUDE	'LSL$CMNROVER:FPPDAT.CMN'
	INCLUDE	'LSL$CMNROVER:DRAWIN.CMN'
	INCLUDE	'LSL$CMNROVER:GKS.CMN'
	INCLUDE	'LSL$CMNROVER:DIGCMN.CMN'
	INCLUDE	'LSL$CMNROVER:STPCMN.CMN'
	INCLUDE	'LSL$CMNROVER:DISCMN.CMN'
	INCLUDE	'LSL$CMNROVER:MAPCMN.CMN'
	INCLUDE	'LSL$CMNDTI:DTIHDR.CMN'
	INCLUDE	'LSL$CMNROVER:RASTED.CMN'
C 
C Functions
	REAL		RDREAL		!reads a real
C
	LOGICAL		GET_DTI_COORDS	!reads DTI input coords
	LOGICAL		GET_IFF_COORDS	!reads IFF input coords
	LOGICAL		HAD_PUCK	!is input from PUCK
	LOGICAL		READ_PUCK	!read puck command
	LOGICAL		INIT_TAB	!initialise table
	LOGICAL		WAIT_INPUT	!waits for input
	LOGICAL		ROVFIL		!to open and map DTI file
	LOGICAL		OPNIFF		!opens IFF file
	LOGICAL		OPNOUT		!opens output IFF file
  	LOGICAL		RDCH		!reads a character
  	LOGICAL		RDCHS		!reads a character
	LOGICAL		READLL		!reads lat/long
	LOGICAL		FRTINI		!to read FRT file
	LOGICAL		SRIINI		!to read SRI file
	LOGICAL		TRIINI		!to read TRI file
	LOGICAL		RDSEL		!read fc selection
	LOGICAL		RDLAY		!read layer selection
	LOGICAL		RDFSN		!read fsn. selection
	LOGICAL		TRNALL		!translate logical names
	LOGICAL		FLWOPN		!open file for write access
	LOGICAL		FLWEXT		!open file for extension
	LOGICAL		CHECK_MODE	!check mode of operation
	LOGICAL		GET_FREE_AND_BASE !select files for REGISTER
	LOGICAL		HADCTRLC	!CTRLC check
	LOGICAL		DISABLE		!true if disable command
C
	INTEGER		RDCOMM		!reads command
	INTEGER		GETFILNAM	!parses file name
	INTEGER		RDLONG		!reads a long
	INTEGER		SYS$ASSIGN	!assigns channel
	INTEGER		TTRSTR		!reads string from term
	INTEGER		DTI_CLOSE	!close DTI file
	INTEGER		LIB$SPAWN	!spawns DCL operations
	INTEGER		TEST_TERM	!input a terminal?
	INTEGER		LIB$DELETE_FILE
	INTEGER		DTI_UNITS	!test units
C
	LOGICAL		OPEN_RCP_FILE	!opens an existing RCP file
	LOGICAL		CREATE_RCP_FILE	!creates a new RCP file
C
	INTEGER*2	GET_BUTTON	!reads button number
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C 	LUNs used throughout ROVER are as follows:
C
C	IFF units are    :  1, 2, 3, 4 (may be < = 4 IFFs in furture)
C	DTI LUNs are     :  1, 2, 3, 4 (< = 4 DTIs are allowed)
C	IFF-RCP LUNs are :  5..8
C	DTI-RCP LUNs are :  9..12
C	RCPLUN           : 13
C	TEMPIFFLUN       : 14
C	COL_LUN          : 5 (used for DTI colour display)
C	COMLUN		 : 16 Rover Command File lun
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	EXTERNAL 	PUT_OUTPUT
C main command table
	EXTERNAL	ROVER_CMD_TABLE 	!command table
C
C secondary command tables
	EXTERNAL	SEL_CMD_TABLE
	EXTERNAL	SHOW_CMD_TABLE
	EXTERNAL	UNIT_CMD_TABLE
	EXTERNAL	LAB_CMD_TABLE
	EXTERNAL	SET_CMD_TABLE
	EXTERNAL	ROT_CMD_TABLE
	EXTERNAL	DRAW_CMD_TABLE
	EXTERNAL	LEG_CMD_TABLE
	EXTERNAL	SETUP_CMD_TABLE
	EXTERNAL	ENABLE_CMD_TABLE
	EXTERNAL	INTERPOLATE_CMD_TABLE
	EXTERNAL	OPEN_CMD_TABLE
	EXTERNAL	CREATE_CMD_TABLE
	EXTERNAL	TABLE_CMD_TABLE
C
C control/C handler
	EXTERNAL	CTRLCAST
C
C Local Variables 
	INTEGER		CMD		!Command number
	INTEGER		ERRCOD		!Error codes
	INTEGER		RET		!Return code
	INTEGER		TOTAL(4)
	INTEGER		XVAL1,XVAL2	!centering coordinates
	INTEGER		YVAL1,YVAL2
	INTEGER		COMAND		!command number
	INTEGER		TOPCOL
	INTEGER	  	SECCMD
	INTEGER		SAVCHN		!save for DTICHAN
	INTEGER		I,J,K		!counting variable
	BYTE		IB
	EQUIVALENCE	(I,IB)
C
	BYTE		CH
C
	REAL		X(2),Y(2)
C
	CHARACTER*80	LINE
C
	INTEGER*2	PTR		!decoding pointer
	INTEGER*2       BUTNO		!button number
C
	LOGICAL*1 	SIGN  
C
	LOGICAL		NEWSTP		!recalculate step?
	LOGICAL		TERM		!is a terminal
	LOGICAL		JOIN		!join line when interp_edit?
	LOGICAL		SOME_FILE_OPEN	!some DTI of IFF file openned?
	LOGICAL		WAS_EDITING	!were we in edit mode?
	LOGICAL		WAS_REGISTERING	!were we in registration mode?
	LOGICAL		OK,END_OF_LINE
	LOGICAL		IFF_OK,DTI_OK	!IFF/DTI ok?
	CHARACTER*1	TRANSLATION	!log name translation
C
C-----------------------------------------------------------------------
C
C Initialise LSLLIB
	CALL LSL_INIT(.FALSE.)		!don't want timing statistics
C
C Want our own output
	CALL LSL_SET_OUTPUT(PUT_OUTPUT)
C
C Set up a ROVER exit handler
	CALL EXIT_INIT
C
C Initialise DTILIB
	CALL DTI_INIT
C
C Let's announce ourself
	CALL DTMJPI
	CALL WRITEF(' ')
C
C Other initialisation
C GKS and workstation
	CALL INIT_DEVICE		
C
C Display variables
	CALL INIT_DISPLAY
C
C Raster related variables
	CALL INIT_RASTER
C
C Vector file related variables
	CALL INIT_VECTOR
C
C Other variables
	HADQIO = .FALSE.		!not had a QIO
	TRACKING = .FALSE.		!map set to DTI
	FIRST_FLOOD = .TRUE.		!we've not flooded yet
	RELOOKUP = .TRUE.		!need to lookup colours again
	WAS_EDITING = .FALSE.		!not editing
	EDITING = .FALSE.		!not in EDITING mode
	DIGITISING = .FALSE.		!not in DIGITISING mode
	REGISTERING = .FALSE.		!not in REGISTERING mode
	FLOODING = .FALSE.		!not in FLOODING mode
	HAD_ABSOLUTE=.TRUE.		!absolute coordinates
	BALL_WAIT = 100			!default trackerball delay
	HAD_SAMPLE = .FALSE.		!not sub-sampling
C
C--------------------------------------------------------------------
C input from terminal or command file
	CMDFIL = .FALSE.
	CALL TEST_TERM('SYS$INPUT',CMDFIL,ERRCOD)
	CMDFIL = .NOT.CMDFIL
C
C set up control/C handler
	IF (.NOT.CMDFIL) CALL SET_OUTBAND_AST(CTRLCAST,8)	!enable AST
	CALL HADCTRLC						!clear CTRLC
C
C--------------------------------------------------------------------
C initialise digitising table
C
	TABLE=.TRUE.				! initial assumption
	RET = TRNALL('LSL$AUTO_ENABLE_TABLE',TRANSLATION)
C
	IF(.NOT.RET.OR.TRANSLATION.NE.'1')THEN
	   TABLE = .FALSE.
	ELSE
	   TABLE = .TRUE.
	   IF(TABLE) THEN
	      IF (INIT_TAB(,IERR)) THEN
	         CALL WRITEF
     &	         ('%S Failed To initialise table monitor',WBELL)
	         CALL WRITEF
     &           ('Program will assume no table is available')
	         CALL WRITEF(' ')		! needed inexplicably
	         TTODON = .TRUE.
	         TABLE = .FALSE.
	      END IF	
	      TTODON = .TRUE.
	   ENDIF
	ENDIF
C
C assign input and output channels
	IERR = SYS$ASSIGN('SYS$INPUT',IN_CHAN,,)
	IF (.NOT.IERR) THEN
	  CALL LSL_PUTMSG(IERR)
	  GOTO 99999		! exit
	END IF
C
	HADQIO = .FALSE.	! no QIO active
	OTERM = .FALSE.		! assume not
	OK = TEST_TERM('SYS$OUTPUT',TERM,IERR)
	IF (.NOT.OK) THEN
	   IF (OK.EQ.LSL__SYSERR) THEN
	      CALL LSL_PUTMSG(IERR)
	   ELSE
	      CALL LSL_PUTMSG(OK)
	   END IF
	ELSE
	   OTERM = TERM
	END IF
C
C assign output channel
	IF (OTERM) THEN
	  IERR = SYS$ASSIGN('SYS$OUTPUT',OUT_CHAN,,)
	  IF (.NOT.IERR) THEN
	    CALL LSL_PUTMSG(IERR)
	    GOTO 99999		! exit
	  END IF
	END IF
C
C set event flag numbers
	IF (TABLE) THEN
	   CALL RETURN_EFN(EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
	   EF_TRKB = EF_VDU+1
	   EF_FB   = EF_VDU+2
	   EF_TIMER = EF_VDU+3
	ELSE
	   EF_VDU = 1
	   EF_TRKB = EF_VDU+1
	   EF_FB   = EF_VDU+2
	   EF_TIMER = EF_VDU+3
	END IF
C
C clear everything to be safe
	CALL SYS$CLREF(%VAL(EF_TIMER))
	CALL SYS$CLREF(%VAL(EF_TRKB))	
	CALL SYS$CLREF(%VAL(EF_FB))	
	CALL SYS$CLREF(%VAL(EF_ERROR))	
	CALL SYS$CLREF(%VAL(EF_POINT))	
	CALL SYS$CLREF(%VAL(EF_STREAM))	
	CALL SYS$CLREF(%VAL(EF_LAST))	
C
C***********************************************************************
C
10	DIRECT = .FALSE.
	IF (HADCTRLC()) THEN
	   IF (IN_COM) THEN
	      CALL WRITEF('Command File Execution aborted')
	      IN_COM = .FALSE.
	      RESPONDING = .FALSE.
	      CALL FLRCLO(COMLUN)
	   ENDIF
	ENDIF      
	HAD_TABLE  = .FALSE.
C	IF (.NOT.TABLE) GOTO 11
	IF (EDITING) THEN
C
C in edit mode - do something different on control-Z
	   IF (FLOODING) THEN
	      IF (.NOT.WAIT_INPUT('Flood')) GOTO 10400
	   ELSEIF (AREAING) THEN
	      IF (.NOT.WAIT_INPUT('Area')) GOTO 10400
	   ELSEIF (INTERPOLATING) THEN
	      IF (.NOT.WAIT_INPUT('Smooth')) GOTO 10400
	   ELSEIF (LINING) THEN
	      IF (.NOT.WAIT_INPUT('Line')) GOTO 10400
	   ELSE
	      IF (.NOT.WAIT_INPUT('Edit')) GOTO 10090
	   ENDIF
	ELSEIF (DIGITISING) THEN
	   IF (.NOT.WAIT_INPUT('Digitise')) GOTO 12190
	ELSEIF (REGISTERING) THEN
	   IF (.NOT.WAIT_INPUT('Registration')) GOTO 10109
	ELSE
	   IF (.NOT.WAIT_INPUT('Rover')) GOTO 10
	END IF
C
	IF (TABLE) THEN
	   IF (HAD_PUCK(IERR)) THEN		!table input
	      HAD_TABLE = .TRUE.
	      PRE_X_TAB = X_TAB
	      PRE_Y_TAB = Y_TAB
	      IF (READ_PUCK(BUTTON,X_TAB,Y_TAB,IERR)) THEN
	         CALL SHOW_ERROR(IERR)
	      ELSE
	         COMAND = BUTTON + 1
		 IF (EDITING) THEN
C
C Editing commands defined on puck
C
C			  MOVE  CENTRE   ENLARGE     REDUCE
		    GOTO(10000,    260,       70,        80,
C
C			  EDIT     END    REMOVE      EN/DI CROSS_CURS
     &			 10200,   9190,    10500,     12900 ,
C
C			  LEFT      UP     RIGHT       DOWN
     &		         11000,  10700,    10900,     10800,
C
C			 AREA_ED SMOOTH_ED EN/DI FLOOD abandon edit
     &			 10300,  10600,    11500,     10400) COMAND  
C
		 ELSEIF (REGISTERING)THEN
C
C    Registering commands largely as in EDIT mode
C			  MOVE  CENTRE   ENLARGE     REDUCE
		    GOTO(10000,    260,       70,        80,
C
C			  RCP_ADD 
     &			 11160,     10,       10,        10,
C
C			  LEFT      UP     RIGHT       DOWN
     &		         11000,  10700,    10900,     10800,
C
C			                             abandon reg.
     &			 10,        10,       10,     10109) COMAND  
C
		 ELSE
	             GOTO(9600,		! display cursor
     &	                   260,		! centre
     &	                    70,		! enlarge
     &	                    80,		! reduce
     &	                  9100,		! start
     &	                  9190) COMAND	! end
	         ENDIF
	      ENDIF
	   ENDIF
	ENDIF
C
	IF (HAD_TRKB.OR. HAD_TIMER) THEN
	    GOTO 10000
	ELSEIF (HAD_FB) THEN			
	    BUTNO = GET_BUTTON()
C
C  EDIT MODE commands
C
	    IF (EDITING) THEN
C
C		     EDIT     END    REMOVE
	      GOTO (10200,   9190,   10500) BUTNO
C
C  REGISTRATION MODE commands
	    ELSE IF (REGISTERING) THEN
C			 ADD
	      GOTO (10, 11150, 10) BUTNO
	    ENDIF
	ELSE				! must be command from VDU
C
C check for empty line comment or @
C
	   IF (RDCHS(CH)) GOTO 10	! substantially empty line
	   IF (CH.EQ.'!') GOTO 10	! comment!
	   IF (CH.EQ.'@') GOTO 12400	! @ command RDCOMM can't cope
	   CALL BSLN
C
C Decode the line
12	   CALL BSLN
	   CMD = RDCOMM(ROVER_CMD_TABLE)
	   IF (CMD .LE. 0) THEN
	      CALL WRITEF('%S unrecognised command',EBELL)
	      GOTO 10
	   ENDIF
C
C NB. Left/right sequence reversed wrt. the above
C
	   GOTO (
C
C       DTI/FILEIN  WIN    RAN    STE    LEG    ENL    RED    CLE   DIS
     &       20,    30,    40,    50,    60,    70,    80,    90,   100,
C
C	    SHO      EXI    HEL    QUAD   
     &      110,   90000,   130,   150,   
C
C           LAB   LUT    UNI    PLA    CEN    CLO
     &      220,  230,   240,   250,   262,   280,
C
C	    FIR    COL    RCP  TABLE
     &      300,   310, 11200, 11300, 
C
C           SEL  DESEL    IFF,   FRT    SRI    TRI IFFWIN    ENA   DISA
     &	   5000,  6000,  3900,  4300,  4400,  4500,  4100,  6500,  6510,
C
C	    INT    TOL    
     &     7010,  7020,  
C
C   	   OVERL   FLO    SET   WAIT   OUTP   STAR   END  
     &     8500,  8600,    8800,  8900,  9000,  9150, 9200, 
C
C           ROT   FAST   SPAW    SCA   MOVE   EDIT  AREA_EDIT REMOVE
     &     9500,  9700,  9800,  9900, 10000, 10200, 10300,     10500,
C
C   SMOOTH_EDIT     UP   DOWN   LEFT  RIGHT   ZOOM RESET_MINMAX
     &	  10600, 10700, 10800, 10900, 11000, 11100, 11600,
C
C	 MODTEN  UPDATE_DTI  ABANDON       SETUP   DRAW
     &	  11700,    11800,    10400,       11900, 12000,
C
C          MESSAGE     PING     RESPOND  CONTINUE
     &    12500,      12600,   12700,   12800,
C
C	  OPEN	  CREATE  SAMPLE
     & 	  13000,  13500,  13900   )CMD
C
	ENDIF
C
	GOTO 10
C-----------------------------------------------------------------------
C FILEIN
C
20	IF (.NOT.CHECK_MODE(3,'FILEIN')) GOTO 10
	IF (ROVFIL(.FALSE.))GOTO 10	!not read in file
	CALL UPDATE_TRANSFORMATIONS()	!set tracking-area to DTI transf
C
C Set up default step values for file read in
C default step is value range/number of colours
C
	CALL SETSTP(NOCOL(DTICHAN),.FALSE.)
	RELOOKUP = .TRUE.
C
	GOTO 10
C-----------------------------------------------------------------------
C WINDOW Command - define DTI window for table tracking area
C
30 	IF (.NOT.CHECK_MODE(3,'WINDOW'))GOTO 10
	CALL ROVWIN(TRACKING)
	TTOPRO = .TRUE.
	HADWIND = .TRUE.
	NEW_WINDOW_RANGE  = .TRUE.	! for SHOW_RANGE
	GOTO 10
C
C-----------------------------------------------------------------------
C RANGE 
C
40	CONTINUE
	IF (.NOT.CHECK_MODE(3,'RANGE')) GOTO 10
	IF (CMDICT .NE. 2 ) THEN
	   CALL WRITEF('%S specifying command RANGE',EBELL)
	   CALL WRITEF('Command requires two integer arguments')
	   GOTO 10
	ENDIF
C
C	Test input range values....
C
	IF (INTARG(1).GT.INTARG(2)) THEN		!allow 0 range!!
	  CALL WRITEF('%S specifying command RANGE',EBELL)
	  CALL WRITEF('Lower value exceeds upper value')
	  GOTO 10
	END IF
C
C make sure inside file range
	CALL TEST_RANGE(INTARG(1),INTARG(2))
C
C	Range O.K.
	HLOWER(DTICHAN) = INTARG(1)
	HUPPER(DTICHAN) = INTARG(2)
	IF (HUPPER(DTICHAN) .EQ. HLOWER(DTICHAN)) 
     &  STEP_ONE(DTICHAN)=.TRUE.
	RELOOKUP = .TRUE.
	FIRST_FLOOD = .TRUE.
C
C	Adjust number of steps and step interval values accordingly
C	This is a bit of a fudge!
C
	CMDICT = 0
	NSTEP(DTICHAN) = 0
	TOTAL(DTICHAN) = HLOWER(DTICHAN)
	IF (STEP_ONE(DTICHAN)) THEN
	   HSTEP(DTICHAN,1) = HLOWER(DTICHAN)
	   NSTEP(DTICHAN) = 1
	   I = 2
	ELSE
	   I = 1
	ENDIF
	GOTO 57
C	END IF
C
C-----------------------------------------------------------------------
C STEP Command
50	IF (.NOT.CHECK_MODE(3,'STEP')) GOTO 10
	FIRST_FLOOD = .TRUE.
	IF (CMDICT .EQ. 0) THEN
	  CALL WRITEF('%S specifying comamnd STEP',EBELL)
	  CALL WRITEF
     &	  ('Command requires at least one integer argument')
	  GOTO 10
	END IF
	DO 52 I = 1,CMDICT
	  IF (INTARG(I).LT.1) THEN
	    CALL WRITEF('%S specifying command STEP',EBELL)
	    CALL WRITEF('Step values should be greater than 1')
	    GOTO 10
	  END IF
52	CONTINUE
	RELOOKUP = .TRUE.
C
C	OK so transfer to STEPS array
C
	DO 53 I = 1,CMDICT
	   STEP(DTICHAN,I) = INTARG(I)
53	CONTINUE
C
C make the first step interval  be what it takes to make the 
C second step start on a whole step value
C only do this in caset of one argument
	IF (CMDICT .EQ. 1) THEN
	   IF (MOD(HLOWER(DTICHAN),STEP(DTICHAN,1)) .NE. 0) THEN
	      CMDICT = 2
	      INTARG(2) = STEP(DTICHAN,1)
	      STEP(DTICHAN,2) = STEP(DTICHAN,1)
	      STEP(DTICHAN,1) = STEP(DTICHAN,1) - 
     &	      MOD(HLOWER(DTICHAN),STEP(DTICHAN,1))
	   ENDIF
	ENDIF
C
C Fill out remainder with last step value up to no colours in table
C 
	DO 54 I = CMDICT+1,NOCOL(DTICHAN)
	   STEP(DTICHAN,I) = INTARG(CMDICT)
54	CONTINUE
	NSTEP(DTICHAN) = CMDICT
C
C recognise the special case of a step of 1
	IF (INTARG(1) .EQ. 1 .AND. CMDICT .EQ. 1) THEN
	   STEP_ONE(DTICHAN) = .TRUE. 
	   I = 2
	   HSTEP(DTICHAN,1) = HLOWER(DTICHAN)
	   TOTAL(DTICHAN) = HLOWER(DTICHAN)
	   IF (HLOWER(DTICHAN) .EQ. HUPPER(DTICHAN)) GOTO 51
	   GOTO 57
	ELSE
	   STEP_ONE(DTICHAN) = .FALSE.
	ENDIF
C
C	Variable step mechanisim.
C
55	TOTAL(DTICHAN) = HLOWER(DTICHAN)
	DO 56 I = 1,NSTEP(DTICHAN)
	  TOTAL(DTICHAN) = TOTAL(DTICHAN)+STEP(DTICHAN,I)
	  IF (TOTAL(DTICHAN).EQ.HUPPER(DTICHAN)) THEN
	    HSTEP(DTICHAN,I) = HUPPER(DTICHAN)
	    NSTEP(DTICHAN) = I
	    GOTO 51
	  END IF
	  IF (TOTAL(DTICHAN).GT.HUPPER(DTICHAN)) THEN
	    NSTEP(DTICHAN) = I
	    CALL WRITEF('%S range exceeded',WBELL)
	    CALL WRITEF('Step %N is truncated to %N',I,
     &	HUPPER(DTICHAN)-HSTEP(DTICHAN,I-1)-1)
	    HSTEP(DTICHAN,I) = HUPPER(DTICHAN)
	    IF (I.NE.CMDICT) THEN
	      CALL WRITEF('and remaining steps ignored.')
	    END IF
	    GOTO 51
	  END IF
	  HSTEP(DTICHAN,I) = TOTAL(DTICHAN)
56	CONTINUE	
C
C 
57	IF (TOTAL(DTICHAN).LT.HUPPER(DTICHAN)) THEN	
	   HSTEP(DTICHAN,I)
     &	   = MIN(HUPPER(DTICHAN),(TOTAL(DTICHAN)+STEP(DTICHAN,I)))
	   TOTAL(DTICHAN) = HSTEP(DTICHAN,I)
	   NSTEP(DTICHAN) = NSTEP(DTICHAN)+1
	   IF (NSTEP(DTICHAN) .GT. NOCOL(DTICHAN) ) THEN
	       CALL WRITEF
     &	       ('%S Too many steps for available colours',WBELL)
	       CALL WRITEF('Upper steps shown in white')
	       NSTEP(DTICHAN) = NSTEP(DTICHAN) - 1
	   ELSE
	      I = I+1
	      GOTO 57
	   END IF
	END IF
C
C set up colour table array so that colour indices are spread evenly
C through the colour table. only applicable if fewer steps than colours
C mod - remove this condition 
C	IF (NSTEP(DTICHAN) .LT. (NOCOL(DTICHAN))) THEN
51	   DO 58 J = 1,NSTEP(DTICHAN)
	      I = J*NOCOL(DTICHAN)/NSTEP(DTICHAN)+BASECOL(DTICHAN)
	      COLTAB(J+2,DTICHAN) = IB		! NB. equivalenced on I
58	   CONTINUE 
C	END IF
C
	IF (HLOWER(DTICHAN) .LT. 0 ) THEN
C
C negative height range
C add on offset so that array doesn't have ne subscripts
C
	  NEGOFF(DTICHAN) = (0 - HLOWER(DTICHAN))
	ELSE
	   NEGOFF(DTICHAN) = 0
	END IF
C
C Initialise loop
	HSTEP(DTICHAN,0) = HLOWER(DTICHAN) - 1
C
C set up array to link height values to each step
C
	DO 59 I = 1,NSTEP(DTICHAN)
	  DO 27 J = HSTEP(DTICHAN,I-1)+1+NEGOFF(DTICHAN),
     &	            HSTEP(DTICHAN,I)+NEGOFF(DTICHAN)
	    COLOUR(J,DTICHAN) = IB	! equivalenced onto I
27	  CONTINUE
C
59	CONTINUE
C fill remainder of array with NSTEP + 1
C this value will be recognised and displayed in white (see ICOL)
C
	I = NSTEP(DTICHAN)+1
	DO 28 J = HSTEP(DTICHAN,NSTEP(DTICHAN))+1+NEGOFF(DTICHAN),32767
	  COLOUR(J,DTICHAN) = IB
28	CONTINUE
	IF ((EDITING.OR.REGISTERING).AND. HADDTI(DTICHAN)) THEN
	   CALL DISPLY(CURPOS,DTICHAN)
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C LEGEND Command
C
C	Has the SIGMA been initialised, if not do so....
60	CMD = RDCOMM(LEG_CMD_TABLE)
	IF (CMD.LE.0) THEN		! unrecognised command
	  CALL WRITEF('%S specifying command LEGEND',EBELL)
	  CALL WRITEF('Command qualifier is POSITION') 
	  GOTO 10
	END IF
	GOTO 210	
C
C-----------------------------------------------------------------------
C ENLARGE Command
C
70	IF (ZOOMF.EQ.1) ZOOMF = 0
	ZOOMF = ZOOMF+2			!increment zoom factor
	IF (ZOOMF.GT.16) THEN
	  CALL WRITEF('Display is at maximum magnification')
	  ZOOMF = 16
	ELSE
	   IF (EDITING.OR.REGISTERING) THEN   
C
C zoom about the DTI cursor
	      CALL LSG_ZOOM_IMAGE
     &	      (WKID,REAL(X_CURPOS),REAL(Y_CURPOS),ZOOMF)
	   ELSE
	      CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	   ENDIF
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C REDUCE Command
C
80	IF (ZOOMF.EQ.2) ZOOMF = 3
 	ZOOMF = ZOOMF-2			!decrement zoom factor
	IF (ZOOMF.LE.0) THEN		!already at minimum zoom
	  CALL WRITEF('Display is at minimum magnification')
	  ZOOMF = 1
	  GOTO 10
	END IF
C
C zoom about cursor
	IF (ZOOMF.GT.1) THEN
	   IF (EDITING.OR.REGISTERING)THEN   
C
C zoom about the DTI cursor
	      CALL LSG_ZOOM_IMAGE
     &	     (WKID,REAL(X_CURPOS),REAL(Y_CURPOS),ZOOMF)
	   ELSE
	      CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	   ENDIF
	   GOTO 10
	END IF
C
C zoom out the image
	ZOOMX = RASTSZ(1)/2
	ZOOMY = RASTSZ(2)/2
	CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
C
C set zoom position to correct position
C	IF ((.NOT.DIVIDED).OR.HADPOS) THEN
C	   I = CURPOS
C	ELSE
C	  IF (CURPOS .EQ.  1) THEN
C	    I = 4
C	  ELSE
C	    I = CURPOS-1
C	  END IF
C	END IF
	ZOOMX = CENTRX(CURPOS)
	ZOOMY = CENTRY(CURPOS)
	GOTO 10
C
C
C-----------------------------------------------------------------------
C CLEAR Command
C
90 	IF (.NOT.CHECK_MODE(3,'CLEAR')) GOTO 10	
	CALL CLEAR
	GOTO 10
C
C-----------------------------------------------------------------------
C DISPLAY Command
C
100	IF (.NOT.CHECK_MODE(3,'DISPLAY')) GOTO 10
	CALL ROVDIS
	GOTO 10
C
C-----------------------------------------------------------------------
C SHOW Command
C
110 	CALL SHOW
	GOTO 10
C
C-----------------------------------------------------------------------
C SELECT FILEIN command
120	IF (.NOT.CHECK_MODE(3,'SELECT FILEIN'))GOTO 10
	IF (INTARG(1) .GT. 4.OR.INTARG(1) .LT. 1 
     &	 .OR. CMDICT .NE. 1) THEN
	  CALL WRITEF('%S specifying command SELECT FILEIN',EBELL)
	  CALL WRITEF
     &	  ('Command requires an integer argument in the range 1 to 4')
	ELSE
	   IF (.NOT.HADDTI(INTARG(1))) THEN
	     CALL WRITEF('%S specifying command SELECT FILEIN',EBELL)
	     CALL WRITEF('Input DTI file not yet opened')
	   ELSE
	      NEW_WINDOW_RANGE = .TRUE.
	      RELOOKUP = .TRUE.
	      IF (EDITING.OR.REGISTERING) THEN
C
C finish off editing previous DTI
	         CALL FINISH_EDIT
		 FIRST_FLOOD = .TRUE.
	      ENDIF
	      DTICHAN = INTARG(1)
C
C work out iff window
	      IF(HADIFF(IFFCHAN))THEN
	         CALL SET_IFFWIN
	      ENDIF
              IF (EDITING.OR.REGISTERING) THEN
C
C if we're in edit mode we try to set the current quadrant to where
C it was last displayed
		 IF (FILE_DISP(POS(DTICHAN)) .EQ. DTICHAN) THEN
		    CURPOS = POS(DTICHAN)
		    CALL INIT_EDIT
		 ELSE	
		    IF (DIVIDED) THEN
		       CURPOS = CURPOS + 1
	               IF (CURPOS .GT. 4) CURPOS = 1
		    ENDIF
	            CALL START_EDIT
		 ENDIF
	      ENDIF
	   END IF
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C HELP command
C
130	CALL HELP			!on-line system help
	GOTO 10
C
C-----------------------------------------------------------------------
C QUADRANT command
C
150	IF (.NOT.DIVIDED) THEN
	  CALL WRITEF('%S Specifying command QUADRANT',EBELL)
     	   CALL WRITEF
     &	   ('Command not valid unless the ENABLE DIVIDE command'
     &	    //' has been given')
	  GOTO 10
	END IF
	IF (.NOT.CHECK_MODE(9,'QUADRANT'))GOTO 10
	IF (INTARG(1) .LT. 1.OR.INTARG(1) .GT. 4.OR. (CMDICT .NE. 1)) 
     &    THEN
	  CALL WRITEF('%S specifying command QUADRANT',EBELL)
	  CALL WRITEF('Command requires an integer in the range 1 to 4')
	ELSE
	  CURPOS = INTARG(1)
	  HADPOS = .TRUE.
C
C	If enlargement factor is greater than 1
C	then update current cursor position
C
	  ZOOMX = CENTRX(CURPOS)
	  ZOOMY = CENTRY(CURPOS)
	  IF (ZOOMF.GT.1) CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C LABEL SIZE command
C
160	IF (INTARG(1).LT.1.OR.INTARG(1).GT.4.OR. CMDICT .NE. 1) THEN
	  CALL WRITEF('%S specifying Command LABEL SIZE',EBELL)
	  CALL WRITEF
     &	  ('Command requires an integer argument in the range 1 to 4')
	ELSE
	  LABSIZ(CURPOS) = INTARG(1)
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C LABEL POSITION command
C
170	IF(REALAR(1).LT. 0.OR.REALAR(1).GT.RASTSZ(1).OR.
     &    REALAR(2).LT. 0 .OR. REALAR(2).GT.RASTSZ(2) .OR.
     &    CMDRCT .NE. 2) THEN
	   CALL WRITEF('%S specifying command LABEL POSITION',EBELL)
	   CALL WRITEF
     &	('Command requires 2 reals in the range 0 to %N and 0 to %N'
     &     ,RASTSZ(1),RASTSZ(2))
	   GOTO 10
	ENDIF
	LABX(CURPOS) = REALAR(1)
        LABY(CURPOS) = REALAR(2)
	GOTO 10
C
C-----------------------------------------------------------------------
C SETUP MAP command - set up tracking area on digitising table which
C may be
C used to point to any part of any IFF or DTI file openned
C
190	IF (.NOT.TABLE) THEN		!not valid without table
	  CALL WRITEF('%S Specifying command SETUP MAP',EBELL)
	  CALL WRITEF('Command not valid without table')
	  GOTO 10
	END IF
	IF (.NOT.CHECK_MODE(9,'SETUP MAP'))GOTO 10
	SOME_FILE_OPEN = HADDTI(1).OR.HADDTI(2).OR.HADDTI(3)
     &	             .OR.HADDTI(4).OR.HADIFF(IFFCHAN)
	IF (.NOT.SOME_FILE_OPEN) THEN	!not valid if no file selected
	  CALL WRITEF('%S Specifying command SETUP MAP',EBELL)
	  CALL WRITEF('No input file yet opened')
	ELSE
	  CALL SET_TRACKING_AREA()	!set table tracking rectangle
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE TEXT command
C
200	IF (DISABLE) THEN
	  TEXTON = .FALSE.
	  IF (.NOT.(EDITING.OR.REGISTERING)) THEN
	     TEXT_BEEN_ON = .FALSE.
	  ENDIF
	ELSE
	  IF (.NOT.CHECK_MODE(9,'ENABLE TEXT'))GOTO 10
	  TEXTON = .TRUE.
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C LEGEND POSITION command
C
210	IF(REALAR(1).LT. 0.OR.REALAR(1).GT.RASTSZ(1).OR.
     &    REALAR(2).LT. 0 .OR. REALAR(2).GT.RASTSZ(2) .OR.
     &     CMDRCT .NE. 2) THEN
	   CALL WRITEF('%S specifying command LEGEND POSITION',EBELL)
	   CALL WRITEF
     &	('Command requires 2  reals in the range 0 to %N and 0 to %N'
     &     ,RASTSZ(1),RASTSZ(2))
	   GOTO 10
	ENDIF
C
	LEGX(CURPOS) = REALAR(1)
	LEGY(CURPOS) = REALAR(2)
	GOTO 10
C
C-----------------------------------------------------------------------
C LABEL command
C
220	CMD = RDCOMM(LAB_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  CALL WRITEF('%S specifying command LABEL',EBELL)
	  CALL WRITEF
     &	  ('Command qualifiers are POSITION ,COLOUR , or SIZE')
	  GOTO 10
	END IF
	GOTO (170,160,225) CMD
C
C-----------------------------------------------------------------------
C LABEL COLOUR command
225	NUMCOL = 2**(8-NOPLNS)-1
	IF (INTARG(1) .LT. 0.OR.INTARG(1).GT. NUMCOL.OR.CMDICT.NE.1) 
     &	  THEN
	  CALL WRITEF('%S specifying command LABEL COLOUR',EBELL)
	  CALL WRITEF
     &	  ('Command requires an integer in the range 0 to %N',
     &	    NUMCOL)
	  GOTO 10
	END IF
	LABECOL = INTARG(1)
	GOTO 10
C-----------------------------------------------------------------------
C LUT command
C
230	IF (.NOT.CHECK_MODE(3,'LUT'))GOTO 10
	CALL LUTSET
	FIRST_FLOOD  = .TRUE.
	GOTO 10
C
C-----------------------------------------------------------------------
C UNITS command
C
240	CMD = RDCOMM(UNIT_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  CALL WRITEF('%S specifying command UNITS',EBELL)
	  CALL WRITEF('Command should be followed by MATRIX, METRES, '
     &	  //'LATLONG, SECONDS or PROJECTION')
	  GOTO 10
	END IF
C
	RET = DTI_UNITS(DTICHAN,CMD)
	IF (.NOT. RET) THEN
	   IF (RET .EQ. DTI__INVUNITS) THEN
	      CALL WRITEF('%S Specifying command UNITS',EBELL)
	      CALL WRITEF
     &        ('Command qualifier is invalid for the input file')
	   ELSE
	       CALL LSL_PUTMSG(RET)
	   ENDIF
	   GOTO 10
	ENDIF
C
	UNTYPE(DTICHAN) = CMD
	IF(REGISTERING)THEN
          CALL CLEAR_STATUS
	  CALL SETUP_STATUS(CURPOS)
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C PLANES command
C
250	IF (.NOT.CHECK_MODE(3,'PLANES'))GOTO 10
	IF (INTARG(1) .LT. 5.OR.INTARG(1) .GT. 8.OR.CMDICT .NE. 1) THEN
	   CALL WRITEF('%S specifying command PLANES',EBELL)
	   CALL WRITEF
     &	   ('Command requires 1 integer argument in the range 5 to  8')
	   GOTO 10
	ELSE
C
C	If registering or editing, undo the cursor to avoid
C	2 cursors appearing on the screen after display
	   IF(REGISTERING.OR.EDITING)THEN
	     CALL MOVE_CURSOR(X_CURDTI,Y_CURDTI,.FALSE.,.TRUE.)
	   ENDIF
C
	   NOPLNS = INTARG(1)
	   PLANE_MASK = 2**NOPLNS-1
	   HADPIC(1) = .TRUE.
	   HADPIC(2) = .FALSE.
	   IF (NOPLNS .EQ. 5) THEN
              CALL LSG_SET_LUT(WKID,'LSL$LOOKUP:ROVER5.DAT') 
	   ELSEIF (NOPLNS .EQ. 6) THEN
	      CALL LSG_SET_LUT(WKID,'LSL$LOOKUP:ROVER6.DAT')
	   ELSEIF (NOPLNS .EQ. 7) THEN
	      CALL LSG_SET_LUT(WKID,'LSL$LOOKUP:ROVER7.DAT')
	   ELSE
	      CALL LSG_SET_LUT(WKID,'LSL$LOOKUP:ROVER8.DAT')
	   END IF
C
	   NUMCOL = 2**(8-NOPLNS)-1
C	Set up text colour
	   IF      (NOPLNS.EQ.7)THEN
	     TEXTCOL = 127
	   ELSE IF(NOPLNS.EQ.8)THEN
	     TEXTCOL = 249
	   ELSE
	     TEXTCOL = 1
	   ENDIF
C	     
	   SAVCHN = DTICHAN		! save current channel
	   DO 255 DTICHAN = 1,4
	      NOCOL(DTICHAN) = PLANE_MASK-2
	      IF(HADDTI(DTICHAN)) CALL SETSTP(NOCOL(DTICHAN),.FALSE.)
255	   CONTINUE
	   DTICHAN = SAVCHN
C
	END IF
C
C clear picture 2 - This avoids garbage being left in picture 2
C after the planes have been changed.
	CALL LSG_PLANE_SELECT(WKID,.NOT.(PLANE_MASK))
	CALL LSG_PLANE_OFFSET(WKID,NOPLNS)
	DO 257 I = 0,4
	   VEC_SHOWN(I) = .FALSE.
257	CONTINUE
	CALL GSFACI(0)		! fill area colour 0 (background)
	CALL GSFAIS(GSOLID)	! solid fill
	X(1) = SX(0)
	X(2) = EX(0)
	Y(1) = SY(0)
	Y(2) = EY(0)
	CALL LSG_FILL_RECTANGLE(X,Y)
	CALL GUWK(WKID,GSUPP)
C
	RELOOKUP = .TRUE.
	FIRST_FLOOD = .TRUE.
	IF ((EDITING.OR.REGISTERING).AND.HADDTI(DTICHAN)) THEN
	   CALL DISPLY(CURPOS,DTICHAN)
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C CENTRE command
C
260	IF (.NOT.TRACKING) THEN	
	   CALL WRITEF('%S No map has been registered',WBELL)
	   GOTO 10
	END IF
        CALL TRANSF(DTICHAN+4,X_TAB,Y_TAB,XVAL1,YVAL1)
	GOTO 264
C
C keyboard command
262	XVAL1 = INTARG(1)
	YVAL1 = INTARG(2)
	IF (CMDICT .NE. 2) THEN 
	   CALL WRITEF('%S specifying command CENTRE',EBELL)
	   CALL WRITEF
     &	   ('Command requires 2 integer arguments')
	ENDIF 
C
C	Ensure point is inside current DTI window
264	XVAL1 = MAX(DTI_WINDOW_SWX(DTICHAN),XVAL1)
	YVAL1 = MAX(DTI_WINDOW_SWY(DTICHAN),YVAL1)
	XVAL1 = MIN(DTI_WINDOW_NEX(DTICHAN),XVAL1)
	YVAL1 = MIN(DTI_WINDOW_NEY(DTICHAN),YVAL1)
C
C	Convert from DTI to screen coordinates and centre around point
C	Zoom around the invisible cursor
C
	IF (HADPOS) THEN
	   XCUR(DTICHAN) = 
     &     SIGSWX(CURPOS)+((XVAL1-DTI_WINDOW_SWX(DTICHAN))*SF(DTICHAN))
	   YCUR(DTICHAN) = 
     &     SIGSWY(CURPOS)+((YVAL1-DTI_WINDOW_SWY(DTICHAN))*SF(DTICHAN))
	ELSE
	   XCUR(DTICHAN) = 
     &     SIGSWX(POS(DTICHAN))+((XVAL1-DTI_WINDOW_SWX(DTICHAN))
     &     *SF(DTICHAN))
	   YCUR(DTICHAN) = 
     &     SIGSWY(POS(DTICHAN))+((YVAL1-DTI_WINDOW_SWY(DTICHAN))
     &     *SF(DTICHAN))
	END IF
	ZOOMX = XCUR(DTICHAN)
	ZOOMY = YCUR(DTICHAN)
	CALL LSG_ZOOM_IMAGE(WKID,ZOOMX,ZOOMY,ZOOMF)
	GOTO 10
C
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE DIVIDE command
C
270	IF (DISABLE) THEN
	   IF (.NOT.CHECK_MODE(3,'DISABLE DIVIDE'))GOTO 10
	   DIVIDED = .FALSE.
	   CURPOS = 0
	ELSE
	   IF (.NOT.CHECK_MODE(3,'ENABLE DIVIDE'))GOTO 10
	   DIVIDED = .TRUE.
	   CURPOS = 1
	END IF
C
C Check window limits for divided screen
	DO 274 I = 1,4
	   IF (HADDTI(I)) CALL CHKWIN(I)
274	CONTINUE
	DO 276 I = 0,4
	   FILE_DISP(I) = .FALSE.
276	CONTINUE
	IF (EDITING.OR.REGISTERING) THEN
	   CALL FINISH_EDIT
	   CALL START_EDIT
	ENDIF
	HADPOS = .TRUE.
	GOTO 10
C
C-----------------------------------------------------------------------
C CLOSE command
C
280	IF (.NOT.CHECK_MODE(3,'CLOSE'))GOTO 10
	CALL CLOFIL
	GOTO 10
C-----------------------------------------------------------------------
C FIRST command
C
300	IF (.NOT.CHECK_MODE(3,'FIRST_COLOUR'))GOTO 10
	IF (INTARG(1).LT.1.OR.INTARG(1).GT.PLANE_MASK .OR. CMDICT
     &	.NE. 1) THEN
	  CALL WRITEF('%S specifying command FIRST_COLOUR',EBELL)
	  CALL WRITEF
     &	  ('Command requires an integer argument in range 1 to %N',
     &	    PLANE_MASK+1)
	  GOTO 10
	END IF
	BASECOL(DTICHAN) = INTARG(1)-1
	I = INTARG(1)-1
	COLTAB(2,DTICHAN) = IB		! nb equivalenced on I
	NOCOL(DTICHAN) = MIN(NOCOL(DTICHAN),PLANE_MASK-I)
	CALL SETSTP(NOCOL(DTICHAN),.FALSE.)
	RELOOKUP = .TRUE.
	FIRST_FLOOD = .TRUE.
	IF ((EDITING.OR.REGISTERING).AND.HADDTI(DTICHAN)) THEN
	   CALL DISPLY(CURPOS,DTICHAN)
	ENDIF
	GOTO 10
C-----------------------------------------------------------------------
C COLOURS command
C
310	IF (.NOT.CHECK_MODE(3,'COLOURS'))GOTO 10
	IF (INTARG(1).LT.1.OR.INTARG(1).GT.255.OR.CMDICT .NE. 1) THEN
	   CALL WRITEF('%S Specifying command COLOURS',EBELL)
	   CALL WRITEF
     &     ('Command requires an integer in the range 1 to 255')
	   GOTO 10
	END IF
C
C	Are number of colours specified possible with current 
C	number of planes?
	IF (INTARG(1).GT.PLANE_MASK-2) THEN
	   CALL WRITEF('%S specifying command COLOURS',EBELL)
	   CALL WRITEF
     &  ('Use of %N colours not possible with current PLANES setting',
     &     INTARG(1))
	   GOTO 10
	END IF
C
	NOCOL(DTICHAN) = MIN(INTARG(1),PLANE_MASK-BASECOL(DTICHAN))
	IF ((BASECOL(DTICHAN) +INTARG(1)) .GT. (PLANE_MASK)) THEN
	   CALL WRITEF
     &	  ('%S Too many colours for current FIRST_COLOUR setting',WBELL)
	   CALL WRITEF('Only %N colours used',NOCOL(DTICHAN))
	ENDIF
C
C recalculate steps
C
	CALL SETSTP(NOCOL(DTICHAN),.FALSE.)
	RELOOKUP = .TRUE.
	FIRST_FLOOD = .TRUE.
	IF ((EDITING.OR.REGISTERING).AND.HADDTI(DTICHAN)) THEN
	   CALL DISPLY(CURPOS,DTICHAN)
	ENDIF
	GOTO 10				
C
C----------------------------------------------------------------------
C
C IFF open input IFF file containing the culture data
C
3900	IF (.NOT.OPNIFF(1))GOTO 10
	HADIFF(IFFCHAN) = .TRUE.
	CALL UPDATE_TRANSFORMATIONS()	!set tracking-area to DTI transf
C
C Initialise all selections (ie. no restriction on what is plotted)
C
	LYSMOD = .FALSE.
	FCSMOD = .FALSE.
	FSNMOD = .FALSE.
	CALL VIOCLR(LAYMAP,LAYMAX*4,-1)	 ! reset the whole bit-map.
	CALL VIOCLR(FCMAP,FCMAX*4,-1)	 ! reset the whole bit-map.
	CALL VIOCLR(FSNMAP,FSNMAX*4,-1)	 ! reset the whole bit-map.
	GOTO 10
C
C---------------------------------------------------------------------
C IFF WINDOW - define IFF window for table tracking area
C
4100	IF (.NOT.HADIFF(IFFCHAN)) THEN
	  CALL WRITEF('%S Specifying command IFFWINDOW',EBELL)
	  CALL WRITEF('Command requires that an IFF file is open')
	  GOTO 10
	END IF
C
	IF (CMDACT.NE.4) THEN		!prompt for window values
C
	  IF (TABLE) THEN
4110	     IF ( GET_IFF_COORDS(REALAR(1),REALAR(2),'SW Corner')) THEN
	       GOTO 4120
	     ELSE
	       GOTO 10
	     END IF
C
4120	     IF ( GET_IFF_COORDS(REALAR(3),REALAR(4),'NE Corner')) THEN
	       TTOPRO = .TRUE. 
	       GOTO 4130
	     ELSE
	       GOTO 10
	     END IF
	  ELSE
	    CALL WRITEF('%S Specifying command IFFWINDOW',EBELL)
	    CALL WRITEF('IFF Window command requires 4 values')
	    CALL WRITEF
     &	    (' SW x,y corner points followed by NE corner points')
	    GOTO 10
	  END IF
	END IF
C
4130	IF (REALAR(1).GE.REALAR(3).OR.REALAR(2).GE.REALAR(4)) THEN
	    CALL WRITEF('%S Specifying command IFFWINDOW',EBELL)
	  CALL WRITEF
     &    ('NE corner should exceed SW corner')
	  GOTO 10
	END IF
C
C	Check if window is inside sheet corners
C	IF (REALAR(1).LT.CNRS(3,2,IFFCHAN)
C     &	.OR.REALAR(2).LT.CNRS(4,2,IFFCHAN)
C     &	.OR.REALAR(3).GT.CNRS(3,4,IFFCHAN)
C     &	.OR.REALAR(4).GT.CNRS(4,4,IFFCHAN)) THEN
C	  CALL WRITEF('%S specified window exceeds '
C     &	  //'IFF control point values',WBELL)
C	END IF
C
	IF (HAD_ABSOLUTE) THEN
	   WIND(1,1,IFFCHAN) = REALAR(1)-ORIGIN_OFFSET(1,IFFCHAN)
	   WIND(1,2,IFFCHAN) = REALAR(2)-ORIGIN_OFFSET(2,IFFCHAN)
	   WIND(2,1,IFFCHAN) = REALAR(3)-ORIGIN_OFFSET(1,IFFCHAN)
	   WIND(2,2,IFFCHAN) = REALAR(4)-ORIGIN_OFFSET(2,IFFCHAN)
	ELSE
	   WIND(1,1,IFFCHAN) = REALAR(1)
	   WIND(1,2,IFFCHAN) = REALAR(2)
	   WIND(2,1,IFFCHAN) = REALAR(3)
	   WIND(2,2,IFFCHAN) = REALAR(4)
	ENDIF
	HADWIN = .TRUE.
	GOTO 10
C
C----------------------------------------------------------------------
C	FRT - read in specified Feature Representation Table
C
4300	HADFRT = .FALSE.
	RET = GETFILNAM(FRTTIT,FRTLEN,'LSL$FRT:FRT.FRT;0',.TRUE.)
	IF (.NOT.RET) THEN
	  CALL WRITEF('%S Specifying command FRT',EBELL)
	  CALL LSL_PUTMSG(RET)
	  GOTO 10
C
	ELSE
	  IF (FRTINI(FRTTIT)) GOTO 10
	  CALL FRT_GRAPH_INIT
	  INIFRT = .TRUE.
	  HADFRT = .TRUE.
	  GOTO 10
	ENDIF
C
C----------------------------------------------------------------------
C	SRI -read in specified symbol representation IFF file
C 	for defining symbols referenced by the FRT file.
C
4400	HADSRI = .FALSE.
	RET = GETFILNAM(SRITIT,SRILEN,'LSL$FRT:SRI.SRI;0',.TRUE.)
	IF (.NOT.RET) THEN
	    CALL WRITEF('%S Specifying command SRI',EBELL)
	   CALL LSL_PUTMSG(RET)
	   GOTO 10
	ELSE
	  IF (SRIINI(SRITIT)) GOTO 10
	  INISRI = .TRUE.
	  HADSRI = .TRUE.
	  SRIDEP = .FALSE.		!SRI name not derived from FRT
	  GOTO 10
	END IF
C
C----------------------------------------------------------------------
C	TRI -read in specified TEXT representation IFF file
C 	for defining text referenced by the FRT file.
C
4500	HADTRI = .FALSE.
	RET = GETFILNAM(TRITIT,TRILEN,'LSL$FRT:TRI.TRI;0',.TRUE.)
	IF (.NOT.RET) THEN
	   CALL WRITEF('%S Specifying command TRI',EBELL)
	   CALL LSL_PUTMSG(RET)
	   GOTO 10
	ELSE
	  IF (TRIINI(TRITIT)) GOTO 10
	  INITRI = .TRUE.
	  HADTRI = .TRUE.
	  TRIDEP = .FALSE.		!TRI name not derived from FRT
	  GOTO 10
	END IF
C
C-------------------------------------------------------------------
C
C SELECT, SELECT FC, SELECT LAYER, SELECT FSN, SELECT ALL
C if none of above secondaries given defaults to SELECT FC
C
C SELECT FC
C Select only the feature codes specified. Feature codes can be
C given explicitely (either singly or as ranges) or as group names
C (eg. SEL 20,30-35,55,WATER,200-300,CONTOURS).
C Delimiters may be either spaces or commas.
C Since the group names are undefined until we read in the FRT file
C (unless we have already done so) the SEL and DES commands must be
C stored up until they are defined.
C
5000	CALL DCPSAV(PTR)		! save decoding pointer
	NOMESS = .TRUE.			! stop CMDLIB error messages
	CMD = RDCOMM(SEL_CMD_TABLE)	! look for qualifier
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S Specifying command SELECT',EBELL)
	   CALL WRITEF
     &	('Command qualifiers are ALL, FC, FILEIN, FSN, RCP_FILE 
     &or LAYER')
	   GOTO 10
	ENDIF 
C
C                 FC  LAYER    FSN    ALL  FILEIN RCP_FILE
	GOTO (  5100,  5200,  5300,  5400,   120, 5500) CMD
C
	CALL DCPSET(PTR)		! reset decode pointer
C
C SELECT FC
5100	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command SELECT FC',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDSEL(.TRUE.,.FALSE.)) GOTO 10
	GOTO 10
C
C SELECT LAYER   (see LAYER command)
5200	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command SELECT LAYER',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDLAY(.TRUE.)) GOTO 10
	GOTO 10
C
C SELECT FSN
5300	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command SELECT FSN',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDFSN(.TRUE.)) GOTO 10
	GOTO 10
C
C SELECT ALL  Reset all selections
5400	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command SELECT ALL',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	LYSMOD = .FALSE.
	FCSMOD = .FALSE.
	FSNMOD = .FALSE.
	CALL VIOCLR(LAYMAP,LAYMAX*4,-1)	 ! reset the whole bit-map.
	CALL VIOCLR(FCMAP,FCMAX*4,-1)	 ! reset the whole bit-map.
	CALL VIOCLR(FSNMAP,FSNMAX*4,-1)	 ! reset the whole bit-map.
	GOTO 10
C
C	SELECT RCP_FILE
5500	CALL SELECT_RCP_FILE(.FALSE.)
	GOTO 10
C
C---------------------------------------------------------------------
C
C DESEL 
C DESELECT, DESELECT FC, DESELECT LAYER, DESELECT FSN
C if none of above secondaries given defaults to DESELECT FC
C
C DESELECT FC
C deselect only the feature codes specified. Feature codes can be
C given explicitely (either singly or as ranges) or as group names
C (eg. DESEL 20,30-35,55,WATER,200-300,CONTOURS).
C Delimiters may be either spaces or commas.
C Since the group names are undefined until we read in the FRT file
C (unless we have already done so) the SEL and DES commands must be
C stored up until they are defined.
C
6000	CALL DCPSAV(PTR)		! save decoding pointer
	NOMESS = .TRUE.
	CMD = RDCOMM(SEL_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S Specifying command DESELECT',EBELL)
	   CALL WRITEF('Command qualifiers are FC, FSN or LAYER')
	   GOTO 10
	ENDIF
C
C                 FC  LAYER    FSN    ALL
	GOTO (  6100,  6200,  6300,  6400) CMD
	IF (CMD.GT.4) GOTO  10		! ignore DESELECT DTI
C
C	No qualifier, so assume default ie. DESELECT FC
	CALL DCPSET(PTR)		! reset pointer
C
C DESELECT FC
6100	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command DESELECT FC',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDSEL(.FALSE.,.FALSE.)) GOTO 10
	GOTO 10
C
C DESELECT LAYER  
6200	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command DESELECT LAYER',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDLAY(.FALSE.)) GOTO 10
	GOTO 10
C
C DESELECT FSN
6300	IF (.NOT. INIFRT) THEN
	   CALL WRITEF('%S Specifying command DESELECT FSN',EBELL)
	   CALL WRITEF('Command invalid before FRT has been read')
	   GOTO 10
	ENDIF
	IF (RDFSN(.FALSE.)) GOTO 10
	GOTO 10
C
C DESELECT ALL is not a valid command
6400	CALL WRITEF('%S Specifying command DESELECT',EBELL)
	CALL WRITEF('DESELECT ALL is not a valid command')
	CALL WRITEF('Use SELECT ALL and then required selections')
	GOTO 10
C
C***********************************************************************
C ENABLE - enable options
C
6500	DISABLE = .FALSE.
	GOTO 6511
C
C***********************************************************************
C
C DISABLE
C Disallow options
C
6510	DISABLE = .TRUE.
6511	CMD = RDCOMM(ENABLE_CMD_TABLE)	
	IF (CMD.LE.0) THEN		! unrecognised command
	  IF (DISABLE) THEN
	     CALL WRITEF('%S Specifying command DISABLE',EBELL)
	  ELSE
	     CALL WRITEF('%S Specifying command ENABLE',EBELL)
	  ENDIF
C
	  CALL WRITEF
     &  ('Command qualifiers are ABSOLUTE, COLOUR_MAP, CROSS_CURSOR, ')
	 CALL WRITEF
     &  ('                       DEFAULT, DIGITISE, DIVIDE, ')
	  CALL WRITEF
     &  ('                       EDIT, FLOODING, HATCH, HEIGHT, '//
     &  'INTERPOLATION,') 
	  CALL WRITEF
     &  ('                       LEGEND, MASK, OVERRIDE, PATTERN '//
     &	'PICTURE')
	  CALL WRITEF
     &  ('                       POSITIONING, REGISTRATION, '//
     &	'SAMPLEC')
	  GOTO 10
	ENDIF
C
	GOTO ( 6520,	! interpolation
     &	      10100,	! edit
     &	      10110,	! registration
     &	      11500,	! flooding
     &        12200,	! digitising
     &	       9400,	! mask
     &	      12100,	! legend
     &	       8400,	! hatch
     &	        270,	! divide
     &	       7900,	! override
     &	       7100,	! pattern
     &	        200,	! text
     &	       8200,	! positioning
     &	       8000,	! height
     &	       8700,	! picture
     &	      12300,	! colour_map
     &	      12900,	! cross_cursor   
     &        13600,	! default
     &        12110,    ! table
     &        12120,    ! absolute
     &        14000	! sample
     &	) CMD
C
C INTERPOLATION - draw GT 6 as interpolated curves (default)
6520	INTLIN = .NOT.DISABLE
	GOTO 10
C
C***********************************************************************
C
C INTERPOLATE
C Specify interpolation algorithm, Akima (default) or McConalogue
7010	CMD =RDCOMM(INTERPOLATE_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	     CALL WRITEF('%S Specifying command INTERPOLATE',EBELL)
	     CALL WRITEF('Command qualifiers are AKIMA,'
     &	  //' or MCCONALOGUE')
	  GOTO 10
	ENDIF
	GOTO (7011,7012), CMD	! jump on secondary argument
C
C INTERPOLATE AKIMA
7011	MCCON = .FALSE.
	GOTO 10
C
C INTERPOLATE MCCONALOGUE
7012	MCCON = .TRUE.
	GOTO 10
C
C***********************************************************************
C
C TOLERANCE
C
C TOLERANCE -  segment length (mm) for drawn curves
C 1st number - segment length (mm)
C 2nd number - arc to chord distance (mm)
C 3rd number - angle (radians)
C
C first fault negative valuies
7020	DO 7025 I = 1,CMDRCT
	   IF (REALAR(I) .LT. 0.0) THEN
	      CALL WRITEF('%S Specifying command TOLERANCE',EBELL)
	      CALL TTWSTR('Tolerance cannot be negative')
	      GOTO 10
	   END IF
7025	CONTINUE
C
C set up the specified tolerances
	DO 7026 I = 1,CMDRCT
	   INTCT(I) = REALAR(I)
7026	CONTINUE
C
C if values are now all zero, or none were given, set the default
	IF ((INTCT(1)+INTCT(2)+INTCT(3) .EQ. 0.0).OR.
     &					(CMDRCT .EQ. 0)) THEN
	   INTCT(1) = DEFCT
	   INTCT(2) = 0.0
	   INTCT(3) = 0.0
	END IF
	GOTO 10
C
C***********************************************************************
C
C ENABLE/DISABLE PATTERN
C Permit(+) or suppress(-) patterned lines (permit by default).
C If no 
7100	PATLIN = .NOT.DISABLE
	GOTO 10
C
C***********************************************************************
C
C ENABLE OVERRIDE
C Overide individual FS entries and set whole overlay to specified FS
C
7900	IF (DISABLE) GOTO 8300
	IF (CMDICT .NE. 2 .OR. INTARG(1) .LT. 0 .OR. INTARG(1) 
     &	.GT. 32767.OR. INTARG(2) .LT. 0 .OR. INTARG(2)
     &	.GT. 32767) THEN
	   CALL WRITEF('%S Specifying command ENABLE OVERRIDE',EBELL)
     	   CALL WRITEF
     &     ('Command requires two integer arguments'  
     &      //' in the range 0 to 32767')
	   GOTO 10
	ENDIF 
	IF (NOVRRD.GE.OVRDMX) THEN
	   CALL WRITEF('%S Specifying command ENABLE OVERRIDE',EBELL)
           CALL TTWSTR('Too many overrides specified')
	   GOTO 10
	END IF
	NOVRRD = NOVRRD+1
	OVERRD(1,NOVRRD) = INTARG(1)	
	OVERRD(2,NOVRRD) = INTARG(2)
	HADOVR = .TRUE.
	GOTO 10
C
C***********************************************************************
C
C ENABLE/DISABLE HEIGHT
C Take height of text from TH entry (default from FRT)
C
8000	TXTOPT = .NOT.DISABLE
	GOTO 10
C***********************************************************************
C ENABLE/DISABLE POSITIONING
C Take text positioning from FS entry (+ =  default)
C
8200	POSOPT = .NOT.DISABLE
	GOTO 10
C***********************************************************************
C
C DISABLE OVERRIDE
C Cancel overrides
8300	HADOVR = .FALSE.
	NOVRRD = 0
	GOTO 10
C
C***********************************************************************
C
C ENABLE/DISABLE HATCH
C Set hatching linewidth and separation (sheet mm)
C Remember the settings, for use in main program
8400	HADHAT = .NOT.DISABLE
	IF (ARGMSG.OR. DISABLE) THEN	! set original values
	   HATWID = SAVHWD
	   HATSEP = SAVHSP
	   GOTO 10
	END IF
	IF ((REALAR(1) .LT. 0 .OR. REALAR(2) .LT. 0 .OR. CMDRCT .NE. 2)
     &             .AND. HADHAT) THEN
	   CALL WRITEF('%S Specifying command ENABLE HATCH',EBELL)
	   CALL WRITEF('Command requires two Positive real arguments')
	   GOTO 10
	ENDIF
	HATWID = REALAR(1)
	HATSEP = REALAR(2)
	GOTO 10
C
C-----------------------------------------------------------------------
C OVERLAY plot the IFF file
C
8500	IF (.NOT.HADIFF(IFFCHAN)) THEN
	   CALL WRITEF('%S Specifying command OVERLAY',EBELL)
	   CALL WRITEF('Command requires that an IFF file is open')
	ELSE
	   CALL PLTIFF
	END IF
	GOTO 10
C-----------------------------------------------------------------------
C
C FLOOD command
8600	IF (.NOT. CHECK_MODE(9,'FLOOD'))GOTO 10
	CALL FLOOD
	GOTO 10
C
C----------------------------------------------------------------------
C ENABLE/DISABLE PICTURE
C
8700	IF (INTARG(1).LT.1.OR.INTARG(1).GT.2 .OR. CMDICT .NE. 1) THEN
	  IF (DISABLE)THEN
	     CALL WRITEF('%S Specifying command DISABLE PICTURE',EBELL)
	  ELSE
	     CALL WRITEF('%S Specifying command ENABLE PICTURE',EBELL)
	  ENDIF
	   CALL WRITEF
     &	   ('Command requires an integer in the range 1 to 2')
	   GOTO 10
	END IF
	IF (DISABLE) INTARG(1) = 3-INTARG(1)
	IF ((.NOT.DISABLE).AND.
     &       ((HADPIC(1).AND.INTARG(1).EQ.2).OR.
     &       (HADPIC(2).AND.INTARG(1).EQ.1))) THEN
	   CALL LSG_PLANE_VISIBLE(WKID,-1)
	   HADPIC(1) = .TRUE.
	   HADPIC(2) = .TRUE.
	ELSE
	   IF (INTARG(1).EQ.1) THEN
	      CALL LSG_PLANE_VISIBLE(WKID,PLANE_MASK)
	      HADPIC(1) = .TRUE.
	      HADPIC(2) = .FALSE.
	   ELSE
	      CALL LSG_PLANE_VISIBLE(WKID,.NOT.PLANE_MASK)
	      HADPIC(1) = .FALSE.
	      HADPIC(2) = .TRUE.
	   END IF
	END IF
	GOTO 10
C-----------------------------------------------------------------------
C SET
C
8800	COMAND = RDCOMM(SET_CMD_TABLE)	
	IF (COMAND .LE. 0) THEN
	   CALL WRITEF('%S specifying command SET',EBELL)
	  CALL WRITEF
     &	 ('Command qualifiers are COLOUR, CURSOR_COLOUR, DELAY, FC, '
     &	  //'FSN or LAYER ')
	   GOTO 10
	END IF
C             COLOUR     FC    FSN  LAYER,CURSOR_COLOUR, DEFAULT, DELAY
	GOTO (  8810,  8820,  8830,  8840, 8850, 13700,13800)COMAND
C
C SET COLOUR
C
8810	CALL COLSET
	GOTO 10
C
C SET FC
C
8820	IF(.NOT.CHECK_MODE(5,'SET FC')) GOTO 10
	IF (CMDICT .NE. 1 .OR. INTARG(1) .LT. 0 .OR. 
     &	    INTARG(1) .GT. 32767) THEN
	   CALL WRITEF('%S specifying command SET FC',EBELL)
	   CALL WRITEF
     &     ('Command requires integer in the range 0 to 32767')
	   GOTO 10
	ENDIF
	CURFC = INTARG(1)
	GOTO 10
C
C SET FSN
C
8830	IF(.NOT.CHECK_MODE(5,'SET FSN')) GOTO 10
	IF (CMDICT .NE. 1 .OR. INTARG(1) .LT. 0 .OR. 
     &	    INTARG(1) .GT. 65534) THEN
	   CALL WRITEF('%S Specifying command SET FSN',EBELL)
	   CALL WRITEF
     &     ('Command requires integer in the range 0 to 65534')
	   GOTO 10
	ENDIF
	FTNO = INTARG(1)
	GOTO 10
C
C SET LAYER
C
8840	IF(.NOT.CHECK_MODE(5,'SET LAYER')) GOTO 10
	IF (CMDICT .NE. 1 .OR. INTARG(1) .LT. 0 .OR. 
     &	    INTARG(1) .GT. 32767) THEN
	   CALL WRITEF('%S specifying command SET LAYER',EBELL)
	   CALL WRITEF
     &     ('Command requires integer in the range 0 to 32767')
	   GOTO 10
	ENDIF
	CURLAY = INTARG(1)
	GOTO 10
C
C SET CURSOR_COLOUR
8850	IF (.NOT. CHECK_MODE(2,'SET CURSOR_COLOUR')) GOTO 10
	IF (.NOT. CHECK_MODE(3,'SET CURSOR_COLOUR')) GOTO 10
	IF (INTARG(1).LT.1.OR.INTARG(1).GT.(PLANE_MASK+1) .OR. CMDICT
     &	.NE. 1) THEN
	  CALL WRITEF('%S Specifying command SET CURSOR_COLOUR',EBELL)
	  CALL WRITEF
     &	  ('Command requires an integer argument in range 0 to %N',
     &	    (PLANE_MASK+1))
	  GOTO 10
	END IF
	CURSOR_COL = INTARG(1)-1
	CALL MOVE_CURSOR(X_CURDTI,Y_CURDTI,.TRUE.,.FALSE.)
	GOTO 10
C 
C
C-----------------------------------------------------------------------
C	WAIT
8900	IF(CMDRCT .NE. 1.OR. REALAR(1) .GT. 1000 .OR. REALAR(1) .LT. 0)
     &   THEN
	   CALL WRITEF('%S specifying command WAIT',EBELL)
	   CALL WRITEF
     &	   ('Command requires a real in the range 1 to 1000')
	   GOTO 10
	ENDIF
	CALL LIB$WAIT (REALAR(1))
	GOTO 10
C
C-----------------------------------------------------------------------
C OUTPUT open output IFF file
C
9000	IF (.NOT.TRACKING) THEN
	   CALL WRITEF('%S Specifying command OUTPUT',EBELL)
	   CALL WRITEF('Command invalid without a map registered')
	   GOTO 10
	END IF
	IF (.NOT.CHECK_MODE(5,'OUTPUT')) GOTO 10
	IF (OPNOUT()) GOTO 10
	GOTO 10
C
C----------------------------------------------------------------------
C START 
9100	IF (.NOT.CHECK_MODE(5,'START'))GOTO 10
	CALL GETSTR(.TRUE.,.FALSE.)
	GOTO 10
9150	IF (.NOT.CHECK_MODE(5,'START'))GOTO 10
	CALL GETSTR(.FALSE.,.FALSE.)
	GOTO 10
C
C----------------------------------------------------------------------
C END
9190	CMDRCT=0				! from button
9200	IF (.NOT.CHECK_MODE(7,'END')) GOTO 10 
	IF (EDITING) THEN
	   IF (HAD_EDIT) THEN 
	      IF (FLOODING ) THEN
		 CALL WRITEF('%S Specifying command END',EBELL)
	         GOTO 10
	      ENDIF
	      IF (INTERPOLATING) THEN
	         CALL END_INTERP
	      ELSEIF (AREAING) THEN
	         CALL END_POLY
	      ELSE
	         CALL END_EDIT
	      END IF
	   ELSE
	      CALL WRITEF
     &	      ('%S Specifying command END',EBELL)
	      CALL WRITEF('No Edit pixels defined')
	   ENDIF
	ELSE  
	      CALL WRITEF
     &	      ('%S Specifying command END',EBELL)
	   CALL WRITEF('Command only valid during digitising or '
     &	   //'editing')
	END IF
	TTODON = .TRUE.
	 GOTO 10	
C
C----------------------------------------------------------------------
C ENABLE /DISABLE MASK means that vector drawing is to both pictures
C
9400	MASK = (.NOT.DISABLE)
	IF (.NOT.MASK) THEN
	   CURCOL = OLDCOL			!revert to previous col
	END IF
	GOTO 10
C
C----------------------------------------------------------------------
C ROTATE
C	Image Rotation
9500	IF (.NOT. CHECK_MODE(3,'ROTATE')) GOTO 10 
	CMD = RDCOMM(ROT_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command ROTATE',EBELL)
	   CALL WRITEF('Command Keywords are NORTH, SOUTH, EAST '
     &                //'or WEST')
	   GOTO 10
	END IF
	IF (CMD .EQ. 1) THEN
	   CUR_ROTATE(DTICHAN) = 0
	ELSEIF (CMD.EQ. 2) THEN
	   CUR_ROTATE(DTICHAN) = 3
	ELSEIF (CMD .EQ. 3) THEN
	   CUR_ROTATE(DTICHAN) = 2
	ELSE
 	   CUR_ROTATE(DTICHAN) = 1
	ENDIF
C
C Check window limits for divided screen
	DO 9501 I = 1,4
	   IF (HADDTI(I)) CALL CHKWIN(I)
9501	CONTINUE
	GOTO 10
C
C-----------------------------------------------------------------------
C Display cursor if map located
9600	IF (TRACKING) THEN
	   CALL GETSTR(.TRUE.,.TRUE.)	
	END IF
	GOTO 10
C-----------------------------------------------------------------------
C FAST for direct uncalculated byte display
9700	IF (.NOT.CHECK_MODE(3,'FAST'))GOTO 10
	DIRECT = .TRUE.
	CALL ROVDIS
	GOTO 10
C-----------------------------------------------------------------------
C SPAWN DCL process - primarily designed for file management
9800	I = 0
9810	IF (RDCH(CH)) THEN
	  GOTO 9820
	ELSE	
	  I = I+1
	  LINE(I:I) = CHAR(CH)
	  GOTO 9810
	END IF
C
9820	IF (I.EQ.0) THEN
	  CALL WRITEF('%S Specifying command SPAWN',EBELL)
	  CALL WRITEF('SPAWN requires a valid DCL command')
	  GOTO 10
	END IF
C
C
C disable CTRL/C outband AST so that CTRL/C will work in spawned process
	IF (.NOT.CMDFIL) CALL SET_OUTBAND_AST
C
C spawn command line
	IERR = LIB$SPAWN ( LINE(1:MIN(I,80)))
	IF (.NOT.IERR) THEN
	   CALL LIB$SIGNAL(%VAL(IERR))
	ELSE
C
C output two blank lines to ensure that we don't overwrite any of
C the possible output from the spawned command
	   CALL WRITEF
	   CALL WRITEF
	END IF
C
C re-enable CTRL/C recognition
	IF (.NOT.CMDFIL) CALL SET_OUTBAND_AST(CTRLCAST,8)
	GOTO 10
C-----------------------------------------------------------------------
C SCALE - specify enlargement factor for symbols, patterns, etc.
9900	IF (REALAR(1).LE.0.OR.CMDRCT .NE. 1) THEN
	   CALL WRITEF('%S specifying command SCALE',EBELL)
	   CALL WRITEF('Command requires a positive real number')
	ELSE
	   SCAFAC = REALAR(1)
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C MOVE - move editing cursor to given position
10000	IF (.NOT.CHECK_MODE(2,'MOVE')) GOTO 10
	IF (HAD_TABLE .OR. HAD_TRKB) THEN
C
C move is interactive flooding when in flood mode if from trackerball
C or table
	   IF (FLOODING) GOTO 11400
	ENDIF
	CALL ROVMOVE
	GOTO 10
C-----------------------------------------------------------------------
C ENABLE/DISABLE EDIT - enable the editing options
C
10090	DISABLE= .TRUE.		! comes here if control/z in edit mode
C
10100	IF (DISABLE) THEN
	   IF (.NOT.CHECK_MODE(4,'DISABLE EDIT')) GOTO 10
	   IF (.NOT.CHECK_MODE(8,'DISABLE EDIT')) GOTO 10
	ELSE
	   IF (.NOT.CHECK_MODE(4,'ENABLE EDIT')) GOTO 10
	   IF (.NOT.CHECK_MODE(8,'ENABLE EDIT')) GOTO 10
	ENDIF
	IF (.NOT.(HADDTI(1).OR.HADDTI(2).OR.HADDTI(3).OR.HADDTI(4)))
     &	    THEN
	   IF (.NOT. DISABLE) THEN
	      CALL WRITEF('%S Specifying command ENABLE EDIT',EBELL)
	      CALL WRITEF
     &	      ('Command requires that a DTI file is open')
	       GOTO 10
	   ELSE
	      EDITING = .FALSE.
	   ENDIF
	ENDIF
	WAS_EDITING = EDITING
	EDITING = (.NOT.DISABLE)
	CALL BALINIT(EDITING)
	MOVED_RECENTLY = .FALSE.
	IF (EDITING) THEN
	   IF (.NOT.WAS_EDITING) CALL START_EDIT
	ELSE
	   IF (WAS_EDITING) THEN
	      CALL UPDATE_HEIGHTS
	      CALL FINISH_EDIT
C
C disable flooding aswell
	      FLOODING = .FALSE.
	      HAD_EDIT = .FALSE.
	      N_EDIT_PTS  = 0
	   ENDIF
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE REGISTRATION - enable the registration options.
C 
10109	DISABLE= .TRUE.	! comes here if control/z in registration mode
C
C Do not allow if curently in EDITING or DIGITISING mode
C
10110	IF (DISABLE) THEN
	   IF (.NOT.CHECK_MODE(6,'DISABLE REGISTRATION')) GOTO 10
	   CALL END_REGISTRATION
	ELSE
	   IF (.NOT.CHECK_MODE(6,'ENABLE REGISTRATION')) GOTO 10
	   IF (.NOT.(HADDTI(1).OR.HADDTI(2).OR.
     &               HADDTI(3).OR.HADDTI(4)))THEN
	     CALL WRITEF
     &       ('%S Specifying command ENABLE REGISTRATION',EBELL)
	     CALL WRITEF
     &	     ('Command requires that a DTI file is open')
	     GOTO 10
           ENDIF
	   CALL BEGIN_REGISTRATION
	ENDIF
C
	GOTO 10
C
C-----------------------------------------------------------------------
C EDIT add point to edit buffer
C
10200   IF (.NOT.CHECK_MODE(2,'EDIT'))GOTO 10
	IF (.NOT.WRITE_DTI(DTICHAN)) THEN
	   CALL WRITEF('%S Specifying command EDIT',EBELL)
	   CALL WRITEF
     &	   ('Selected DTI file is opened read-only')
	   GOTO 10
	ENDIF
	IF (.NOT.INTERPOLATING) THEN
	   JOIN = .TRUE.
	ELSE
C
C don't want to join second line to first in INTERP_EDIT
	   JOIN = ((FIRST_POS .NE. N_EDIT_PTS).OR.FIRST_INTERP)
	END IF
	IF(N_MASTER .EQ. 0) TTOPRO = .TRUE.
	CALL EDIT(JOIN)
	IF (.NOT.(AREAING .OR. INTERPOLATING .OR. FLOODING)) THEN
	   LINING = .TRUE.
	ENDIF
	GOTO 10
C-----------------------------------------------------------------------
C AREA_EDIT
C
10300	IF (.NOT.CHECK_MODE(2,'AREA_EDIT'))GOTO 10
	IF (.NOT.CHECK_MODE(3,'AREA_EDIT'))GOTO 10
	IF (.NOT.WRITE_DTI(DTICHAN)) THEN
	   CALL WRITEF('%S Specifying command AREA_EDIT',EBELL)
	   CALL WRITEF
     &	   ('Selected DTI file is opened read-only')
	   GOTO 10
	ENDIF
	AREAING = .TRUE.
	TTOPRO = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
CABANDON - also here on CTRL/Z out of edit
C redraw all pixels in original colour
10400 	IF (.NOT.CHECK_MODE(7,'ABANDON'))GOTO 10
	IF (N_EDIT_PTS .GT. 0) THEN
	   CALL REPLACE_EDIT(EDIT_COORDS(1,1),N_EDIT_PTS)
	END IF
	N_EDIT_PTS = 0
	N_MASTER = 0
	INTERPOLATING = .FALSE.
	AREAING = .FALSE.
	HAD_EDIT = .FALSE.
	FLOODING  = .FALSE.
	LINING = .FALSE.
	TTODON = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
C REMOVE - remove last point in editing
10500   IF (.NOT.CHECK_MODE(2,'REMOVE'))GOTO 10
	IF (N_MASTER .GT. 0) THEN
	   CALL ROV_REMOVE
	END IF
	GOTO 10
C-----------------------------------------------------------------------
C SMOOTH_EDIT
10600  	IF (.NOT.CHECK_MODE(2,'SMOOTH_EDIT'))GOTO 10
	IF (.NOT.CHECK_MODE(3,'SMOOTH_EDIT'))GOTO 10
	IF (.NOT.WRITE_DTI(DTICHAN)) THEN
	   CALL WRITEF('%S Specifying command SMOOTH_EDIT',EBELL)
	   CALL WRITEF
     &	   ('Selected DTI file is opened read-only')
	   GOTO 10
	ENDIF
	CALL WRITEF('Please define first line')
	INTERPOLATING  = .TRUE. 
	FIRST_INTERP = .TRUE.
	TTODON = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
C UP
10700	IF (.NOT.CHECK_MODE(2,'UP'))GOTO 10
	CALL SINGLE_MOVE(1)
	GOTO 10
C-----------------------------------------------------------------------
C DOWN
10800	IF (.NOT.CHECK_MODE(2,'DOWN'))GOTO 10
	CALL SINGLE_MOVE(2)
	GOTO 10
C-----------------------------------------------------------------------
C RIGHT
10900	IF (.NOT.CHECK_MODE(2,'RIGHT'))GOTO 10
	CALL SINGLE_MOVE(4)
	GOTO 10
C-----------------------------------------------------------------------
C LEFT
11000	IF (.NOT.CHECK_MODE(2,'LEFT'))GOTO 10
	CALL SINGLE_MOVE(3)
	GOTO 10
C
C-----------------------------------------------------------------------
C ZOOM
11100	IF (.NOT.CHECK_MODE(3,'ZOOM'))GOTO 10
	CALL ROVZOOM
	GOTO 10
C-----------------------------------------------------------------------
C RCP ADD (from mouse button )
11150	CALL RCP_COMMAND (2)
	GOTO 10

C-----------------------------------------------------------------------
C RCP ADD (from puck)
11160	CALL RCP_COMMAND (3)
	GOTO 10
C
C----------------------------------------------------------------------
C RCP
C
11200	CALL RCP_COMMAND(0)
	GOTO 10
C-----------------------------------------------------------------------
C TABLE RCP
C
11300	CMD = RDCOMM(TABLE_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S Specifying command TABLE',EBELL)
	   CALL WRITEF
     &     ('Command qualifier is RCP_FILE ')
	   GOTO 10
	ENDIF
C
	GOTO (11310) CMD
11310	CALL SELECT_RCP_FILE(.TRUE.)
	GOTO 10

C-----------------------------------------------------------------------
C Flooding from trackerball
C
11400	CALL INTER_FLOOD()
	GOTO 10
C-----------------------------------------------------------------------
C ENABLE FLOOD 
C
11500	IF (.NOT.CHECK_MODE(2,'ENABLE FLOOD'))GOTO 10
	IF (HAD_TABLE) THEN
	   FLOODING = (.NOT.FLOODING)
 	ELSE
	   FLOODING = (.NOT.DISABLE)
	ENDIF
	IF(FLOODING) THEN
	   IF (.NOT.CHECK_MODE(3,'ENABLE FLOOD'))GOTO 10
	   CALL SETUP_STATUS(CURPOS)
	   CALL INTER_FLOOD
	   HAD_EDIT = .TRUE.
	ELSE
	   HAD_EDIT = .FALSE.
	ENDIF
	TTODON = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
C UPDATE_HEIGHTS
C
11600 	IF (.NOT.CHECK_MODE(3,'RESET_MINMAX'))GOTO 10
	CALL UPDATE_HEIGHTS
	GOTO 10
C-----------------------------------------------------------------------
C MODTEN
C
11700 	IF (.NOT.CHECK_MODE(3,'MODTEN'))GOTO 10
	CALL MODTEN
	FIRST_FLOOD  = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
C UPDATE - opens files for write
C
11800	IF (.NOT.CHECK_MODE(3,'UPDATE_FILEIN'))GOTO 10
	IF (ROVFIL(.TRUE.))GOTO 10	!not read in file
	CALL UPDATE_TRANSFORMATIONS()	!set tracking-area to DTI transf
C
C Set up default step values for file read in
C default step is value range/number of colours
C
	CALL SETSTP(NOCOL(DTICHAN),.FALSE.)
	RELOOKUP = .TRUE.
	GOTO 10
C-----------------------------------------------------------------------
C SETUP 
11900	CMD = RDCOMM(SETUP_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command SETUP',EBELL)
	   CALL WRITEF('SETUP qualifier is MAP')
	   GOTO 10
	END IF
C
C               MAP	
	GOTO (  190) CMD
C
C-----------------------------------------------------------------------
C DRAW LABEL
12000	CMD = RDCOMM(DRAW_CMD_TABLE)
	IF (CMD .LE. 0) THEN
	   CALL WRITEF('%S specifying command DRAW',EBELL)
	   CALL WRITEF('DRAW qualifier is LABEL')
	   GOTO 10
	END IF
	CALL ANOTAT
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABEL LEGEND
12100	PLOT_LEG = .NOT.DISABLE
	GOTO 10
C-----------------------------------------------------------------------
C ENABLE TABLE
12110	IF (DISABLE) THEN
	   IF(TABLE)CALL CLOSE_TAB (IERR)
C set event flag numbers
	   EF_VDU = 1
	   EF_TRKB = EF_VDU+1
	   EF_FB   = EF_VDU+2
	   EF_TIMER = EF_VDU+3
C
C cancel the qio on the terminal
	   CALL SYS$CANCEL(%VAL(IN_CHAN))
	   HADQIO = .FALSE.
C
	   TABLE = .FALSE.
	ELSE
	   IF (.NOT. TABLE) THEN
	      IF (INIT_TAB(,IERR)) THEN
	         CALL WRITEF
     &	         ('%S Error initialising table monitor',WBELL)
	         CALL WRITEF
     &           ('Program will assume no table is available')
	         TABLE=.FALSE.
	         GOTO 10
	      ENDIF
	      TABLE = .TRUE.
C
C Set event flag numbers
	      CALL RETURN_EFN
     &        (EF_POINT,EF_STREAM,EF_ERROR,EF_VDU,EF_LAST)
	      EF_TRKB = EF_VDU+1
	      EF_FB   = EF_VDU+2
	      EF_TIMER = EF_VDU+3
C
C cancel the qio on the terminal
	      CALL SYS$CANCEL(%VAL(IN_CHAN))
	      HADQIO = .FALSE.
	   ENDIF
	ENDIF
	GOTO 10
C-----------------------------------------------------------------------
C ENABLE ABSOLUTE
12120	HAD_ABSOLUTE = .NOT.DISABLE
	IF(REGISTERING)THEN
          CALL CLEAR_STATUS
	  CALL SETUP_STATUS(CURPOS)
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE DIGITISING
C here if control/z in digitise mode
12190	DISABLE= .TRUE.
C
12200   IF (.NOT.CHECK_MODE(9,'ENABLE DIGITISE'))GOTO 10
	DIGITISING = .NOT.DISABLE
	IF (DIGITISING) THEN
	  IF (.NOT.TRACKING) THEN
	    CALL WRITEF('%S Specifying command ENABLE DIGITISE',EBELL)
	    CALL WRITEF
     &	    ('Command invalid without a map registered')
	    DIGITISING = .FALSE.
	  END IF
	ELSE
	  IF (PLOT_IFF) CALL CLSOUT		! close output file
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE COLOUR_MAP
12300	IF (DISABLE) THEN
	   IF (.NOT.CHECK_MODE(3,'DISABLE COLOUR_MAP'))GOTO 10
	ELSE
	   IF (.NOT.CHECK_MODE(3,'ENABLE COLOUR_MAP'))GOTO 10
	ENDIF
	IF (.NOT.DISABLE) THEN
	   IF (HAD_SAMPLE) THEN 
	      CALL WRITEF
     &        ('%S Specifying command ENABLE COLOUR_MAP',EBELL)
	      CALL WRITEF
     &	      ('Command not available while sampling')
	      GOTO 10
	   ENDIF
	ENDIF	
	COLOUR_MAP = .NOT.DISABLE
C
	IF (COLOUR_MAP) THEN
	   IF (.NOT.OPENED_COLFILE) THEN
	      CALL OPEN_COLOUR_MAP
	   ENDIF
	ELSE
	   RELOOKUP = .TRUE.
	ENDIF
	GOTO 10  
C-----------------------------------------------------------------------
C @ command
12400	CALL ROVAT
	GOTO 10
C-----------------------------------------------------------------------
C MESSAGE 
12500   CALL ROVMESS
	GOTO 10
C-----------------------------------------------------------------------
C PING
12600	CALL ROVPING
	GOTO 10
C-----------------------------------------------------------------------
C RESPOND
12700	CALL ROVRESP
	GOTO 10
C-----------------------------------------------------------------------
C CONTINUE
12800	CALL ROVCONT
	GOTO 10
C-----------------------------------------------------------------------
C ENABLE/DISABLECURSOR
12900	IF (DISABLE) THEN
	   IF (REGISTERING)THEN
	      IF(.NOT.CHECK_MODE(8,'DISABLE CROSS_CURSOR')) GOTO 10
	   ENDIF
	   IF (.NOT. CHECK_MODE(2,'DISABLE CROSS_CURSOR')) GOTO 10
	ELSE
	   IF (.NOT. CHECK_MODE(2,'ENABLE CROSS_CURSOR')) GOTO 10
	ENDIF
C
	IF (HAD_TABLE) THEN
	   DISABLE = CROSS_CURSOR
	ENDIF
C
	IF (DISABLE .NEQV. CROSS_CURSOR) GOTO 10
C
C if we are changing from black square to cross cursors then we need 
C first to fill in the previous square
	CROSS_CURSOR = .FALSE.
	CALL MOVE_CURSOR(X_CURDTI,Y_CURDTI,.FALSE.,.TRUE.)
	CROSS_CURSOR = .NOT.DISABLE
	CALL LSG_SET_CURSOR
     &        (WKID,FLOAT(XCROSS),FLOAT(YCROSS),CROSS_CURSOR)
	IF (.NOT. CROSS_CURSOR) THEN
	   CALL MOVE_CURSOR(X_CURDTI,Y_CURDTI,.TRUE.,.FALSE.)
	ENDIF
	CALL GUWK(WKID,GSUPP)
	GOTO 10
C
C-----------------------------------------------------------------------
C	OPEN command
13000	CMD = RDCOMM(OPEN_CMD_TABLE)
	IF (CMD .NE. 1) THEN
	   CALL WRITEF('%S Specifying command OPEN',EBELL)
	   CALL WRITEF('Command qualifier is RCP_FILE')
	   GOTO 10
	ENDIF
C
C	Read in the specified RCP file
	IF(.NOT.OPEN_RCP_FILE())GOTO 10
C
	GOTO 10
C-----------------------------------------------------------------------
C	OPEN command
13500	CMD = RDCOMM(CREATE_CMD_TABLE)
	IF (CMD .NE. 1) THEN
	   CALL WRITEF('%S Specifying command CREATE',EBELL)
	   CALL WRITEF('Command qualifier is RCP_FILE')
	   GOTO 10
	ENDIF
C
C	Read in the specified RCP file
	IF(.NOT.CREATE_RCP_FILE())GOTO 10
C
	GOTO 10
C-----------------------------------------------------------------------
C	ENABLE / DISABLE DEFAULT
13600	CALL RCP_ENABLE_DEFAULT (DISABLE)
	GOTO 10
C
C-----------------------------------------------------------------------
C	SET DEFAULT
13700	CALL RCP_SET_DEFAULT (DISABLE)
	GOTO 10
C
C-----------------------------------------------------------------------
C	SET DELAY - mouse movement delay in milliseconds
13800   IF (INTARG(1).LT.0.OR.CMDICT.NE. 1) THEN
	   CALL WRITEF('%S specifying command SET DELAY',EBELL)
	   CALL WRITEF('Command requires a positive integer')
	ELSE
	   BALL_WAIT= INTARG(1)
	END IF
	GOTO 10
C
C-----------------------------------------------------------------------
C	SAMPLE x and y - sub-sampling values
13900   IF(CMDICT .EQ. 0) THEN
	   CALL WRITEF('%S specifying command SAMPLE',EBELL)
	   CALL WRITEF('Command requires at least one integer argument')
	   GOTO 10
	ENDIF
	IF(CMDICT.EQ. 1) THEN
	   INTARG(2) = INTARG(1)
	ENDIF
	IF(INTARG(1).LT. 1 .OR. INTARG(1) .GT. MATSIZ(DTICHAN,1))THEN
	   CALL WRITEF('%S specifying command SAMPLE',EBELL)
	   CALL WRITEF
     &     ('X sample interval should be in the range 1 to %N',
     &     MATSIZ(1,DTICHAN))
	   GOTO 10
        ENDIF
	IF(INTARG(2).LT. 1 .OR. INTARG(2) .GT. MATSIZ(DTICHAN,2))THEN
	   CALL WRITEF('%S specifying command SAMPLE',EBELL)
	   CALL WRITEF
     &     ('Y sample interval should be in the range 1 to %N',
     &     MATSIZ(2,DTICHAN))
	   GOTO 10
	ENDIF
C
	IF (.NOT. CHECK_MODE(1,'SAMPLE')) GOTO 10
C
	IF (.NOT.(HADDTI(1).OR.HADDTI(2).OR.
     &    HADDTI(3).OR.HADDTI(4)))THEN
	  CALL WRITEF
     &    ('%S Specifying command SAMPLE',EBELL)
	  CALL WRITEF
     &	  ('Command requires that a DTI file is open')
	  GOTO 10
        ENDIF
	X_SAMPLE(DTICHAN) = INTARG(1)
	Y_SAMPLE(DTICHAN) = INTARG(2)
C
C may have to adjust sampling if too small for the current window
	CALL CHKWIN(DTICHAN)
	IF ((EDITING.OR.REGISTERING).AND.HADDTI(DTICHAN)) THEN
	   CALL DISPLY(CURPOS,DTICHAN)
	ENDIF
	GOTO 10
C
C-----------------------------------------------------------------------
C ENABLE/DISABLE SAMPLE
14000	IF (.NOT. DISABLE) THEN
	  IF (.NOT. CHECK_MODE(1,'ENABLE SAMPLE')) GOTO 10
	ENDIF
	IF(.NOT.DISABLE)THEN
	   IF (COLOUR_MAP) THEN 
	      CALL WRITEF
     &        ('%S Specifying command ENABLE SAMPLE',EBELL)
	      CALL WRITEF
     &	      ('Command not available while COLOUR_MAP is enabled')
	      GOTO 10
	   ENDIF
	ENDIF
	IF (.NOT.(HADDTI(1).OR.HADDTI(2).OR.HADDTI(3).OR.HADDTI(4)))
     &	    THEN
            CALL WRITEF('%S Specifying command SAMPLE',EBELL)
	    CALL WRITEF
     &	    ('Command requires that a DTI file is open')
	     GOTO 10
	ENDIF

	HAD_SAMPLE = (.NOT. DISABLE)
	CALL CHKWIN(DTICHAN)
	GOTO 10
C
C	
C EXIT
90000	IF (EDITING )THEN
	   CALL UPDATE_HEIGHTS
	ENDIF
C
	DO 90010 I = 1,4
	   IF (HADDTI(I)) RET = DTI_CLOSE(I,.FALSE.,.TRUE.,ERRCOD)
90010	CONTINUE
C
	IF (OPENED_COLFILE) THEN
	   CALL DTI_CLOSE(COL_LUN,.FALSE.,.FALSE.,ERRCOD)
	   RET = LIB$DELETE_FILE('LSL$DTI:ROVER.TMP;*',,,,,,,,)
	   IF(.NOT.RET) CALL LSL_PUTMSG(RET)
	ENDIF
	
C
99999	IF (OPWK) THEN
	   CALL GDAWK(WKID)
	   CALL GCLWK(WKID)
	   CALL GCLKS
	   OPWK = .FALSE.
	ENDIF
C
	CALL EXIT
	END
C
