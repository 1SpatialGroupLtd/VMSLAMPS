	LOGICAL FUNCTION LOOKUP_CMD()
C
***	MODULE	LOOKUP_CMD
***	IDENT	14JN88
C
C	Copyright (C), Laser-Scan Laboratories Ltd., Cambridge, England
C
C Created by 					ALB 15-Feb-1988
C
C Function to group and feature code information from lookup file.
C
C Function returns .TRUE. if all is well, otherwise .FALSE.
C
	IMPLICIT NONE
C
C Parameters :
	INCLUDE 'LSL$DTMCREATESYS:MESPAR.PAR'
	INCLUDE 'LSL$CMNLSL:LSLLIBMSG.PAR'	! LSL messages
	INCLUDE 'LSL$CMNLSL:READSTR.PAR'	! LSL messages
	INCLUDE 'LSL$CMNITCHECK:CONSTANTS.PAR'	! ITCHECK constants
C
C Common:
C
	INCLUDE	'LSL$CMNLSL:CMDCOM.CMN'
	INCLUDE	'LSL$CMNLSL:EXPC.CMN'
	INCLUDE	'LSL$CMNLSL:TXTC.CMN'
	INCLUDE 'LSL$CMNITCHECK:CONTROL.CMN'
	INCLUDE 'LSL$CMNITCHECK:GROUP.CMN'
	INCLUDE 'LSL$CMNITCHECK:SELECT.CMN'
C
C External
C
	EXTERNAL	GROUP_CMD_TABLE	
	INTEGER		GROUP_CMD_TABLE	
C
C W/s
	BYTE		CH		! a character
	LOGICAL		BLANK		! blank line?
	LOGICAL		OK		! for return code
	INTEGER		RET_CODE	! for error returns
	INTEGER		IERR		! for error returns
	INTEGER		CMD		! decoded command number
	INTEGER		GROUP_NUMBER	! group assigned from constants
	INTEGER		I		! loop counter
	INTEGER		NCHAR		! number of characters in string
	CHARACTER*24	OUT_STR		! group name from lookup file
C
C Functions
C
	LOGICAL		GETFILNAM	! get file-spec
	LOGICAL		FLRCLO		! close lookup file
	LOGICAL		FLRLIN		! read a record from a opened file
	LOGICAL		FLROPN		! open lookup file
	LOGICAL		INITSEL		! initialise bit map for group
	LOGICAL		READSTR		! read string from input buffer
	LOGICAL		RDCHS		! read char. skipping spaces
	LOGICAL		RDCOMM		! parse command against command table
	LOGICAL		TTRSTR		! read from TT:
C
C ......................................................................
C
	LOOKUP_CMD=.TRUE.		! assume success
C
C ......................................................................
C
C Look for filename, taking appropriate action if none found
C
	BLANK=RDCHS(CH)			! empty line ...
	IF (BLANK.OR.CH.EQ.'!') THEN	! or comment?
C
C Display warning/error for no filename present
C
	   IF (TTIN) THEN
	      CALL WRITEF('%S Specifying command LOOKUP',WARNING)
	      CALL WRITEF('You must specify a file-spec argument'//
     &		' to the LOOKUP command')
	   ELSE
	      CALL WRITEF('%S Specifying command LOOKUP',ERROR)
	      CALL WRITEF('You must specify a file-spec argument'//
     &		'to the LOOKUP command')
	   ENDIF	   
C
C If terminal input, prompt for filename
C
	   IF (TTIN) THEN
	      CALL WRITEF('For example LOOKUP ITCHECK2.DAT')
	      RET_CODE=TTRSTR(,,'Read from which lookup file? ',IERR)
C
C Deal any errors
C
	      IF(RET_CODE.NE.LSL__NORMAL) THEN		! problem with input
	         CALL LSL_PUTMSG(RET_CODE)		
	         IF(RET_CODE.EQ.LSL__SYSERR) THEN	! system error
	            CALL LSL_ADDMSG(IERR) 
		 ENDIF
	         LOOKUP_CMD=.FALSE.
	         GOTO 999
	      ENDIF
	      CALL BSLN				! reset decode ptr 		
	      IF (TXTPTR.EQ.0) THEN
	   	 LOOKUP_CMD=.FALSE.
		 GOTO 999			! empty line
	      ENDIF
	   ELSE
	      LOOKUP_CMD=.FALSE.
	      GOTO 999  ! someone got their indirect file wrong !!
	   ENDIF
	ENDIF
C
C ......................................................................
C
C Try interpreting the file-spec
C
	CALL BSCH					! move back one chr
	RET_CODE=  GETFILNAM(	LOOKUP_FNAME,		! filename
     &			LOOKUP_LEN,			! filename length
     &			'LSL$LOOKUP:ITCHECK.DAT;0',	! default
     &			.TRUE.,				! allow version numbers
     &			%REF('!') )			! termination character
C
C Deal with any error in interpreting file-spec
C
	IF (RET_CODE.NE.LSL__NORMAL) THEN
	   CALL WRITEF('%S Specifying command LOOKUP',ERROR)
	   CALL WRITEF('Unable to interpret input file-spec')
	   CALL LSL_PUTMSG(OK)
	   LOOKUP_CMD=.FALSE.
	   GOTO 999
	ENDIF
C
C ......................................................................
C
C attempt to open the Lookup file (readonly)
C
	RET_CODE = FLROPN(LOOKUP_LUN,LOOKUP_FNAME,IERR)
C
C Deal with any error in opening lookup file
C
	IF (RET_CODE.NE.LSL__NORMAL) THEN	! error occurred
	   CALL WRITEF('%S Specifying command LOOKUP',ERROR)
	   CALL WRITEF('Unable to open file %S',
     &		LOOKUP_FNAME(:LOOKUP_LEN))
	   CALL LSL_PUTMSG(RET_CODE)
	   IF(RET_CODE.EQ.LSL__SYSOPEN) THEN	! system error
	      CALL LSL_ADDMSG(IERR) 
	   ENDIF
	   LOOKUP_CMD=.FALSE.
	   GOTO 999
	ENDIF
C
C read records from opened lookup file
C
	HAD_RESET = .FALSE.			! to reset bit maps
10	CONTINUE
	RET_CODE = FLRLIN(,,,IERR)
	IF(RET_CODE.EQ.LSL__EOF) GOTO 800	! EOF found
C
C Deal with any error reading lookup file
C
	IF (RET_CODE.NE.LSL__NORMAL) THEN	! error occurred
	   CALL WRITEF('%S Specifying command LOOKUP',ERROR)
	   CALL WRITEF('While reading file %S',
     &	   LOOKUP_FNAME(:LOOKUP_LEN))
	   CALL LSL_PUTMSG(RET_CODE)
	   IF(RET_CODE.EQ.LSL__SYSREAD) THEN	! system error
	      CALL LSL_ADDMSG(IERR) 
	   ENDIF
	   LOOKUP_CMD=.FALSE.
	   GOTO 998
	ENDIF
C
	CALL BSLN			! position at start of line
C
	IF(RDCHS(CH)) GOTO 10 	! empty line
	IF(CH.EQ.'!') GOTO 10	! comment
C
	CALL BSCH			! backspace one character
C
C now validate groups in lookup file
C
	CMD=RDCOMM(GROUP_CMD_TABLE)
C
	GOTO(	100,			! a unrecognised group
     &		110,			! cliffs
     &		120,			! coastlines	
     &		140,			! contours
     &		160,			! index_contours
     &		180,			! lakes
     &		200,			! ridge_lines
     &		220,			! rivers
     &		240,			! spot_heights
     &		260			! supplementary_contours
     &					), CMD+1
C
C group validation not yet implimented
C
	CALL WRITEF('%S Group validation not yet implimented',
     & 	WARNING)
	GOTO 10
C
C unrecognised group
C
100	CONTINUE
	CALL BSLN
	NCHAR = READSTR(OUT_STR,,ON_EOL)
	CALL WRITEF('%S Unrecognised group name %S',
     & 	WARNING,OUT_STR(:NCHAR))
	GOTO 10
C
C cliffs
C
110	CONTINUE
	GROUP_NUMBER = CLIFF
	GOTO 500
C
C coastlines
C
120	CONTINUE
	GROUP_NUMBER = COAST
	GOTO 500
C
C contours
C
140	CONTINUE
	GROUP_NUMBER = CONTOUR
	GOTO 500
C
C index contours
C
160	CONTINUE
	GROUP_NUMBER = INDEX_C
	GOTO 500
C
C lakes
C
180	CONTINUE
	GROUP_NUMBER = LAKE
	GOTO 500
C
C rigde lines
C
200	CONTINUE
	GROUP_NUMBER = RIDGE
	GOTO 500
C
C rivers
C
220	CONTINUE
	GROUP_NUMBER = RIVER
	GOTO 500
C
C spot heights
C
240	CONTINUE
	GROUP_NUMBER = SPOT
	GOTO 500
C
C supplementary contours
C
260	CONTINUE
	GROUP_NUMBER = SUPPLEMENTARY
	GOTO 500
C
C got group number now prepare to initialise or update group bit map
C
500	CONTINUE
	IF(RDCHS(CH)) THEN		! No feature with lookup group name
	   CALL BSLN
	   NCHAR = READSTR(OUT_STR,,ON_EOL)
	   CALL WRITEF('%S No feature codes with group name %S',
     & 	   WARNING,OUT_STR(:NCHAR))
	   GOTO 10
	ENDIF
C
C set bitmap for group
C
C
	CALL BSCH			! backspace one character
	OK = INITSEL(GROUP_NUMBER)
	IF(.NOT.OK) THEN
	   LOOKUP_CMD = .FALSE.
	   GOTO 998
	ENDIF
C
C move group bit map into feature code bit map
C
	DO 710 I = 1,FCMAX
	   FCMAP(I) = FCMAP(I) .OR. GRPFCT(I,GROUP_NUMBER)
710	CONTINUE
	GOTO 10
C
800	CONTINUE				! EOF label (normal exit)
998	CONTINUE				! abnormal exit (close file)
C
C close LOOKUP file
C
	RET_CODE = FLRCLO(LOOKUP_LUN,IERR)
C
C Deal with any error in closing lookup file
C
	IF (RET_CODE.NE.LSL__NORMAL) THEN	! error occurred
	   CALL WRITEF('%S Specifying command LOOKUP',ERROR)
	   CALL WRITEF('Unable to close file %S',
     &		LOOKUP_FNAME(:LOOKUP_LEN))
	   CALL LSL_PUTMSG(RET_CODE)
	   IF(RET_CODE.EQ.LSL__SYSCLOSE) THEN	! system error
	      CALL LSL_ADDMSG(IERR) 
	   ENDIF
	   LOOKUP_CMD=.FALSE.
	   GOTO 999
	ENDIF
	HAD_LOOKUP = .TRUE.			! lookup done (remember)
999	CONTINUE				! abnormal exit 
C
	RETURN
	END
