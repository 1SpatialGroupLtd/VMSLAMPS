	INTEGER FUNCTION EXPLOIT_SECTORS(COORDS)
C
**	MODULE	EXPLOIT_SECTORS
**	IDENT	11MR92
C
C Copyright Laser-Scan Labs., Ltd., Cambridge, England.
C
C Author J.H.Rees
C
C	Part of the IFF-to-Raster conversion program
C
C	 - takes the sector-list and rasterises the features, swathe-by-swathe.
C
	IMPLICIT NONE
C
***	PARAMETER/LSL$CMNLSL:LSLLIBMSG/
***	PARAMETER/CMN:PRIM2RASTERMSG/
***	COMMON/LSL$CMNIFF:IFFHAN/
***	COMMON/CMN:CLIP/
***	COMMON/CMN:COORD/
***	COMMON/CMN:PRIM2RASTER/
***	COMMON/CMN:RASBUF/
C
C Functions:
	INTEGER		OUTPUT_SWATHE		! handles the outputting of
						!  complete swathes.
	LOGICAL		IFF_COORDS		! IFFLIB function
	INTEGER*4	SYS$EXPREG
C
C arguments:
	REAL*4		COORDS(2,*)
C
C w/s:
	INTEGER		I, K			! DO-loop counters.
	INTEGER		ST_PTS			! No of coords in current ST.
	INTEGER		IENDS			! bit-pattern.
	REAL		COORD1(2)		! first point of feature
	REAL		WIDTH			! with in pixels
	REAL		Y_MIN,Y_MAX		! extent of a feature.
	REAL		XY(2,5)			! thick line buffer
	REAL		DX,DY,R
	INTEGER*4	F_PTR,LAST_PTR
	INTEGER*2	F_WORD(2)
	BYTE		F_BYTE(2)
	EQUIVALENCE	(F_WORD,F_BYTE)
	LOGICAL		AREA
	INTEGER*4	F_ST			! ST pointer
	LOGICAL		DONE
	INTEGER		NATT
	INTEGER		NCOORD
	INTEGER		LINES			! no. of lines in swathe
	INTEGER*4	RETADR(2)
	INTEGER		CAP,JOIN		! cap/join styles
	LOGICAL		CLOSED
C
	EXPLOIT_SECTORS = LSL__NORMAL		! assume success.
C
	IF (CHECK.AND.LOGGING) THEN
	  CALL WRITEF('First pass, calculating buffer size...')
	ENDIF
C
10	IF (LOGGING) THEN
	  CALL WRITEF('Starting to rasterise the swathes...')
	ENDIF
C
C set-up the 1st swathe-window to clip the features to. (all in pixel-space)
C The first swathe may not be a complete one
C
	CLIPLO = (MAX_SWATHE-1) * LINES_PER_SWATHE
	CLIPHI = COLUMN_END-1
C
	RCLIPLO = (CLIPLO-0.5)*RESOLUTION
	RCLIPHI = (CLIPHI+1.5)*RESOLUTION
C
	LINES = CLIPHI-CLIPLO+1
C
C loop through all the swathes - we limit ourselves between the swathes that
C we know have features crossing them.
C	
	DO 100 I = MAX_SWATHE, 1, -1
C
C get pointer to first and last feature for sector
	  CALL PUTLNG(%VAL(FIRST_ADR+4*(I-1)),F_PTR)
	  IF (F_PTR.EQ.0) GOTO 210		! no features in this swathe
	  CALL PUTLNG(%VAL(LAST_ADR+4*(I-1)),LAST_PTR)
C
C If we have reached the end of the sector, then swathe is finished,
C otherwise if at the end of a block, get the address of next block
110	  IF (F_PTR.EQ.LAST_PTR) GOTO 210	! done all features
	  IF ((F_PTR.AND.511).EQ.504) CALL PUTLNG(%VAL(F_PTR),F_PTR)

C...we've now got a feature that cuts this swathe;
C...go through it, line-by-line, clipping to the current swathe, and
C...rastering it.

	  CALL PUTLNG(%VAL(F_PTR),F_ST)			! get ST pointer
	  F_PTR = F_PTR+4				! step to next item
	  CALL PUTLNG(%VAL(F_PTR),F_WORD)		! get data
C
C translate the colour index into the output colour
	  CLOSED = .FALSE.
	  V_VALUE = F_WORD(1).AND.255	! IFF colour index
	  CAP = F_BYTE(2)	! this byte is CAP + 10*JOIN - 128 if closed
	  IF (CAP.LT.0) THEN
	    CLOSED = .TRUE.
	    CAP = CAP+128
	  ENDIF
	  JOIN = CAP/10
	  CAP = CAP-JOIN*10
	  IF (V_VALUE.EQ.MASK) THEN	! change MASK to BACKGROUND
	    V_VALUE = BACKGROUND
	  ELSEIF (BINARY) THEN		! anything else to foreground
	    V_VALUE = FOREGROUND
	  ENDIF
	  AREA = .FALSE.
	  IF (F_WORD(2).LT.0) THEN
	    AREA = .TRUE.
	  ELSE
	    WIDTH = FLOAT(F_WORD(2))/1000.0
	    IF (WIDTH.LT.RESOLUTION) WIDTH = RESOLUTION	! minimum thickness
	  ENDIF
	  F_PTR = F_PTR+4				! step to next feature
	  NCOORD = 0					! no coords yet
	  IF (.NOT.AREA) CALL BEGIN_LINE(CLOSED,WIDTH,CAP,JOIN)

C...go on to next entry
C...deal with ST entry/entries for this feature.
120	  DONE = IFF_COORDS(F_ST,ST_PTS,IENDS,COORDS(1,NCOORD+1),NATT,0,0)
C
C... get coordinates into sector range
	  DO 300 K = 1, ST_PTS
	    COORDS(1,NCOORD+K) = COORDS(1,NCOORD+K) - RANGE(1)
	    COORDS(2,NCOORD+K) = COORDS(2,NCOORD+K) - RANGE(3)
300	  CONTINUE
C
	  IF (.NOT.AREA) THEN
	    DO 400 K = 1, ST_PTS
	      CALL ADD_POINT(COORDS(1,K))
400	    CONTINUE
C
C finish off line feature
	    IF (DONE) CALL END_LINE
	  ELSE
	    NCOORD = NCOORD + ST_PTS		! update counter for area
	  ENDIF
	  IF (.NOT.DONE) GOTO 120			! and go on to next
	  IF (.NOT.AREA) GOTO 110			! back for next feature

C here with complete area feature to plot
C ensure area closed
	  IF ( COORDS(1,1).NE.COORDS(1,NCOORD) .OR.
     &	       COORDS(2,1).NE.COORDS(2,NCOORD) ) THEN
	    NCOORD = NCOORD+1
	    COORDS(1,NCOORD) = COORDS(1,1)
	    COORDS(2,NCOORD) = COORDS(2,1)
	  ENDIF
	  CALL FILL_SIDE(NCOORD,COORDS,%VAL(SIDES_ADR),%VAL(SIDPTR_ADR),
     &				GFASCT,%VAL(INTSCT_ADR),%VAL(INTPTS_ADR))
	  GOTO 110			! back for next feature
C
C...output this swathe.

210	  EXPLOIT_SECTORS = OUTPUT_SWATHE(LINES)
	  IF ( .NOT. EXPLOIT_SECTORS ) GOTO 999	! error
	  IF ( LOGGING ) CALL WRITEF(
     &	'Finished swathe %I of %I',MAX_SWATHE-I+1,MAX_SWATHE)
C
C...move the clipping window down to the next swathe
C...all but the first swathe are whole ones
	  CLIPHI = CLIPLO - 1
	  CLIPLO = CLIPLO - LINES_PER_SWATHE
	  RCLIPLO = (CLIPLO-0.5)*RESOLUTION
	  RCLIPHI = (CLIPHI+1.5)*RESOLUTION
	  LINES = LINES_PER_SWATHE
100	CONTINUE
C
C if checking tape blocksize, then allocate buffer and make second pass
	IF (CHECK) THEN
	  CHECK = .FALSE.
	  IF (LOGGING) CALL WRITEF(
     &		'Allocating %N byte output buffer',BLOCKSIZE)
	  EXPLOIT_SECTORS = SYS$EXPREG(%VAL((BLOCKSIZE-1)/512+1),RETADR,,)
	  IF (.NOT.EXPLOIT_SECTORS) THEN
	    CALL LSL_PUTMSG(P2R__NOMEM)
	    GOTO 999
	  ENDIF
	  TAPE_BUFF_ADR = RETADR(1)
	  IF (LOGGING) CALL WRITEF('Second pass, writing data...')
	  GOTO 10
	ENDIF
C
999	RETURN
	END
