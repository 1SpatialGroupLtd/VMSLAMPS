	.TITLE	TKBS
	.IDENT	/28MR82/
 
 
; Copyright Laser-Scan Laboratories Ltd., Cambridge, England
; Author Susan Manning, from originals by R. Fairbairns,
;		from originals by P.A.Woodsford, P.Cross, et al.
 
; date as .IDENT
 
; B a s i c   T e k t r o n i x   4 0 1 x
;         g r a p h i c    l i b r a r y     s u p p o r t
 
; Conditional assembly by variable C4014; non-0 if supporting 4014 with
;   enhanced graphics, or a 4016
 
 
	CODE_PSECT	TKW

; P r i m i t i v e    l i n e - d r a w i n g   e n t r i e s
 
; i n c r e m e n t a l
 
; null move
 
 .ENTRY		MOVB00,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
$MOV00::			; for historical reasons
	BSBB	$MOVB0
	RET
 
; move by
 
 .ENTRY		MOVBY,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVF	@4(AP),R7
	MOVF	@8(AP),R9
	BSBB	$MOVBY
	RET
 
; line by
 
 .ENTRY		LINBY,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVF	@4(AP),R7
	MOVF	@8(AP),R9
$LINBY:: MOVW	#1,R10
	BSBB	MLBY
	RET
 
 
; a b s o l u t e
 
; move to
 
 .ENTRY		MOVTO,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVF	@4(AP),R7
	MOVF	@8(AP),R9
	BSBB	$MOVTO
	RET
 
; line to
 
 .ENTRY		LINTO,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVF	@4(AP),R7
	MOVF	@8(AP),R9
$LINTO:: MOVW	#1,R10
	BSBB	MLTO
	RET
 
$MOVB0:: CLRF	R7
	CLRF	R9
$MOVBY:: CLRW	R10
MLBY::	TSTW	$DIVRF		; in refresh?
	BEQL	10$
	JSB	$RFBY		; yes - divert
	BRB	20$
10$:	BSBB	LBGEN
20$:	RSB
 
 
$MOVTO:: CLRW	R10
MLTO::	TSTW	$DIVRF		; in refresh?
	BEQL	10$
	JSB	$RFTO		; yes - divert
	BRB	20$
10$:	BSBB	LTGEN
20$:	RSB
 
 
; form endpoint in user space
LBGEN::	ADDF2	TKRUX,R7
	ADDF2	TKRUY,R9
 
; establish line drawing position
LTGEN::	BSBB	LR1EST
	MOVF	R7,TKRUX
	MOVF	R9,TKRUY
JL:	ADDF2	TKRUOX,R7
	ADDF2	TKRUOY,R9
	BSBB	TKTRMT		; transform endpoint
	JSB	$TKMOV
	RSB
 
 
; TKTRMU performs linear transformation of [R7,R9] by matrix pointed
;   to by R1. Result in [R6,R8]
 
TKTRMT:	MOVAW	TKTR,R1		; standard matrix entry
TKTRMU:	MOVF	R7,R8		; preserve X
	MOVF	R9,R6		; preserve Y
	MULF2	(R1)+,R7	; (1,1) * X
	MULF2	(R1)+,R6	; (1,2) * Y
	ADDF2	R7,R6		; X result
	MULF2	(R1)+,R8	; (2,1) * X
	MULF2	(R1)+,R9	; (2,2) * Y
	ADDF2	R9,R8		; Y result
	RSB
 
 
; establish at line-drawing position, and then divert for thick, etc.,
;  if required
 
LR1EST:	TSTW	TKLNCH		; have we been drawing chars?
	BEQL 	$IFTHK
	PUSHL	R7		; preserve where we
	PUSHL	R9		;   were going to
	MOVL	R10,-(SP)	;   and how
	CLRW	TKLNCH		; clear recursive loop
	BSBW	$MOVB0		; move back to last line-drawing position
	MOVL	(SP)+,R10	; recover
	MOVF	(SP)+,R9
	MOVF	(SP)+,R7
$IFTHK:: BBS	#FLAG_V_IFTHK,FLAGW,THKDO	
	RSB
 
; go to THKDO with R10 = visibility and endpoint
;  in TKRUX, TKRUY
 
THKDO:	BBC	#FLAG_V_THKD,FLAGW,TKTHKJ			
	JMP	T.DDC
TKTHKJ:	BRB THKDO
 
 
; return beam to origin and wait until all drawing done
 
 .ENTRY		LDCMPL,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
$LDCMP:: JSB	$MOVT0		; go to origin
	BRB 	$LDWAIT
 
; wait until outstanding moves completed
 
 
 .ENTRY		LDWAIT,^M<R2,R4,R5,R6,R7,R8,R9,R10,R11>
$LDWAIT:: BSBW	$MOVB0		; generate extra idle
	JSB	$FLUSH		; flush out buffer
	JSB	$WBUFF		; join 'wait buffer completion'
	RET
 
 
; C h a r a c t e r    ' d r a w i n g '
 
 
; basic 'print' character
 
				; this is the best we can do
PLTCHR::			; can't be implemented as for HRD:
 .ENTRY		PRTCHR,^M<R2,R5,R6,R7,R9,R10,R11>
$PRTCH:: MOVZBL @4(AP),R6	; character
	BSBB	PRTR1
	RET
 
 
PRTR1:	BICB2	#^O200,R6	; clear junk
	CMPB	R6,#^O40	; control char ?
	BGEQ	1$		; no
	CMPB	R6,#AS.LF	; line feed ?
	BEQL	1$		; allowed
	CMPB	R6,#AS.CR	; carriage return ?
	BNEQ	CHRTS		; nothing else allowed (not even or in refresh)
1$:	TSTW	$DIVRF		; in refresh?
	BEQL	CHGEN
	JSB	$RFCH		; yes - divert
	BRB	CHRTS
 
; generate character R1
CHGEN::	TSTW	TKLNCH		; already drawing characters
	BNEQ	3$		; yes
	PUSHR	#^M<R6>		; save reg mangled by T.FLSH
	JSB	T.FLSH		; ensure at correct position
	POPR	#^M<R6>		; recover reg
	JSB	$TKW2C		; get out of graphic mode
	.BYTE	AS.US,0
3$:	MOVB	R6,R10		; character to where its needed
	JSB	$TKWCH		; transmit character
	INCW	TKLNCH		; count characters transmitted
CHRTS:	RSB
 
 
; string of characters, zero terminated
 
 .ENTRY		CHARZ,^M<R2,R5,R6,R7,R9,R10,R11>
	MOVL	4(AP),R2	; string pointer
1$:	MOVZBL	(R2)+,R6	; next character of string
	BEQL	2$		; nul => end
	PUSHR	#^M<R2>		; save register flattened by PRTCHR
	BSBB	PRTR1		; output character
	POPR	#^M<R2>		; recover register
	BRB	1$
2$:	RET
 
 
; counted string of charcters

.ENTRY	CHARC,^M<R2,R3,R5,R6,R7,R9,R10,R11>
	MOVL	4(AP),R2	; string pointer
	MOVZBL	(R2)+,R3	; character count
	BEQL	CH2		; if zero, none to output
CH1:	MOVZBL	(R2)+,R6	; next character of string
	PUSHR	#^M<R2,R3>	; save registers flattened by PRTCHR
	BSBB	PRTR1		; output character
	POPR	#^M<R2,R3>	; recover registers
	SOBGTR	R3,CH1		; next character if present
CH2:	RET



; string of characters passed by descriptor

.ENTRY	CHARS,^M<R2,R3,R5,R6,R7,R9,R10,R11>
	MOVL	4(AP),R2	; descriptor address
	MOVZWL	(R2),R3		; length of string
	BEQL	CH2		; if zero, none to output
	MOVL	4(R2),R2	; address of string
	BRB	CH1		; join common code


	.PSECT
	.END
