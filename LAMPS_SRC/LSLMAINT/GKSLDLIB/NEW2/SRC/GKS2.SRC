C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1992-03-26 13:21:58.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
C 	CONTROL FUNCTIONS
C	=================
C
	SUBROUTINE	GOPKS(ERRFIL)
C
**	MODULE	GOPKS
**	IDENT	26MR92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
	IMPLICIT NONE
C
	EXTERNAL GKSBLK		! ensure that block data is linked in
C
C OPEN GKS - includes initialising of data structures and variables
C
C Arguments:
	INTEGER	ERRFIL			! error message file
C
C
***	COMMON/GKSDAT2/			! GKS data structures
***	COMMON/GKSESL/			! GKS error state list
C
C Set up initial indices and  default modes
	GKSERR 	= 0		! no errors yet
	TRNCUR	= 1		! use normalisation transformation 0
	PLIND	= 1		! use polyline bundle table 1
	ENCLIP	= .TRUE.	! enable clipping
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GCLKS
C
**	MODULE	GCLKS
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C CLOSE GKS	
C
	IMPLICIT NONE
C
***	COMMON/GKSESL/
C
	GKSERR	= 0				! no errors
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GOPWK(WKID,CONID,WTYPE)
C
**	MODULE	GOPWK
**	IDENT	30NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C Add UPFA setting				TJI	30-Nov-1984
C
C OPEN WORKSTATION   - sets up World Coordinates and Normalised Device
C			  Coordinates to be 1 metre on the film with
C			  the origin at the bottom left hand corner
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	CONID			! connection-identifier
	INTEGER	WTYPE			! workstation type
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
***	COMMON/THKPAR/			! LDLIB common block
C
C Local variables
	INTEGER	DEV,I
	REAL NULL
C
	GKSERR	= 0			! no errors
C
C which workstation type is it
	DO 10 I=1,TYPNUM
	   IF (WTYPE.EQ.WTYPES(I,1)) THEN
	      DEV = WTYPES(I,2)
	      GOTO 20
	   ENDIF
10	CONTINUE
C
	GKSERR = 23		! trap unknown type
	GOTO 999
C
C set workstation identifier in appropriate slot
20	WKIDS(DEV) = WKID
	DEFER(DEV) = GASTI	! deferral mode is At Some TIme
	REGEN(DEV) = GSUPPD	! implicit regeneration suppressed
	UPTRN(DEV) = .TRUE.	! update transformation
	UPLIN(DEV) = .TRUE.	! update polyline attributes
	UPFA(DEV)  = .TRUE.	! update fill area attributes
	UPTX(DEV)  = .TRUE.	! update text attributes
C
	CCOLI(DEV) = -1		! ensure colour set first time round
	CLWID(DEV) = 0.0	! and linewidth
C
	IF ( DEV.EQ.GTEK ) THEN
C
C	 LDLIB (or WOSPLIB etc. device)
C
	   CALL LDINIT(INIARG(DEV),CONID,WTYPE)
C
C	 Make sure that MSPOT and MSEP in common /THKPAR/ have non-zero
C	 values (they should have been set by LDLIB)
C	 If preset, MSPOT is the line thickness and MSEP is the line
C	 separation to give solid fill in device units (cm, mm, or what-
C	 ever, according to DCUNIT). If unset, then we set them to be
C	 0.0001 metres
	   IF (MSPOT.LE.0.0) MSPOT = DCUNIT(DEV)*0.0001
	   IF (MSEP .LE.0.0) MSEP  = MSPOT
C
C	 Get the size of the available film area in device units.
C	 Device units are considered to be mms, so if they are,
C	 for example, cms (such as on the BENSON plotter) then the
C	 plot will be 10 times too large
C
	   CALL LDFPPM(4,NULL,DCMAXX(DEV),DCMAXY(DEV))
	   RASTX(DEV) = 32000
	   RASTY(DEV) = 32000
C
C	 use -1 version of ORIGIN (device units), this is what
C	 WOSPLIB does
C
	   CALL ORIGIN(-DCMAXX(DEV)/2,-DCMAXY(DEV)/2,-1)
	   CALL UNITS(DCUNIT(DEV))
C
	   GNOMLW(DEV)  = MSPOT
	   GNOMSEP(DEV) = MSEP
C
	ELSE
C
C	 VSLIB device
C
	   CALL VSINIT(INIARG(DEV))
	   CALL VSSIZE(DCMAXX(DEV),DCMAXY(DEV))
	   RASTX(DEV) = 1024
	   RASTY(DEV) = 1024
	   CALL VSORGN(-DCMAXX(DEV)/2,-DCMAXY(DEV)/2)
	   CALL VSUNIT(DCUNIT(DEV))
	   CALL VSDEF(1,8,0)
C
C	    choose the lesser linewidth (for safety)
C
	   GNOMLW(DEV)  = MIN( DCMAXX(DEV)/1024,
     &			       DCMAXY(DEV)/1024 )
	   GNOMSEP(DEV) = GNOMLW(DEV)
C
	ENDIF
C
C Convert to metres
	DCMAXX(DEV) = DCMAXX(DEV)/DCUNIT(DEV)
	DCMAXY(DEV) = DCMAXY(DEV)/DCUNIT(DEV)
	GNOMLW(DEV) = GNOMLW(DEV)/DCUNIT(DEV)
	GNOMSEP(DEV) = GNOMSEP(DEV)/DCUNIT(DEV)
C
C Set workstation viewport to entire area
	CALL GSWKVP(WKID,0.0,DCMAXX(DEV),0.0,DCMAXY(DEV))
C
999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GCLWK(WKID)
C
**	MODULE	GCLWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C CLOSE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.EQ.0) THEN
	   IF (DEV.EQ.GTEK) THEN
	      CALL LDINIT(0)
	   ELSE
	      CALL VSINIT(0)
	   ENDIF
	   WKIDS(DEV) = -1
	ENDIF
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GACWK(WKID)
C
**	MODULE	GACWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C ACTIVATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.EQ.0) WSACT(DEV) = .TRUE.
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GDAWK(WKID)
C
**	MODULE	GDAWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C DEACTIVATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.EQ.0) WSACT(DEV) = .FALSE.
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GCLRWK(WKID,COFL)
C
**	MODULE	GCLRWK
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	14-Nov-1983
C
C CLEAR WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER COFL			! control flag
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (DEV.EQ.GTEK) THEN
	   CALL LDWAIT			! execute all deferred actions
	   IF (PC(DEV)) THEN
	      CALL PCFRAM(1.0)
	   ELSE
	      CALL DIFRAM(1)
	   ENDIF
	ELSE
	   CALL VSDEF(1,8,0)		! picture 1 all 8 planes
	   CALL VSCLR(1)		! clear it
	   CALL LSG_PLANE_SELECT(WKID,PSEL(DEV)) ! restore picture 1
	ENDIF
C
9999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GUWK(WKID,REGFL)
C
**	MODULE	GUWK
**	IDENT	16MY84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	16-May-1984
C
C UPDATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	REGFL			! regeneration flag
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (DEV.EQ.GTEK) THEN
	   CALL LDWAIT
	ELSE
	   CALL VSGEN
	ENDIF
C
9999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSDS(WKID,DEFMOD,REGMOD)
C
**	MODULE	GSDS
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET DEFERRAL STATE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	DEFMOD			! deferral mode
	INTEGER	REGMOD			! implicit regeneration mode
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF ( DEFMOD.LT.GASAP .OR. DEFMOD.GT.GASTI ) GOTO 10
	   DEFER(DEV) = DEFMOD
C	 nasty call to GUWK (second argument ignored)
	   IF (DEFER(DEV).EQ.GASAP.AND.WSACT(DEV)) CALL GUWK(WKID,0)
C
10	IF ( REGMOD.LT.GSUPPD .OR. REGMOD.GT.GALLOW) GOTO 9999
	   REGEN(DEV)= REGMOD
C
9999	RETURN
	END
C
C**********************************************************************
C
C	OUTPUT FUNCTIONS
C	================
C
	SUBROUTINE	GPL(N,PX,PY)
C
**	MODULE	GPL
**	IDENT	28OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C POLYLINE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER N			! number of points
	REAL	PX(N)			! X coords of points in WC
	REAL	PY(N)			! Y coords of points in WC
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Functions:
	LOGICAL	GKCLIP			! clips a straight line to
					! rectangular boundaries
C
C Internal variables:
	INTEGER	I			! loop variable
	REAL	PX1,PX2,PY1,PY2		! X and Y coordinates
	REAL	CURX,CURY		! current position
	INTEGER	DEV
C
	GKSERR	= 0
C
	IF (N.LT.2) THEN
	   GKSERR = 100
	   GOTO 9999
	ENDIF
C
	DO 100 DEV=1,WSMAX
C
C Is this workstation active?
	   IF (.NOT.WSACT(DEV)) GOTO 100
C
C Make sure transformation is up to date
	   IF (UPTRN(DEV)) CALL GUPTRN(DEV)
C
C Is everything clipped ?
	   IF (CLPALL(DEV)) GOTO 100
C
C Make sure polyline attributes are up to date
	   IF (UPLIN(DEV)) CALL GUPLIN(DEV)
C
C unset current position to force move
	   CURX = 1E38
	   CURY = 1E38
C
C Loop for each segment of this polyline.
	   DO 90 I = 1, N-1
	      PX1 = PX(I)
	      PY1 = PY(I)
	      PX2 = PX(I+1)
	      PY2 = PY(I+1)
	      IF (ENCLIP) THEN
	         IF (GKCLIP(DEV,PX1,PY1,PX2,PY2)) GOTO 90
	      ENDIF
C transform World Coordinates to Workstation Device Coordinates
	      PX1 = (PX1*SCALEX(DEV))+OFFX(DEV)
	      PX2 = (PX2*SCALEX(DEV))+OFFX(DEV)
	      PY1 = (PY1*SCALEY(DEV))+OFFY(DEV)
	      PY2 = (PY2*SCALEY(DEV))+OFFY(DEV)
	      IF (DEV.EQ.GTEK) THEN
	         IF (PX1.NE.CURX.OR.PY1.NE.CURY) CALL MOVTO(PX1,PY1)
	         CALL LINTO(PX2,PY2)
	      ELSE
	         IF (PX1.NE.CURX.OR.PY1.NE.CURY) CALL VSMTO(PX1,PY1)
	         CALL VSLTO(PX2,PY2)
	      ENDIF
	      CURX = PX2		! update current position
	      CURY = PY2
90	   CONTINUE
C
	   IF (DEFER(DEV) .EQ. GASAP) THEN
	      IF (DEV.EQ.GTEK) THEN
	         CALL LDWAIT
	      ELSE
	         CALL VSGEN
	      ENDIF
	   ENDIF
100	CONTINUE
C
9999	RETURN
	END
C
C**********************************************************************
C
C	OUTPUT ATTRIBUTES
C	=================
C			(Workstation independent primitive attributes)
C
C
	SUBROUTINE	GSPLI(INDEX)
C
**	MODULE	GSPLI
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET POLYLINE INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	INDEX			! polyline index
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER	I
C
	GKSERR	= 0			! no errors yet
	IF (INDEX.LT.1.OR.INDEX.GT.PLMAX) THEN
	   GKSERR = 60			! polyline index is invalid
	ELSEIF (INDEX.NE.PLIND) THEN
	   PLIND = INDEX		! set it to current index
	   DO 20 I=1,WSMAX
	      UPLIN(I) = .TRUE.		! attributes need updating
20	   CONTINUE
	ENDIF
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSLN(LTYPE)
C
**	MODULE	GSLN
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET LINETYPE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	LTYPE			! linetype
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER	I
C
	GKSERR = 0
	IF (LTYPE.LE.0) THEN
	   GKSERR = 62			! linetype .LE. 0
	ELSE
	   ILTYPE = LTYPE
	   DO 20 I=1,WSMAX
	      UPLIN(I) = .TRUE.		! attributes need updating
20	   CONTINUE
	ENDIF
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSLWSC(LWIDTH)
C
**	MODULE	GSLWSC
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET LINEWIDTH SCALE FACTOR
C
	IMPLICIT NONE
C
C Arguments:
	REAL	LWIDTH			! linewidth scale factor
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER I
C
	GKSERR = 0
C
	IF (LWIDTH.LE.0.0) THEN
	   GKSERR = 90			! linewidth scale factor .LE. 0
	ELSE
	   ILWID = LWIDTH
	   DO 20 I=1,WSMAX
	      UPLIN(I) = .TRUE.		! attributes need updating
20	   CONTINUE
	ENDIF
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSPLCI(COLI)
C
**	MODULE	GSPLCI
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET POLYLINE COLOUR INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	COLI			! polyline colour index
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER I
C
	GKSERR = 0
	IF (COLI.LT.0) THEN
	   GKSERR = 85			! colour index .LT. 0
	ELSE
	   ICOLI = COLI
	   DO 20 I=1,WSMAX
	      UPLIN(I) = .TRUE.		! attributes need updating
20	   CONTINUE
	ENDIF
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSASF(LASF)
C
**	MODULE	GSASF
**	IDENT	30NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C Add setting of UPFA			Tony J Ibbs	30-Nov-1984
C
C SET ASPECT SOURCE FLAGS
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Arguments:
	INTEGER	LASF(ASFMAX)			! list of flags
C
	INTEGER	I				! loop counter
C
	GKSERR = 0
	DO 11 I = 1,ASFMAX
	   GASF(I) = LASF(I)
11	CONTINUE
C
	DO 12 I = 1,WSMAX
	   UPLIN(I) = .TRUE.		! attributes need updating
	   UPFA(I)  = .TRUE.
	   UPTX(I)  = .TRUE.
12	CONTINUE
C
	RETURN
	END
C
C***********************************************************************
C
C	WORKSTATION ATTRIBUTES (Representations)
C	========================================
C
C
	SUBROUTINE	GSPLR(WKID,PLI,LTYPE,LWIDTH,COLI)
C
**	MODULE	GSPLR
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-Jul-1983
C Colour added					PGH	29-Feb-1984
C
C SET POLYLINE REPRESENTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	PLI			! polyline index
	INTEGER	LTYPE			! linetype
	REAL	LWIDTH			! line width scale factor
	INTEGER	COLI			! colour index
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (PLI .LT. 1 .OR. PLI .GT. PLMAX ) THEN
	   GKSERR	= 60		! polyine index is invalid
	ELSEIF (LTYPE .LE. 0) THEN
	   GKSERR	= 62		! linetype is invalid
	ELSEIF (LWIDTH .LE. 0) THEN
	   GKSERR	= 90		! linewidth SF is invalid
	ELSEIF (COLI .LT. 0 ) THEN
	   GKSERR	= 86		! colour index is invalid
	ELSE
	   PLTYPE(PLI,DEV) = LTYPE	! store values in bundle table
	   PLWDTH(PLI,DEV) = LWIDTH
	   PLCOL(PLI,DEV)  = COLI
	   IF (PLI .EQ. PLIND) THEN	! apply if current index
	      UPLIN(DEV)  = .TRUE.	! attributes need updating
	   ENDIF
	ENDIF
C
9999	RETURN
C
	END
C
	SUBROUTINE	GSCR(WKID,CI,RED,GREEN,BLUE)
C
**	MODULE	GSCR
**	IDENT	25JL85
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	25-Jul-1985
C
C SET COLOUR REPRESENTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	CI			! colour index
	REAL	RED,GREEN,BLUE		! colour values
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
	INTEGER*4	COLOUR
	BYTE		C(4),BLINK
	INTEGER*2	R,G,B
	EQUIVALENCE	(C(1),COLOUR)
	EQUIVALENCE	(R,C(1)),(G,C(2)),(B,C(3)),(BLINK,C(4))
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (CI .LT. 0) THEN
	   GKSERR	= 93		! colour index is invalid
	ELSEIF (RED.LT.0.0.OR.RED.GT.1.0.OR.
     &		GREEN.LT.0.0.OR.GREEN.GT.1.0.OR.
     &		BLUE.LT.0.0.OR.BLUE.GT.1.0) THEN
	   GKSERR	= 96		! colour out of range
	ELSE
	   IF (DEV.EQ.GSIG) THEN	! only on Sigma
	      R = RED*255.0
	      G = GREEN*255.0
	      B = BLUE*255.0
	      BLINK = 0
	      CALL VSSGSC(CI,COLOUR)
	   ENDIF
	ENDIF
C
9999	RETURN
C
	END
C
C**********************************************************************
C
C	TRANSFORMATION FUNCTIONS
C	========================
C
C
	SUBROUTINE	GSWN(TRN,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWN
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET WINDOW 
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! window number
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER TRNTMP			! temporary copy of TRN so as
C					! not to pass back new value.
	INTEGER	I
C
	TRNTMP  = TRN+1			! convert to Fortran index
C
	IF (TRNTMP .LT. 1 .OR. TRNTMP .GT. TRNMAX) THEN
	   GKSERR = 50			! transformation invalid
	ELSEIF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) THEN
	   GKSERR = 51			! rectangle definition invalid
	ELSE
	   GKSERR = 0
	   WINDOW(1,TRNTMP) = XMIN
	   WINDOW(2,TRNTMP) = XMAX
	   WINDOW(3,TRNTMP) = YMIN
	   WINDOW(4,TRNTMP) = YMAX
	   DO 20 I=1,WSMAX
	      UPTRN(I) = .TRUE.		! transformations need updating
20	   CONTINUE
	ENDIF
	RETURN
C
	END
C
C**********************************************************************
C
	SUBROUTINE	GSVP(TRN,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSVP
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET VIEWPORT
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! viewport number
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER TRNTMP			! temporary copy of TRN so as
C					! not to pass back new value.
	INTEGER	I
C
	GKSERR	= 0			! no errors yet
	TRNTMP = TRN+1			! convert to Fortran index
C
	IF (TRNTMP .LT. 1 .OR. TRNTMP .GT. TRNMAX) THEN
	   GKSERR	= 50	! transformation number invalid
	ELSEIF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) THEN
	   GKSERR	= 51	! rectangle definition is invalid
	ELSEIF (XMIN .LT. 0.0 .OR. XMAX .GT. 1.0 .OR.
     &	        YMIN .LT. 0.0 .OR. YMAX .GT. 1.0) THEN
	   GKSERR	= 53	! viewport not within NDC unit square
	ELSE
	   VIEWPT(1,TRNTMP) = XMIN
	   VIEWPT(2,TRNTMP) = XMAX
	   VIEWPT(3,TRNTMP) = YMIN
	   VIEWPT(4,TRNTMP) = YMAX
	   DO 20 I=1,WSMAX
	      UPTRN(I) = .TRUE.		! transformation needs updating
20	   CONTINUE
	ENDIF
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSWKWN(WKID,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWKWN
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	27-Oct-1983
C
C SET WORKSTATION WINDOW
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) THEN
	   GKSERR = 51	! rectangle definition is invalid
	ELSEIF (XMIN .LT. 0.0 .OR. XMAX .GT. 1.0 .OR.
     &	        YMIN .LT. 0.0 .OR. YMAX .GT. 1.0) THEN
	   GKSERR = 53	! workstation window not within NDC unit square
	ELSE
	   WSWIN(1,DEV) = XMIN
	   WSWIN(2,DEV) = XMAX
	   WSWIN(3,DEV) = YMIN
	   WSWIN(4,DEV) = YMAX
	   UPTRN(DEV) = .TRUE.
	ENDIF
C
9999	RETURN
C
	END
C
C**********************************************************************
C
	SUBROUTINE	GSWKVP(WKID,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWKVP
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	27-Oct-1983
C
C SET WORKSTATION VIEWPORT
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) THEN
	   GKSERR = 51		! rectangle definition invalid
	ELSEIF (((XMAX-XMIN) .GT. DCMAXX(DEV)) .OR.
     &	        ((YMAX-YMIN) .GT. DCMAXY(DEV))) THEN
	   GKSERR = 54	! workstation viewport not within display space
	ELSE
	   WSVIEW(1,DEV) = XMIN
	   WSVIEW(2,DEV) = XMAX
	   WSVIEW(3,DEV) = YMIN
	   WSVIEW(4,DEV) = YMAX
	   UPTRN(DEV) = .TRUE.

	ENDIF
C
9999	RETURN
C
	END
C
C**********************************************************************
C
	SUBROUTINE	GSELNT(TRN)
C
**	MODULE	GSELNT
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SELECT NORMALISATION TRANSFORMATION
C			  and set clipping limits to viewport
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! transformation number
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER TRNTMP		! temporary copy of TRN so as not to
C				! pass back new value
	INTEGER	I
C
	GKSERR	= 0			! no errors yet
	TRNTMP=TRN+1			! convert to Fortran index
C
	IF (TRNTMP.LT.1 .OR. TRNTMP.GT.TRNMAX) THEN
	   GKSERR = 50			! transformation number invalid
	ELSE
	   TRNCUR = TRNTMP		! set currently selected
	   DO 20 I=1,WSMAX
	      UPTRN(I) = .TRUE.		! transformation needs updating
20	   CONTINUE
	ENDIF
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSCLIP(CLSW)
C
**	MODULE	GSCLIP
**	IDENT	31JL84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	31-July-1984
C
C SET CLIPPING INDICATOR
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	CLSW			! clipping indicator
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	ENCLIP = (CLSW.EQ.GCLIP)
	RETURN
C
	END
C
C**********************************************************************
C
C	INQUIRY FUNCTIONS
C	=================
C
	SUBROUTINE GQASF(ERRIND,LASF)
C
***	MODULE	GQASF
***	IDENT	30NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	 1-May-1984
C Inquire for ASFMAX flags			TJI	30-Nov-1984
C
C INQUIRE ASPECT SOURCE FLAGS
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	LASF(ASFMAX)	! Aspect source flags
C
	INTEGER	I
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	DO 11 I=1,ASFMAX
	   LASF(I) = GASF(I)
11	CONTINUE
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GQMDS(WTYPE,ERRIND,COOUNI,RX,RY,LX,LY)
C
***	MODULE	GQMDS
***	IDENT	14SE83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	14-Sept-1983
C
C INQUIRE MAXIMUM DISPLAY SURFACE SIZE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WTYPE		! Workstation type
	INTEGER	ERRIND		! Error indicator
	INTEGER	COOUNI		! Device Coordinate Units
	REAL	RX,RY		! Max. display surface size in DC
	INTEGER	LX,LY		! no. of device units in X and Y
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
C
	INTEGER	DEV,I
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
C which workstation type is it
	DO 10 I=1,TYPNUM
	   IF (WTYPE.EQ.WTYPES(I,1)) THEN
	      DEV = WTYPES(I,2)
	      GOTO 20
	   ENDIF
10	CONTINUE
C
C unknown type
	ERRIND = 23
	GOTO 999
C
20	COOUNI = GMETRE		! units are in metres
	RX = DCMAXX(DEV)	! film size in metres
	RY = DCMAXY(DEV)
	LX  = RASTX(DEV)	! pixels
	LY  = RASTY(DEV)
C
999	RETURN
	END
C
C
C**********************************************************************
C
	SUBROUTINE GQPLF(
     &		WTYPE,N,ERRIND,NLT,LT,NLW,NOMLW,RLWMIN,RLWMAX,NPPLI)
C
***	MODULE	GQPLF
***	IDENT	16MY84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	16-May-1984
C
C INQUIRE POLYLINE FACILITIES
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WTYPE		! Workstation type
	INTEGER	N		! list element requested
	INTEGER	ERRIND		! Error indicator
	INTEGER NLT		! number of available linetypes
	INTEGER	LT		! N'th element of available linetypes
	INTEGER NLW		! number of available linewidths
	REAL	NOMLW		! nominal linewidth (DC)
	REAL	RLWMIN,RLWMAX	! range of linewidths
	INTEGER	NPPLI		! number of predefined polyline indices
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
***	COMMON/THKPAR/		! LDLIB common block
C
	INTEGER	DEV,I
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
C which workstation type is it
	DO 10 I=1,TYPNUM
	   IF (WTYPE.EQ.WTYPES(I,1)) THEN
	      DEV = WTYPES(I,2)
	      GOTO 20
	   ENDIF
10	CONTINUE
C
C unknown type
	ERRIND = 23
	GOTO 999
C
C this is a grey area regarding the linewidth on Sigma
20	NLT = 4			! number of linetypes
	LT = N			! just return N as N'th type
	NLW = 0			! continuous range of linewidths
	NOMLW = GNOMLW(DEV)	! nominal linewidth in DC
	RLWMIN = NOMLW		! also the minimum
	RLWMAX = 10.0*NOMLW	! rather arbitrary maximum
	NPPLI = PLMAX
C
999	RETURN
	END
C
C
C**********************************************************************
C
	SUBROUTINE GQLN(ERRIND,LTYPE)
C
***	MODULE	GQLN
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE LINETYPE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	LTYPE		! line type
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	LTYPE = ILTYPE
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GQLWSC(ERRIND,LWIDTH)
C
***	MODULE	GQLWSC
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE LINE WIDTH SCALE FACTOR
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	REAL	LWIDTH		! line width scale factor
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	LWIDTH = ILWID
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GQPLCI(ERRIND,COLI)
C
***	MODULE	GQPLCI
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE POLYLINE COLOUR INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	COLI		! polyline colour index
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	COLI = ICOLI
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GQCR(WKID,CI,TYPE,ERRIND,RED,GREEN,BLUE)
C
**	MODULE	GQCR
**	IDENT	26AU86
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	25-Jul-1985
C
C INQUIRE COLOUR REPRESENTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	CI			! colour index
	INTEGER	TYPE			! type of values (unused)
	INTEGER	ERRIND			! error indicator
	REAL	RED,GREEN,BLUE		! colour values
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C workspace
	INTEGER	DEV
	INTEGER*4	COLOUR
	BYTE		C(4)
	EQUIVALENCE	(C(1),COLOUR)
C
C function
	INTEGER	GETDEV
C
	ERRIND = GETDEV(DEV,WKID)
	IF (ERRIND.NE.0) GOTO 9999
C
	IF (CI.LT.0.OR.CI.GT.255) THEN
	   ERRIND	= 86		! colour index is invalid
	ELSE
	   IF (DEV.EQ.GSIG) THEN	! only on Sigma
	      CALL VSSGQC(CI,COLOUR)
	      RED = (C(1).AND.255)/255.0
	      GREEN = (C(2).AND.255)/255.0
	      BLUE = (C(3).AND.255)/255.0
	   ENDIF
	ENDIF
C
9999	RETURN
	END
C
C
C**********************************************************************
C
C	GKSLDLIB UTILITIES
C	==================
C
	SUBROUTINE GUPTRN(DEV)
C
***	MODULE	GUPTRN
***	IDENT	19SE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	19-Sep-1984
C
C Update the tranformation for device DEV
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/		! GKS data structures
C
C argument
	INTEGER	DEV
C
C w/s
	REAL	NDCSCX,NDCSCY	! scaling part of WC to NDC transform
	REAL	NDCOFX,NDCOFY	! offset  part of WC to NDC transform
	REAL	DCSC		! scaling part of NDC to DC transform
	REAL	DCOFX, DCOFY	! offset  part of NDC to DC transform
C
C Work out the scaling factor and offset for WC to NDC transformation.
C Effective formula for transforming a coord is:-
C	XN = XVMIN + (XW-XWMIN) * ((XVMAX-XVMIN)/(XWMAX-XWMIN))
C	YN = YVMIN + (YW-YWMIN) * ((YVMAX-YVMIN)/(YWMAX-YWMIN))
C
C This formula needs to be put into the form:-
C	XN = (XW*NDCSCX) + NDCOFX
C	YN = (YW*NDCSCY) + NDCOFY
C
	NDCSCX = (VIEWPT(2,TRNCUR)-VIEWPT(1,TRNCUR))
     &		/(WINDOW(2,TRNCUR)-WINDOW(1,TRNCUR))
	NDCSCY = (VIEWPT(4,TRNCUR)-VIEWPT(3,TRNCUR))
     &		/(WINDOW(4,TRNCUR)-WINDOW(3,TRNCUR))
	NDCOFX = VIEWPT(1,TRNCUR) - (WINDOW(1,TRNCUR)*NDCSCX)
	NDCOFY = VIEWPT(3,TRNCUR) - (WINDOW(3,TRNCUR)*NDCSCY)
C
C A similar formula has to be used to transform NDC to DC with the
C difference that the shape of the workstation window has to be
C preserved within the workstation viewport (bottom left corner
C is fixed).
	DCSC = MIN(((WSVIEW(2,DEV)-WSVIEW(1,DEV))
     &		   /(WSWIN (2,DEV)-WSWIN (1,DEV)))
     &		  ,((WSVIEW(4,DEV)-WSVIEW(3,DEV))
     &		   /(WSWIN (4,DEV)-WSWIN (3,DEV))))
	DCOFX = WSVIEW(1,DEV) - (WSWIN(1,DEV)*DCSC)
	DCOFY = WSVIEW(3,DEV) - (WSWIN(3,DEV)*DCSC)
C
C Both transformations have to be combined in the form:-
C	XD = (((XW*NDCSCX*DCSC) + (NDCOFX*DCSC)+DCOFX
C	YD = (((YW*NDCSCY*DCSC) + (NDCOFY*DCSC)+DCOFY
C
	SCALEX(DEV) = NDCSCX * DCSC
	SCALEY(DEV) = NDCSCY * DCSC
	OFFX(DEV) = (NDCOFX*DCSC) + DCOFX
	OFFY(DEV) = (NDCOFY*DCSC) + DCOFY
C
C Work out the clipping limits.
C These correspond to the area of overlap in NDC space between
C the viewport and the workstation window transformations.
C Logical variable CLPALL is set if there is no overlap.
	CLPALL(DEV) = .FALSE.
C Is there any overlap at all?
	IF ((VIEWPT(1,TRNCUR).GT.WSWIN(2,DEV))
     &  .OR.(VIEWPT(2,TRNCUR).LE.WSWIN(1,DEV))
     &  .OR.(VIEWPT(3,TRNCUR).GT.WSWIN(4,DEV))
     &  .OR.(VIEWPT(4,TRNCUR).LE.WSWIN(3,DEV))) GOTO 5
C
C Define the clipping limits to be the overlapping rectangle.
	CLIPLO(1,DEV) = MAX(VIEWPT(1,TRNCUR),WSWIN(1,DEV))	! W
	CLIPHI(1,DEV) = MIN(VIEWPT(2,TRNCUR),WSWIN(2,DEV))	! E
	CLIPLO(2,DEV) = MAX(VIEWPT(3,TRNCUR),WSWIN(3,DEV))	! S
	CLIPHI(2,DEV) = MIN(VIEWPT(4,TRNCUR),WSWIN(4,DEV))	! N
C
C Transform the clipping limits into WC space so that clipping can
C be done before transforming coordinates. This is not GKS standard.
C To do this we use the formulas:-
C	XW = (XN-NDCOFX) / NDCSCX
C	YW = (YN-NDCOFY) / NDCSCY
C
	CLIPLO(1,DEV) = (CLIPLO(1,DEV)-NDCOFX) / NDCSCX
	CLIPHI(1,DEV) = (CLIPHI(1,DEV)-NDCOFX) / NDCSCX
	CLIPLO(2,DEV) = (CLIPLO(2,DEV)-NDCOFY) / NDCSCY
	CLIPHI(2,DEV) = (CLIPHI(2,DEV)-NDCOFY) / NDCSCY
	GOTO 20
C
C No overlap
5	CLPALL(DEV) = .TRUE.
C
C transformation is now up to date
20	UPTRN(DEV) = .FALSE.
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GUPLIN(DEV)
C
***	MODULE	GUPLIN
***	IDENT	30NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C Add setting of UPFA			Tony J Ibbs	30-Nov-1984
C
C Update the polyline attributes for device DEV
C
	IMPLICIT NONE
C
C argument
	INTEGER	DEV
C
C local variables
	INTEGER	NLTYPE,NCOLI
	REAL	NLWID
C
***	COMMON/GKSDAT2/		! GKS data structures
***	COMMON/THKPAR/		! LDLIB common block
C
C ---------------------------------------------------------------------
C
	IF (GASF(1).EQ.GBUNDL) THEN
	   NLTYPE = PLTYPE(PLIND,DEV)
	ELSE
	   NLTYPE = ILTYPE
	ENDIF
C
	IF (GASF(2).EQ.GBUNDL) THEN
	   NLWID = PLWDTH(PLIND,DEV)
	ELSE
	   NLWID = ILWID
	ENDIF
C
	IF (GASF(3).EQ.GBUNDL) THEN
	   NCOLI = PLCOL(PLIND,DEV)
	ELSE
	   NCOLI = ICOLI
	ENDIF
C
C ---------------------------------------------------------------------
C
	IF (NLTYPE.NE.CLTYPE(DEV)) THEN
	   CLTYPE(DEV) = NLTYPE
C
	   IF ( DEV.EQ.GTEK ) THEN
C
	      GOTO (110,120,130,140), NLTYPE
C
110	      CALL DOTTED(0)		! solid line
	      GOTO 300
C
120	      CALL DASHED(1,0.003,0.002,0.0)	! dashed
	      UPFA(DEV) = .TRUE.	! changes fill area, too
	      GOTO 300
C
130	      CALL DASHED(1,0.002,0.001,0.0)	! dotted
	      UPFA(DEV) = .TRUE.	! changes fill area, too
	      GOTO 300
C
140	      CALL DASHED(2,0.006,0.003,0.001)	! dash-dot
	      UPFA(DEV) = .TRUE.	! changes fill area, too
	      GOTO 300
	   ELSE
C
C	 do nothing for the moment
C
	      CONTINUE
	   ENDIF
	ENDIF
C
300	IF (NLWID.LE.1.0) NLWID = 0.0	! ie turn off thick lines
	IF (NLWID.NE.CLWID(DEV)) THEN
C
	   CLWID(DEV) = NLWID
	   IF ( DEV.EQ.GTEK ) THEN
C
C	- Tektronix - set required thickness
C
	      CALL THICK(NLWID*MSPOT/DCUNIT(1))
	      IF (NLWID.NE.FALWID(DEV)) UPFA(DEV) = .TRUE.
	   ELSE
C
C	 device 2 - do nothing, for now
C
	      CONTINUE
	   ENDIF
	ENDIF
C
600	IF (NCOLI.NE.CCOLI(DEV)) THEN
C
	   CCOLI(DEV) = NCOLI
	   UPFA(DEV) = .TRUE.			! update fill area
	   UPTX(DEV) = .TRUE.			! update text
	   IF ( DEV.EQ.GTEK ) THEN
C
C	 device 1 - Tektronix - change 'colour'
C
	      CALL PEN (NCOLI)
	   ELSE
C
C	 device 2 - ARGS - change colour
C
	      CALL VSCOL(NCOLI)
	   ENDIF
	ENDIF
C
	UPLIN(DEV) = .FALSE.		! now up to date
	RETURN
	END
C
C**********************************************************************
C
	LOGICAL FUNCTION GKCLIP(DEV,X1,Y1,X2,Y2)
C
***	MODULE	GKCLIP
***	IDENT	23JL80
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Authors many and varied but mainly Paul Hardy based on algorithms
C by P. Woodsford and P.Cross, with tidies by R.Fairbairns
C
C Created July 1980
C
C to clip a straight line to rectangular boundaries.
C function value is TRUE if no visible result.
C
	IMPLICIT NONE
C
	INTEGER	DEV		! which clip limits to use
	REAL X1,Y1,X2,Y2	! coords of ends of line
C
***	COMMON/GKSDAT2/		! contains boundaries
C
	PARAMETER X=1,Y=2	! for clarity
C w/s
	REAL P(2,2)		! our copies of the points
	REAL D(2)		! DX,DY is line vector
	REAL R			! temp variable
	INTEGER DEP,INDEP	! X / Y depending which axis considered
	INTEGER HIGH,LOW	! 1 or 2 to indicate ends of line
C
C set everything up
	GKCLIP=.FALSE.			! assume visible result
	P(X,1)=X1			! take copy of args
	P(Y,1)=Y1
	P(X,2)=X2
	P(Y,2)=Y2
	D(X)=X2-X1			! calculate vector
	D(Y)=Y2-Y1
C
C now loop for both axes
	DO 30 DEP=X,Y
	   INDEP=3-DEP			! independent axis
	   LOW=1			! guess which end lowest
	   IF(D(INDEP).LT.0.0) LOW=2	! upside down
	   HIGH=3-LOW			! the other end
	   IF(P(INDEP,HIGH).LT.CLIPLO(INDEP,DEV)) GOTO 50 ! out bottom
	   IF(P(INDEP,LOW ).GT.CLIPHI(INDEP,DEV)) GOTO 50 ! out top
	   IF(D(INDEP).EQ.0.0) GOTO 30	! parallel to frame this axis
C
C here to consider low end
	   R=P(INDEP,LOW)-CLIPLO(INDEP,DEV) ! distance from frame
	   IF(R.GE.0.0) GOTO 20		! inside frame
C
C clip low end
	   P(DEP,LOW)=P(DEP,LOW)-R*D(DEP)/D(INDEP) ! similar triangles
	   P(INDEP,LOW)=CLIPLO(INDEP,DEV) ! push onto frame
C
C now lets consider the high end
20	   R=CLIPHI(INDEP,DEV)-P(INDEP,HIGH) ! distance from frame
	   IF(R.GE.0.0) GOTO 30		! inside frame
C
C clip high end
	   P(DEP,HIGH)=P(DEP,HIGH)+R*D(DEP)/D(INDEP) !similar triangles
	   P(INDEP,HIGH)=CLIPHI(INDEP,DEV) ! push onto frame
C
30	   CONTINUE			! loop for both axes
C
C copy args back
	X1=P(X,1)
	Y1=P(Y,1)
	X2=P(X,2)
	Y2=P(Y,2)
40	RETURN
C
C here with all invisible
50	GKCLIP=.TRUE.
	GOTO 40
C
	END
C
C**********************************************************************
C
	SUBROUTINE GKSW2D(WKID,WX,WY,DX,DY)
C
***	MODULE	GKSW2D
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created August 1984
C
C To convert world coordinate WX,WY to device coordinate DX,DY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	WX,WY		! input world coordinate
	REAL	DX,DY		! output device coordinate
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
C Make sure transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)
C
	DX = (WX*SCALEX(DEV))+OFFX(DEV)
	DY = (WY*SCALEY(DEV))+OFFY(DEV)
C
9999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKSD2W(WKID,DX,DY,WX,WY)
C
***	MODULE	GKSD2W
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created February 1985
C
C To convert device coordinate DX,DY to world coordinate WX,WY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	DX,DY		! input device coordinate
	REAL	WX,WY		! output world coordinate
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
C Make sure transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)
C
	WX = (DX-OFFX(DEV))/SCALEX(DEV)
	WY = (DY-OFFY(DEV))/SCALEY(DEV)
C
9999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GD2W(WKID,DX,DY,WX,WY)
C
***	MODULE	GD2W
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created August 1984
C
C To scale device coordinate lengths DX,DY to world coordinate WX,WY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	DX,DY		! input device coordinate
	REAL	WX,WY		! output world coordinate
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
C Make sure transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)
C
	WX = DX / SCALEX(DEV)
	WY = DY / SCALEY(DEV)
C
9999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GW2D(WKID,WX,WY,DX,DY)
C
***	MODULE	GW2D
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created August 1984
C
C To scale world coordinate lengths WX,WY, to device coordinate DX,DY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	WX,WY		! input world coordinate
	REAL	DX,DY		! output device coordinate
C
C w/s
	INTEGER	DEV
C
C function
	INTEGER	GETDEV
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
C Make sure transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)
C
	DX = WX*SCALEX(DEV)
	DY = WY*SCALEY(DEV)
C
9999	RETURN
	END
C
C**********************************************************************
C
	INTEGER FUNCTION GETDEV(DEV,WKID)
C
**	MODULE	GETDEV
**	IDENT	18SE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	18-Sep-1984
C
C Get device corresponding to a particular workstation identifier
C Returning 0 if successful, or 20 (GKS error specified workstation
C identifier is invalid.
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	DEV			! device
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/GKSDAT2/
C
	GETDEV = 0
	DO 10 DEV=1,WSMAX
	   IF (WKID.EQ.WKIDS(DEV)) GOTO 20
10	CONTINUE
	DEV = -1			! not found
	GETDEV = 20
C
20	CONTINUE
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKSDAT(DEV,LDARG,USEPC)
C
***	MODULE	GKSDAT
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created April 1985
C
C To set control variables
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
C
C arguments
	INTEGER	DEV		! device number
	INTEGER LDARG		! argument for LDINIT
	LOGICAL*1 USEPC		! use PCFRAM rather than DIFRAM
C
C Set things in common block
	IF (DEV.EQ.GTEK.OR.DEV.EQ.GSIG) THEN
	   INIARG(DEV) = LDARG
	   PC(DEV) = USEPC
	ENDIF
C
	RETURN
	END
C
C *********************************************************************
C
	SUBROUTINE	GESC(ESCID,DATA)
C
**	MODULE	GESC
**	IDENT	29MY86
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	9-May-1986
C
C ESCAPE
C
	IMPLICIT NONE
C
***	COMMON/GFADAT2/
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Arguments
	INTEGER ESCID			! escape identifier
	REAL	DATA(2)			! other data
C
C Despatch on escape type
	GKSERR = 0
	IF (ESCID.EQ.3) GOTO 300
	IF (ESCID.EQ.103) GOTO 3000
	GKSERR = 180			! function not supported
	GOTO 9999
C
C Set fill area line width and spacing
300	CONTINUE
C
C Zero width will cause the nominal width to be used
C If spacing is less than width, then set a sensible value
C
	IF (DATA(1).GE.0.0) GFAWID = DATA(1)
	GFAGAP = DATA(2)
	IF (GFAGAP.LT.GFAWID) GFAGAP = 2.0*GFAWID
	GOTO 9999
C
C Inquire fill area line width and spacing
3000	DATA(1) = GFAWID
	DATA(2) = GFAGAP
C
9999	RETURN
	END
