C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 1992-03-26 13:58:14.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
C 	CONTROL FUNCTIONS
C	=================
C
	SUBROUTINE	GOPKS(ERRFIL)
C
**	MODULE	GOPKS
**	IDENT	26MR92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
	IMPLICIT NONE
C
	EXTERNAL GKSBLK		! ensure that block data is linked in
C
C OPEN GKS	- includes initialising of data structures and variables
C
C Arguments:
	INTEGER	ERRFIL			! error message file
C
C
***	COMMON/CMN:GKSDAT1/			! GKS data structures
***	COMMON/CMN:GKSESL/			! GKS error state list
C
C Set up initial indices and  default modes
	GKSERR 	= 0		! no errors yet
	TRNCUR	= 1		! use normalisation transformation 0
	PLIND	= 1		! use polyline bundle table 1
	ENCLIP	= .TRUE.	! enable clipping
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GCLKS
C
**	MODULE	GCLKS
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C CLOSE GKS	
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSESL/
C
	GKSERR	= 0				! no errors
C
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GOPWK(WKID,CONID,WTYPE,IN_IFF)
C
**	MODULE	GOPWK
**	IDENT	10AU89
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Adapted for generation of 'primitive' IFF	JHR	18-Apr-1989
C Add initialise fill area update		TJI	27-Nov-1984
C Created					SCM	27-Jul-1983
C
C OPEN WORKSTATION   - sets up World Coordinates and Normalised Device
C			  Coordinates to be 1 metre on the film with the
C			  origin at the bottom left hand corner
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID		! workstation-identifier
	INTEGER	CONID		! connection-identifier
	INTEGER	WTYPE		! workstation type
	CHARACTER*(*)	IN_IFF	! name of the i/p IFF-file.
				! ** N.B. this is only applicable
				!    to the Primitive IFF version **
C
***	PARAMETER/FPPCMN:EFNLUN/
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
***	COMMON/CMN:GKSIFF/
***	COMMON/LSL$CMNIFF:IFFHAN/
C
C Local variables
	REAL NULL
	INTEGER		DOTPOS		! position of last '.' in string.
	CHARACTER*72	PRIMTIT		! Primitive IFF-file name
	INTEGER		I		! DO-loop counter.
C
	GKSERR	= 0			! no errors
C
	NO_COUNT = 0		! no overlays created yet.
	NF_COUNT = 0		! reset the New Feature count.
	IFF_STARTED = .FALSE.
	IN_FEATURE = .FALSE.
	THIS_AREA = .FALSE.
	AREA_ATTR = .FALSE.
	STIND = 0
C
C set up correct device units (mm or cm)
	DCUNIT = 1000.0			! set as mm
C
	WKIDS = WKID
	DEFER = GASTI	! deferral mode is At Some TIme
	REGEN = GSUPPD	! implicit regeneration suppressed
	UPTRN = .TRUE.	! update transformation
	UPLIN = .TRUE.	! update polyline attributes
	UPFA  = .TRUE.	! update fill area attributes
C
	CCOLI = -1	! ensure colour set first time round
	CLWID = 0.0	! and linewidth
	GNOMLW  = 0.001	! 1 micron
	CCAP = 0	! current cap style 'butt'
	CJOIN = 0	! current join sytle 'mitre'
C
C Convert to metres
	DCMAXX  = 1120.0
	DCMAXY  = 2470.0
	DCMAXX  = DCMAXX/DCUNIT
	DCMAXY  = DCMAXY/DCUNIT
	GNOMLW  = GNOMLW/DCUNIT
CC
CC Set workstation viewport to entire area
C	CALL GSWKVP(WKID,0.0,DCMAXX,0.0,DCMAXY)
C
C open the Primitive IFF-file...
C  add the .PRIM to where the i/p file's extension is.
	DO 100 I = LEN(IN_IFF), 1, -1
	  IF ( IN_IFF(I:I) .EQ. '.' )  THEN
	    DOTPOS = I
	    GOTO 110
	  ENDIF
100	CONTINUE
C...fall thro' to error...
	CALL WRITEF('Error parsing input IFF file %S', IN_IFF)
	GOTO 999
CC	DOTPOS = INDEX(IN_IFF, '.')
110	PRIMTIT = IN_IFF(1:DOTPOS-1)//'.PRIM'
	CALL IFFOPN(PRIMLUN,PRIMTIT)
	IF (IERCD.NE.0) THEN
	  CALL WRITEF('Error opening Primitive IFF file %S',PRIMTIT)
	  GOTO 999
	ENDIF
999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GCLWK(WKID)
C
**	MODULE	GCLWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Adapted for generation of 'primitive' IFF	JHR	18-Apr-1989
C Created					SCM	27-July-1983
C
C CLOSE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	PARAMETER/FPPCMN:EFNLUN/
C
***	COMMON/CMN:GKSESL/
***	COMMON/CMN:GKSIFF/
***	COMMON/LSL$CMNIFF:IFFHAN/
C
	INTEGER*2	IECODE,IELEN
C
C close the Primitive IFF-file.
	CALL IFFSEL(PRIMLUN)
	CALL GKS_END_FEATURE
	CALL IFFUNO(LPOSNO)
	CALL IFFEO
	CALL IFFEM
	CALL IFFEJ
	CALL IFFRWD
	CALL IFFNXT(IECODE,IELEN)
	IF (IECODE.EQ.'RA') CALL EIHWR(RANGE,4,1)
	CALL IFFCLO(PRIMLUN)
C
	GKSERR = 0
C
9999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GACWK(WKID)
C
**	MODULE	GACWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C ACTIVATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	WSACT = .TRUE.
9999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GDAWK(WKID)
C
**	MODULE	GDAWK
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C DEACTIVATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	WSACT = .FALSE.
9999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GCLRWK(WKID,COFL)
C
**	MODULE	GCLRWK
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	14-Nov-1983
C
C CLEAR WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER COFL			! control flag
C
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
C	CALL LDWAIT			! execute all deferred actions
C	IF (PC) THEN
C	   CALL PCFRAM(1.0)
C	ELSE
C	   CALL DIFRAM(1)
C	ENDIF
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GUWK(WKID,REGFL)
C
**	MODULE	GUWK
**	IDENT	16MY84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	16-May-1984
C
C UPDATE WORKSTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	REGFL			! regeneration flag
C
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
C	CALL LDWAIT
C
9999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GSDS(WKID,DEFMOD,REGMOD)
C
**	MODULE	GSDS
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET DEFERRAL STATE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	DEFMOD			! deferral mode
	INTEGER	REGMOD			! implicit regeneration mode
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (DEFMOD .LT. GASAP .OR. DEFMOD .GT. GASTI) GOTO 10
	DEFER = DEFMOD
C
C nasty call to GUWK (second argument ignored)
	IF (DEFER.EQ.GASAP.AND.WSACT) CALL GUWK(WKID,0)
10	IF (REGMOD .LT. GSUPPD .OR. REGMOD .GT. GALLOW) GOTO 9999
	REGEN= REGMOD
C
9999	RETURN
	END
C
C***********************************************************************
C
C	OUTPUT FUNCTIONS
C	================
C
	SUBROUTINE	GPL(N,PX,PY)
C
**	MODULE	GPL
**	IDENT	28OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Adapted for generation of 'primitive' IFF	JHR	17-Apr-1989
C Created					SCM	27-July-1983
C
C POLYLINE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER N			! number of points
	REAL	PX(N)			! X coords of points in WC
	REAL	PY(N)			! Y coords of points in WC
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
***	COMMON/CMN:GKSIFF/
C
C function
	LOGICAL		GKCLIP
C
C Internal variables:
	INTEGER*4	IWID			! IFF integer width
	REAL		PPX(2),PPY(2)
	INTEGER		I
C
	IF ( N .LT. 2 )  THEN
	  GKSERR = 100
	  GOTO 9999
	ENDIF
C
C Is this workstation active?
	IF (.NOT.WSACT) GOTO 9999
C
C Make sure transformation is up to date
	IF (UPTRN) CALL GUPTRN
C
C Is everything clipped ?
	IF (CLPALL) GOTO 9999
C
C Make sure polyline attributes are up to date.
	IF (UPLIN.AND..NOT.AREA_ATTR) CALL GUPLIN
C
C set up line width in microns
C
	IWID = NINT(CLWID*GNOMLW*DCUNIT*1000)
	IF (IWID.LT.0) IWID=0
	IF (IWID.GT.32767) IWID=32767
C
	IF (.NOT.ENCLIP) THEN
	   CALL GKS_ADD_POINTS(CCOLI,IWID,CCAP,CJOIN,PX,PY,N)
	   GOTO 9999
	ENDIF
C
C Loop for each segment of this polyline.
	DO 90 I = 1, N-1
	   PPX(1) = PX(I)
	   PPY(1) = PY(I)
	   PPX(2) = PX(I+1)
	   PPY(2) = PY(I+1)
	   IF (GKCLIP(PPX(1),PPY(1),PPX(2),PPY(2))) GOTO 90
	   CALL GKS_ADD_POINTS(CCOLI,IWID,CCAP,CJOIN,PPX,PPY,2)
90	CONTINUE
C
9999	RETURN
	END
C
	SUBROUTINE GKS_ADD_POINTS(COLI,WID,CAP,JOIN,PX,PY,N)
C
**	MODULE	GKS_ADD_POINTS
**	IDENT	28OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-Feb-1990
C
C POLYLINE - add points to IFF feature
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	COLI			! colour index
	INTEGER	WID			! line width
	INTEGER	CAP			! cap style
	INTEGER	JOIN			! join style
	INTEGER N			! number of points
	REAL	PX(N)			! X coords of points in WC
	REAL	PY(N)			! Y coords of points in WC
C
***	PARAMETER/FPPCMN:EFNLUN/
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
***	COMMON/CMN:GKSIFF/
***	COMMON/LSL$CMNIFF:IFFHAN/
C
C Internal variables:
	INTEGER*4	I			! loop variable
	INTEGER		START			! first point to do
	INTEGER*2	ISQ			! IFF internal sequence number
	INTEGER*2	FSARR(4)		! feature status entry
C
C Do we need to write the file header
	IF (.NOT.IFF_STARTED) CALL GKS_BEGIN_IFF
C
C Do we need a new feature?
	START = 1
	IF (.NOT.IN_FEATURE .OR. (THIS_AREA.NEQV.LAST_AREA) .OR.
     &		COLI.NE.LAST_COLI .OR. WID.NE.LAST_WID .OR.
     &		(.NOT.THIS_AREA.AND.(CAP.NE.LAST_CAP.OR.
     &				     JOIN.NE.LAST_JOIN) ) ) GOTO 10
	IF (PX(1).NE.STBUF(1,STIND) .OR. PY(1).NE.STBUF(2,STIND)) THEN
C
C new line does not join on to previous - if an area, then carry on
C regardless, but for a line begin a new feature
	   IF (THIS_AREA) THEN
	      GOTO 20
	   ELSE
	      GOTO 10
	   ENDIF
	ENDIF
	START = 2
	GOTO 20
C
C end the previous feature
10	CALL IFFSEL(PRIMLUN)			! select the primitve file.
	CALL GKS_END_FEATURE
C
C set up start of feature stuff 
C
	IENDS = 0				! move to 1st pt.
	IF ( NO_COUNT.EQ.0 .OR. NF_COUNT.GE.32767 )  THEN
	   IF (NO_COUNT.NE.0) THEN
	      CALL IFFUNO(LPOSNO)
	      CALL IFFEO
	   ENDIF
	   NO_COUNT = NO_COUNT + 1
	   LPOSNO = LPOSE
	   CALL IFFNO(NO_COUNT,0)
	   NF_COUNT = 0
	ENDIF
	NF_COUNT = NF_COUNT + 1			! create a new feature
	ISQ = 0
	CALL IFFNF(NF_COUNT, ISQ)
C
C set up feature status with type and colour
C
	IF ( THIS_AREA )  THEN			! solid-area fill - flag as thus
	   FSARR(1) = 100			! FC - area
	   FSARR(2) = 1				! status - closed
	ELSE
	   FSARR(1) = CAP + 10*JOIN		! FC - line
	   FSARR(2) = 2				! status - open line
	ENDIF
	FSARR(3) = COLI				! colour as process code
	FSARR(4) = 0				! user-word
	CALL IFFFS(FSARR)
	CALL IFFTH(WID)
	IENDS = 0				! pen up
	IN_FEATURE = .TRUE.
	LAST_AREA = THIS_AREA
	LAST_COLI = COLI
	LAST_WID = WID
	LAST_CAP = CAP
	LAST_JOIN = JOIN
C
C add points to buffer
20	DO 100 I=START,N
	   IF (STIND.GT.0) THEN
	      IF ( STBUF(1,STIND).EQ.PX(I).AND.
     &		   STBUF(2,STIND).EQ.PY(I) ) GOTO 100	! duplicate
	   ENDIF
	   IF (STIND.EQ.MAX_COORDS) THEN
	      CALL IFFSEL(PRIMLUN)		! select the primitve file.
	      CALL IFFST(STBUF, STIND, IENDS)
	      IENDS = 1				! pen down
	      STIND = 0
	   ENDIF
	   STIND = STIND+1
	   STBUF(1,STIND) = PX(I)
	   STBUF(2,STIND) = PY(I)
	   IF (PX(I).LT.RANGE(1)) RANGE(1) = PX(I)
	   IF (PX(I).GT.RANGE(2)) RANGE(2) = PX(I)
	   IF (PY(I).LT.RANGE(3)) RANGE(3) = PY(I)
	   IF (PY(I).GT.RANGE(4)) RANGE(4) = PY(I)
100	CONTINUE
C
	CALL IFFSEL(IFFLUN)
C
	RETURN
	END
C
	SUBROUTINE GKS_END_FEATURE
C
**	MODULE	GKS_END_FEATURE
**	IDENT	28OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-Feb-1990
C
C POLYLINE - end IFF feature
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSIFF/
C
	IF (IN_FEATURE) THEN
	   IF (STIND.GT.0) THEN
	      CALL IFFST(STBUF, STIND, IENDS)
	      STIND = 0
	   ENDIF
	   CALL IFFEF
	   IN_FEATURE = .FALSE.
	ENDIF
C	
	RETURN
	END
C
	SUBROUTINE	GKS_BEGIN_IFF
C
**	MODULE	GKS_BEGIN_IFF
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Begin 'primitive' IFF	file		JHR	 4-May-1989
C
	IMPLICIT NONE
C
C
***	PARAMETER/FPPCMN:EFNLUN/
C
***	COMMON/CMN:MH_IFF_PRIMITIVE/
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSIFF/
***	COMMON/LSL$CMNIFF:IFFHAN/
***	COMMON/LSL$CMNIFF:MD2DES/	!  Common for version 2 MD
C
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
	REAL		COEFF(10,2)	! Cubic coefficients
	REAL		CPTS(4,4)	! Control points
C
C Define an NS entry
C
	CHARACTER*27	NS
	DATA		NS	/'IFF graphics primitive file'/
C
C Set the unit matrix in the coefficients
C
	DATA	COEFF	/0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,
     &			 0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0/
C
C get extent from currently set WINDOW (from GSWN)
	XMIN = WINDOW(1,TRNCUR)
	XMAX = WINDOW(2,TRNCUR)
	YMIN = WINDOW(3,TRNCUR)
	YMAX = WINDOW(4,TRNCUR)
C
C write dummy range entry.
	RANGE(1) = 1E38
	RANGE(2) = -1E38
	RANGE(3) = 1E38
	RANGE(4) = -1E38
	CALL IFFSEL(PRIMLUN)
	CALL IFFRA(RANGE)	! create range entry
C ........................................................................
C Next create a blank HIstory record to be filled out by IFFLIB
C
	CALL IFFHI		! add empty history entry
C
C ........................................................................
C Map Header - we output a special map header
	MHDESC(1)=MHLEN/2-1	! length is standard
	CUST    = 1		! state MCE
	PRIM(1) = 'P'
	PRIM(2) = 'R'
	PRIM(3) = 'I'
	PRIM(4) = 'M'
	PRIM_VER = 1		! version 1
	CALL IFFMH(MHARR,MHLEN)
C
C ........................................................................
C
	MATV2 = 2				! version 2 descriptor
	MD2LOC(1) = 0.0D0			! no origin
	MD2LOC(2) = 0.0D0
	MD2SCL = 1000				! scale millimetres
	MD2PRJ = 0				! unset
	MD2UNT = 0				! unset
	CALL IFFMD(MD2ARR,MD2LEN)
C
C ........................................................................
C New Section
C
	CALL IFFNS( %REF(NS), LEN(NS) )
C
C ........................................................................
C Calibration Coefficients - unit transformation
C
	CALL IFFCC ( COEFF )
C
C ........................................................................
C Control points - use the maximum and minimum coordinate values again
C
C Xin
	CPTS(1,1)=XMIN	! NW
	CPTS(1,2)=XMIN	! SW
	CPTS(1,3)=XMAX	! SE
	CPTS(1,4)=XMAX	! NE
C Yin
	CPTS(2,1)=YMAX
	CPTS(2,2)=YMIN
	CPTS(2,3)=YMIN
	CPTS(2,4)=YMAX
C Xout
	CPTS(3,1)=XMIN
	CPTS(3,2)=XMIN
	CPTS(3,3)=XMAX
	CPTS(3,4)=XMAX
C Yout
	CPTS(4,1)=YMAX
	CPTS(4,2)=YMIN
	CPTS(4,3)=YMIN
	CPTS(4,4)=YMAX
C
	CALL IFFCP( CPTS )	! Write the entry
C
	CALL IFFSEL(IFFLUN)
	IFF_STARTED = .TRUE.
	RETURN
	END
C
C
C***********************************************************************
C
C	OUTPUT ATTRIBUTES (Workstation independent primitive attributes)
C	=================
C
C
	SUBROUTINE	GSPLI(INDEX)
C
**	MODULE	GSPLI
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET POLYLINE INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	INDEX			! polyline index
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR	= 0			! no errors yet
	IF (INDEX .LT. 1 .OR. INDEX .GT. PLMAX) GOTO 10
	IF (INDEX .EQ.PLIND) GOTO 20	! if current already, ignore
	PLIND = INDEX			! set it to current index
	UPLIN = .TRUE.		! attributes need updating
	GOTO 20
C
10	GKSERR = 60			! polyline index is invalid
C
20	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSLN(LTYPE)
C
**	MODULE	GSLN
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET LINETYPE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	LTYPE			! linetype
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (LTYPE.LE.0) GOTO 10
	ILTYPE = LTYPE
	UPLIN = .TRUE.		! attributes need updating
	GOTO 20
10	GKSERR = 62			! linetype .LE. 0
20	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GSLWSC(LWIDTH)
C
**	MODULE	GSLWSC
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET LINEWIDTH SCALE FACTOR
C
	IMPLICIT NONE
C
C Arguments:
	REAL	LWIDTH			! linewidth scale factor
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
C
	IF (LWIDTH.LE.0.0) GOTO 10
	ILWID = LWIDTH
	UPLIN = .TRUE.		! attributes need updating
	GOTO 20
10	GKSERR = 90			! linewidth scale factor .LE. 0
20	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GSPLCI(COLI)
C
**	MODULE	GSPLCI
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET POLYLINE COLOUR INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	COLI			! polyline colour index
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (COLI.LT.0) GOTO 10
	ICOLI = COLI
	UPLIN = .TRUE.		! attributes need updating
	GOTO 20
10	GKSERR = 85			! colour index .LT. 0
20	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE	GSASF(LASF)
C
**	MODULE	GSASF
**	IDENT	27NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C Update of fill area required, too	Tony J Ibbs	27-Nov-1984
C
C SET ASPECT SOURCE FLAGS
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
C Arguments:
	INTEGER	LASF(ASFMAX)			! list of flags
C
	INTEGER	I				! loop counter
C
	GKSERR = 0
	DO 11 I=1,ASFMAX
	   GASF(I) = LASF(I)
11	CONTINUE
	UPLIN = .TRUE.		! polyline attributes need updating
	UPFA  = .TRUE.		! also fill area attributes
C
	RETURN
	END
C
C***********************************************************************
C
C	WORKSTATION ATTRIBUTES (Representations)
C	========================================
C
C
	SUBROUTINE	GSPLR(WKID,PLI,LTYPE,LWIDTH,COLI)
C
**	MODULE	GSPLR
**	IDENT	29FE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-Jul-1983
C Colour added					PGH	29-Feb-1984
C
C SET POLYLINE REPRESENTATION
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	PLI			! polyline index
	INTEGER	LTYPE			! linetype
	REAL	LWIDTH			! line width scale factor
	INTEGER	COLI			! colour index
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (PLI .LT. 1 .OR. PLI .GT. PLMAX ) GOTO 10
	IF (LTYPE .LE. 0) GOTO 20
	IF (LWIDTH .LE. 0) GOTO 30
	IF (COLI .LT. 0 ) GOTO 40
	PLTYPE(PLI) = LTYPE		! store values in bundle table
	PLWDTH(PLI) = LWIDTH
	PLCOL(PLI)  = COLI
	IF (PLI .NE. PLIND) GOTO 9999	! apply if current index
	UPLIN = .TRUE.		! attributes need updating
	GOTO 9999
C
10	GKSERR	= 60			! polyine index is invalid
	GOTO 9999
20	GKSERR	= 62			! linetype is invalid
	GOTO 9999
30	GKSERR	= 90			! linewidth scale factor invalid
	GOTO 9999
40	GKSERR	= 86			! colour index is invalid
C
9999	RETURN
C
	END
C
C***********************************************************************
C
C	TRANSFORMATION FUNCTIONS
C	========================
C
C
	SUBROUTINE	GSWN(TRN,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWN
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C Adapted for generation of 'primitive' IFF	JHR	 4-May-1989
C
C SET WINDOW 
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! window number
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	INTEGER TRNTMP			! temporary copy of TRN so as
C					! not to pass back new value.
C
	GKSERR	= 0			! no errors yet
	TRNTMP=TRN+1			! convert to Fortran index
	IF (TRNTMP .LT. 1 .OR. TRNTMP .GT. TRNMAX) GOTO 10
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) GOTO 20
	WINDOW(1,TRNTMP) = XMIN
	WINDOW(2,TRNTMP) = XMAX
	WINDOW(3,TRNTMP) = YMIN
	WINDOW(4,TRNTMP) = YMAX
C
	UPTRN = .TRUE.		! transformation needs updating
	GOTO 30
C
10	GKSERR	= 50			! transformation invalid
	GOTO 30
15	GKSERR = 999			! unexpected end of IFF file
	GOTO 30
20	GKSERR	= 51			! rectangle definition invalid
C
30	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSVP(TRN,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSVP
**	IDENT	27JL83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SET VIEWPORT
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! viewport number
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	INTEGER TRNTMP			! temporary copy of TRN so as
C					! not to pass back new value.
C
	GKSERR	= 0			! no errors yet
	TRNTMP = TRN+1			! convert to Fortran index
	IF (TRNTMP .LT. 1 .OR. TRNTMP .GT. TRNMAX) GOTO 10
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) GOTO 20
	IF (XMIN .LT. 0.0 .OR. XMAX .GT. 1.0 .OR.
     &	    YMIN .LT. 0.0 .OR. YMAX .GT. 1.0) GOTO 30
	VIEWPT(1,TRNTMP) = XMIN
	VIEWPT(2,TRNTMP) = XMAX
	VIEWPT(3,TRNTMP) = YMIN
	VIEWPT(4,TRNTMP) = YMAX
	UPTRN = .TRUE.		! transformation needs updating
	GOTO 40
C
10	GKSERR	= 50		! transformation number invalid
	GOTO 40
20	GKSERR	= 51		! rectangle definition is invalid
	GOTO 40
30	GKSERR	= 53		! viewport not within NDC unit square
C
40	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSWKWN(WKID,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWKWN
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	27-Oct-1983
C
C SET WORKSTATION WINDOW
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) GOTO 20
	IF (XMIN .LT. 0.0 .OR. XMAX .GT. 1.0 .OR.
     &	    YMIN .LT. 0.0 .OR. YMAX .GT. 1.0) GOTO 30
	WSWIN(1) = XMIN
	WSWIN(2) = XMAX
	WSWIN(3) = YMIN
	WSWIN(4) = YMAX
	UPTRN = .TRUE.
	GOTO 9999
C
20	GKSERR	= 51	! rectangle definition is invalid
	GOTO 9999
30	GKSERR	= 53	! workstation window not within NDC unit square
C
9999	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSWKVP(WKID,XMIN,XMAX,YMIN,YMAX)
C
**	MODULE	GSWKVP
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					RD	27-Oct-1983
C
C SET WORKSTATION VIEWPORT
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	REAL	XMIN,XMAX,YMIN,YMAX	! rectangular boundaries
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0
	IF (XMAX .LE. XMIN .OR. YMAX .LE. YMIN) GOTO 20
	IF (((XMAX-XMIN) .GT. DCMAXX) .OR.
     &	    ((YMAX-YMIN) .GT. DCMAXY)) GOTO 30
	WSVIEW(1) = XMIN
	WSVIEW(2) = XMAX
	WSVIEW(3) = YMIN
	WSVIEW(4) = YMAX
	UPTRN = .TRUE.
	GOTO 9999
C
20	GKSERR = 51	! rectangle definition invalid
	GOTO 9999
30	GKSERR = 54	! workstation viewport not within display space
C
9999	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSELNT(TRN)
C
**	MODULE	GSELNT
**	IDENT	27OC83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	27-July-1983
C
C SELECT NORMALISATION TRANSFORMATION
C and set clipping limits to viewport
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	TRN			! transformation number
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	INTEGER TRNTMP		! temporary copy of TRN so as not to
C				! pass back new value
	GKSERR	= 0			! no errors yet
	TRNTMP=TRN+1			! convert to Fortran index
	IF (TRNTMP .LT. 1 .OR. TRNTMP .GT.TRNMAX) GOTO 10
	TRNCUR	= TRNTMP		! set currently selected
C					! normalisation transformation
	UPTRN = .TRUE.			! transformation needs updating
	GOTO 20
C
10	GKSERR	= 50			! transformation number invalid
C
20	RETURN
C
	END
C
C***********************************************************************
C
	SUBROUTINE	GSCLIP(CLSW)
C
**	MODULE	GSCLIP
**	IDENT	31JL84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	31-July-1984
C
C SET CLIPPING INDICATOR
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	CLSW			! clipping indicator
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
	ENCLIP = (CLSW.EQ.GCLIP)
	RETURN
C
	END
C
C***********************************************************************
C
C	INQUIRY FUNCTIONS
C	=================
C
	SUBROUTINE GQASF(ERRIND,LASF)
C
***	MODULE	GQASF
***	IDENT	27NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	 1-May-1984
C Allow up to ASFMAX returns now		TJI	17-Nov-1984
C
C INQUIRE ASPECT SOURCE FLAGS
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	LASF(ASFMAX)	! Aspect source flags
C
	INTEGER	I
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	DO 11 I=1,ASFMAX
	   LASF(I) = GASF(I)
11	CONTINUE
C
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE GQMDS(WTYPE,ERRIND,COOUNI,RX,RY,LX,LY)
C
***	MODULE	GQMDS
***	IDENT	14SE83
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					SCM	14-Sept-1983
C
C INQUIRE MAXIMUM DISPLAY SURFACE SIZE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WTYPE		! Workstation type
	INTEGER	ERRIND		! Error indicator
	INTEGER	COOUNI		! Device Coordinate Units
	REAL	RX,RY		! Max. display surface size in DC
	INTEGER	LX,LY		! no. of device units in X and Y
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	COOUNI = GMETRE		! units are in metres
	RX = DCMAXX	! film size in metres
	RY = DCMAXY
	LX  = 32000		! 6 micron device units
	LY  = 32000
C
999	RETURN
	END
C
C
C***********************************************************************
C
	SUBROUTINE GQPLF(
     &		WTYPE,N,ERRIND,NLT,LT,NLW,NOMLW,RLWMIN,RLWMAX,NPPLI)
C
***	MODULE	GQPLF
***	IDENT	16MY84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	16-May-1984
C
C INQUIRE POLYLINE FACILITIES
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	WTYPE		! Workstation type
	INTEGER	N		! list element requested
	INTEGER	ERRIND		! Error indicator
	INTEGER NLT		! number of available linetypes
	INTEGER	LT		! N'th element of available linetypes
	INTEGER NLW		! number of available linewidths
	REAL	NOMLW		! nominal linewidth (DC)
	REAL	RLWMIN,RLWMAX	! range of linewidths
	INTEGER	NPPLI		! number of predefined polyline indices
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
C this is a grey area regarding the linewidth on Sigma
	NLT = 4			! number of linetypes
	LT = N			! just return N as N'th type
	NLW = 0			! continuous range of linewidths
	NOMLW = GNOMLW		! nominal linewidth in DC
	RLWMIN = NOMLW		! also the minimum
	RLWMAX = 100.0*NOMLW	! rather arbitrary maximum
	NPPLI = PLMAX
C
999	RETURN
	END
C
C
C***********************************************************************
C
	SUBROUTINE GQLN(ERRIND,LTYPE)
C
***	MODULE	GQLN
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE LINETYPE
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	LTYPE		! line type
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	LTYPE = ILTYPE
C
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE GQLWSC(ERRIND,LWIDTH)
C
***	MODULE	GQLWSC
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE LINE WIDTH SCALE FACTOR
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	REAL	LWIDTH		! line width scale factor
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	LWIDTH = ILWID
C
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE GQPLCI(ERRIND,COLI)
C
***	MODULE	GQPLCI
***	IDENT	01MA84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created					CCB	1-May-1984
C
C INQUIRE POLYLINE COLOUR INDEX
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	ERRIND		! Error indicator
	INTEGER	COLI		! polyline colour index
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/CMN:GKSESL/
C
	GKSERR = 0		! inquiry functions can't gen errors
	ERRIND = 0		! only give indications of them !!
C
	COLI = ICOLI
C
	RETURN
	END
C
C***********************************************************************
C
C	GKSLDLIB UTILITIES
C	==================
C
	SUBROUTINE GUPTRN
C
***	MODULE	GUPTRN
***	IDENT	19SE84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	19-Sep-1984
C
C Update the tranformation
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
C
C w/s
	REAL	NDCSCX,NDCSCY	! scaling part of WC to NDC transform
	REAL	NDCOFX,NDCOFY	! offset  part of WC to NDC transform
	REAL	DCSC		! scaling part of NDC to DC transform
	REAL	DCOFX, DCOFY	! offset  part of NDC to DC transform
C
C Work out the scaling factor and offset for WC to NDC transformation.
C Effective formula for transforming a coord is:-
C	XN = XVMIN + (XW-XWMIN) * ((XVMAX-XVMIN)/(XWMAX-XWMIN))
C	YN = YVMIN + (YW-YWMIN) * ((YVMAX-YVMIN)/(YWMAX-YWMIN))
C
C This formula needs to be put into the form:-
C	XN = (XW*NDCSCX) + NDCOFX
C	YN = (YW*NDCSCY) + NDCOFY
C
	NDCSCX = (VIEWPT(2,TRNCUR)-VIEWPT(1,TRNCUR))
     &		/(WINDOW(2,TRNCUR)-WINDOW(1,TRNCUR))
	NDCSCY = (VIEWPT(4,TRNCUR)-VIEWPT(3,TRNCUR))
     &		/(WINDOW(4,TRNCUR)-WINDOW(3,TRNCUR))
	NDCOFX = VIEWPT(1,TRNCUR) - (WINDOW(1,TRNCUR)*NDCSCX)
	NDCOFY = VIEWPT(3,TRNCUR) - (WINDOW(3,TRNCUR)*NDCSCY)
C
C A similar formula has to be used to transform NDC to DC with the
C difference that the shape of the workstation window has to be
C preserved within the workstation viewport (bottom left corner
C is fixed).
	DCSC = MIN(((WSVIEW(2)-WSVIEW(1))
     &		   /(WSWIN (2)-WSWIN (1)))
     &		  ,((WSVIEW(4)-WSVIEW(3))
     &		   /(WSWIN (4)-WSWIN (3))))
	DCOFX = WSVIEW(1) - (WSWIN(1)*DCSC)
	DCOFY = WSVIEW(3) - (WSWIN(3)*DCSC)
C
C Both transformations have to be combined in the form:-
C	XD = (((XW*NDCSCX*DCSC) + (NDCOFX*DCSC)+DCOFX
C	YD = (((YW*NDCSCY*DCSC) + (NDCOFY*DCSC)+DCOFY
C
	SCALEX = NDCSCX * DCSC
	SCALEY = NDCSCY * DCSC
	OFFX = (NDCOFX*DCSC) + DCOFX
	OFFY = (NDCOFY*DCSC) + DCOFY
C
C Work out the clipping limits.
C These correspond to the area of overlap in NDC space between
C the viewport and the workstation window transformations.
C Logical variable CLPALL is set if there is no overlap.
	CLPALL = .FALSE.
C Is there any overlap at all?
	IF ((VIEWPT(1,TRNCUR).GT.WSWIN(2))
     &  .OR.(VIEWPT(2,TRNCUR).LE.WSWIN(1))
     &  .OR.(VIEWPT(3,TRNCUR).GT.WSWIN(4))
     &  .OR.(VIEWPT(4,TRNCUR).LE.WSWIN(3))) GOTO 5
C
C Define the clipping limits to be the overlapping rectangle.
	CLIPLO(1) = MAX(VIEWPT(1,TRNCUR),WSWIN(1))	! W
	CLIPHI(1) = MIN(VIEWPT(2,TRNCUR),WSWIN(2))	! E
	CLIPLO(2) = MAX(VIEWPT(3,TRNCUR),WSWIN(3))	! S
	CLIPHI(2) = MIN(VIEWPT(4,TRNCUR),WSWIN(4))	! N
C
C Transform the clipping limits into WC space so that clipping can
C be done before transforming coordinates. This is not GKS standard.
C To do this we use the formulas:-
C	XW = (XN-NDCOFX) / NDCSCX
C	YW = (YN-NDCOFY) / NDCSCY
C
	CLIPLO(1) = (CLIPLO(1)-NDCOFX) / NDCSCX
	CLIPHI(1) = (CLIPHI(1)-NDCOFX) / NDCSCX
	CLIPLO(2) = (CLIPLO(2)-NDCOFY) / NDCSCY
	CLIPHI(2) = (CLIPHI(2)-NDCOFY) / NDCSCY
	GOTO 20
C
C No overlap
5	CLPALL = .TRUE.
C
C the transformation is now up to date
20	UPTRN = .FALSE.
	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE GUPLIN
C
***	MODULE	GUPLIN
***	IDENT	27NO84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C Take account of need to set UPFA	Tony J Ibbs	27-Nov-1984
C Adapted for generation of 'primitive' IFF	JHR	 9-May-1989
C
C Update the polyline attributes
C
	IMPLICIT NONE
C
C local variables
	INTEGER	NLTYPE,NCOLI,NMTYPE
	REAL	NLWID
C
***	PARAMETER/FPPCMN:EFNLUN/
C
***	COMMON/CMN:GKSDAT1/		! GKS data structures
***	COMMON/LSL$CMNIFF:IFFHAN/
C
	IF (GASF(1).EQ.GBUNDL) THEN
	   NLTYPE = PLTYPE(PLIND)
	ELSE
	   NLTYPE = ILTYPE
	ENDIF
C
	IF (GASF(2).EQ.GBUNDL) THEN
	   NLWID = PLWDTH(PLIND)
	ELSE
	   NLWID = ILWID
	ENDIF
C
	IF (GASF(3).EQ.GBUNDL) THEN
	   NCOLI = PLCOL(PLIND)
	ELSE
	   NCOLI = ICOLI
	ENDIF
C
	IF (NLWID.LE.1.0) NLWID = 0.0	! ie turn off thick lines
	IF (NLWID.NE.CLWID) THEN
	   CLWID = NLWID
	   IF (NLWID.NE.FALWID) UPFA = .TRUE.	! check fill area
	ENDIF
C
	IF (NCOLI.NE.CCOLI) THEN
	   CCOLI = NCOLI
	   UPFA  = .TRUE.			! and fill area update
	ENDIF
C
C set up correct polyline tracked symbol
C split 'marker type' into components
C
	NMTYPE = LSYM-1		! from GESC(1...), start at 0
	CJOIN = NMTYPE/10
	CCAP = NMTYPE - CJOIN*10
C
	IF (CJOIN.GT.2) CJOIN = 0
	IF (CCAP.GT.2) CCAP = 0
C
	UPLIN = .FALSE.		! polyline now up to date
	RETURN
	END
C
C***********************************************************************
C
	LOGICAL FUNCTION GKCLIP(X1,Y1,X2,Y2)
C
***	MODULE	GKCLIP
***	IDENT	23JL80
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Authors many and varied but mainly Paul Hardy based on algorithms
C by P. Woodsford and P.Cross, with tidies by R.Fairbairns
C
C Created July 1980
C
C to clip a straight line to rectangular boundaries.
C function value is TRUE if no visible result.
C
	IMPLICIT NONE
C
	REAL X1,Y1,X2,Y2	! coords of ends of line
C
***	COMMON/CMN:GKSDAT1/		! contains boundaries
C
	PARAMETER X=1,Y=2	! for clarity
C w/s
	REAL P(2,2)		! our copies of the points
	REAL D(2)		! DX,DY is line vector
	REAL R			! temp variable
	INTEGER DEP,INDEP	! X or Y depending which axis considered
	INTEGER HIGH,LOW	! 1 or 2 to indicate ends of line
C
C set everything up
	GKCLIP=.FALSE.			! assume visible result
	P(X,1)=X1			! take copy of args
	P(Y,1)=Y1
	P(X,2)=X2
	P(Y,2)=Y2
	D(X)=X2-X1			! calculate vector
	D(Y)=Y2-Y1
C
C now loop for both axes
	DO 30 DEP=X,Y
	   INDEP=3-DEP			! independent axis
	   LOW=1			! guess which end lowest
	   IF(D(INDEP).LT.0.0) LOW=2	! upside down
	   HIGH=3-LOW			! the other end
	   IF(P(INDEP,HIGH).LT.CLIPLO(INDEP)) GOTO 50 ! out bottom
	   IF(P(INDEP,LOW ).GT.CLIPHI(INDEP)) GOTO 50 ! out top
	   IF(D(INDEP).EQ.0.0) GOTO 30	! parallel to frame this axis
C
C here to consider low end
	   R=P(INDEP,LOW)-CLIPLO(INDEP) ! distance from frame
	   IF(R.GE.0.0) GOTO 20		! inside frame
C
C clip low end
	   P(DEP,LOW)=P(DEP,LOW)-R*D(DEP)/D(INDEP) ! similar triangles
	   P(INDEP,LOW)=CLIPLO(INDEP) ! push onto frame
C
C now lets consider the high end
20	   R=CLIPHI(INDEP)-P(INDEP,HIGH) ! distance from frame
	   IF(R.GE.0.0) GOTO 30		! inside frame
C
C clip high end
	   P(DEP,HIGH)=P(DEP,HIGH)+R*D(DEP)/D(INDEP) ! similar triangles
	   P(INDEP,HIGH)=CLIPHI(INDEP) ! push onto frame
C
30	   CONTINUE			! loop for both axes
C
C copy args back
	X1=P(X,1)
	Y1=P(Y,1)
	X2=P(X,2)
	Y2=P(Y,2)
40	RETURN
C
C here with all invisible
50	GKCLIP=.TRUE.
	GOTO 40
C
	END
C
C***********************************************************************
C
	SUBROUTINE GKSW2D(WKID,WX,WY,DX,DY)
C
***	MODULE	GKSW2D
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created August 1984
C
C To convert world coordinate WX,WY to device coordinate DX,DY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	WX,WY		! input world coordinate
	REAL	DX,DY		! output device coordinate
C
	GKSERR = 0
C
C Make sure transformation is up to date
	IF (UPTRN) CALL GUPTRN
	DX = (WX*SCALEX)+OFFX
	DY = (WY*SCALEY)+OFFY
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKSD2W(WKID,DX,DY,WX,WY)
C
***	MODULE	GKSD2W
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created February 1985
C
C To convert device coordinate DX,DY to world coordinate WX,WY
C on workstation WKID
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
C arguments
	INTEGER	WKID		! worstation identifier
	REAL	DX,DY		! input device coordinate
	REAL	WX,WY		! output world coordinate
C
	GKSERR = 0
C
C Make sure transformation is up to date
	IF (UPTRN) CALL GUPTRN
C
	WX = (DX-OFFX)/SCALEX
	WY = (DY-OFFY)/SCALEY
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GD2W(WKID,DX,DY,WX,WY)
C
***	MODULE	GD2W
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created August 1984
C
C To scale device coordinate lengths DX,DY to world coordinate WX,WY
C on workstation WKID (only one in any case)
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
C arguments
	INTEGER WKID		! for compatibility with 2 workstation
	REAL	DX,DY		! input device coordinate
	REAL	WX,WY		! output world coordinate
C
C Make sure transformation is up to date
	IF (UPTRN) CALL GUPTRN
C
	WX = DX / SCALEX
	WY = DY / SCALEY
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GW2D(WKID,WX,WY,DX,DY)
C
***	MODULE	GW2D
***	IDENT	14MY84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created May 1985
C
C To scale world coordinate lengths WX,WY to device coordinate DX,DY
C on workstation WKID (only one in any case)
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
***	COMMON/CMN:GKSESL/
C
C arguments
	INTEGER WKID		! for compatibility with 2 workstation
	REAL	WX,WY		! input world coordinate
	REAL	DX,DY		! output device coordinate
C
C Make sure transformation is up to date
	IF (UPTRN) CALL GUPTRN
C
	DX = WX*SCALEX
	DY = WY*SCALEY
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKSDAT(DEV,LDARG,USEPC)
C
***	MODULE	GKSDAT
***	IDENT	10AU84
C
C Copyright Laser Scan Laboratories Ltd., Cambridge, England.
C Author: Clarke Brunt
C
C Created April 1985
C
C To set control variables
C
	IMPLICIT NONE
C
***	COMMON/CMN:GKSDAT1/
C
C arguments
	INTEGER DEV		! device number (ignored)
	INTEGER LDARG		! argument for LDINIT
	LOGICAL*1 USEPC		! use PCFRAM rather than DIFRAM
C
C Set things in common block
	INIARG = LDARG
	PC = USEPC
C
	RETURN
	END
C
C *********************************************************************
C
	SUBROUTINE	GESC(ESCID,DATA)
C
**	MODULE	GESC
**	IDENT	12JN86
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	9-May-1986
C
C ESCAPE
C
	IMPLICIT NONE
C
***	COMMON/GFADAT1/
***	COMMON/GKSDAT1/
***	COMMON/GKSESL/
C
C Arguments
	INTEGER ESCID			! escape identifier
	INTEGER	DATA(2)			! other data
C
C Workspace
	INTEGER		IDATA
	REAL		RDATA
	LOGICAL*4	LDATA
	EQUIVALENCE	(IDATA,RDATA,LDATA)
C
	IDATA = DATA(1)	! copy into integer version
C
C Despatch on escape type
	GOTO (100,99,300),ESCID
	GOTO (1000,99,3000),ESCID-100
99	GKSERR = 180			! function not supported
	GOTO 9999
C
C Set 'marker type' for lines (as for GSMK)
100	LSYM = IDATA
	UPLIN = .TRUE.
	GOTO 9999
C
C Set symbol angle (used for markers, and lines if not tangential)
CCC200	SANG = RDATA
CCC	IF (SANG.NE.CANG) THEN
CCC	   UPLIN = .TRUE.
CCC	   UPMAR = .TRUE.
CCC	ENDIF
CCC	GOTO 9999
C
C Set fill area line width and spacing
300	CONTINUE
C
C Zero width will cause the nominal width to be used
C If spacing is less than width, then set a sensible value
C
	IF (RDATA.GE.0.0) GFAWID = RDATA
	IDATA = DATA(2)
	GFAGAP = RDATA
	IF (GFAGAP.LT.GFAWID) GFAGAP = 2.0*GFAWID
	GOTO 9999
C
C Inquire 'marker type' for lines (as for GSMK)
1000	IDATA = LSYM
	GOTO 9000
C
C Inquire symbol angle (used for markers, and lines if not tangential)
CCC2000	RDATA = SANG
CCC	GOTO 9000
C
C Inquire fill area line width and spacing
3000	RDATA = GFAGAP
	DATA(2) = IDATA
	RDATA = GFAWID
C
C Replace argument for inquiries
9000	DATA(1) = IDATA
C
9999	RETURN
	END
