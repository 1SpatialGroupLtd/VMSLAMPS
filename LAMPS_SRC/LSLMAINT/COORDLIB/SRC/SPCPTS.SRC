	SUBROUTINE SPCPTS(IN_POINTS,NUMBER_IN,OUT_POINTS,NUMBER_OUT,
     &                    LOOPED,ERROR)
C
***	IDENT	22OC87
***	MODULE	SPCPTS
C
C	Copyright : Laser-Scan Laboratories Ltd., Cambridge, England
C	Created   : ACM   Vectorise version		 Nov 1985
C	Modified  : DRC   for use in COORDLIB         04 Sep 1987 
C	
C
	IMPLICIT NONE
C
***	PARAMETER/LSL$CMNCOORD:MAXPTS/	! max. no. of points in line
C Arguments
	REAL		IN_POINTS(2,MAXPTS)! line to be regulated
	INTEGER*4	NUMBER_IN	! number of points in line
	REAL		OUT_POINTS(2,MAXPTS)! line after regulation
	INTEGER*4	NUMBER_OUT	! number of pts in OUT_POINTS(
	LOGICAL		LOOPED		! is the line to be looped?
	INTEGER*4	ERROR		! error number
C
C local parameters
	REAL		MINLEN,MAXLEN
	REAL		SQMINLEN,SQMAXLEN
	REAL		RTOL
	PARAMETER(	MINLEN	= 1E-3)
	PARAMETER(	MAXLEN	= 1.0)
	PARAMETER(	SQMINLEN= MINLEN**2)
	PARAMETER(	SQMAXLEN= MAXLEN**2)
	PARAMETER(	RTOL	= 1E-5)
C
C workspace
	INTEGER		I,J,K
	INTEGER		IP
	INTEGER		NDIVS
	REAL		DX,DY
	REAL		LASTDX,LASTDY
	REAL		SQLEN
	LOGICAL		DONE_LOOP	! traversed loops yet?
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	The line returned is the input line with
C	1/ Coincident consecutive pts removed
C	2/ Long segments divided
C	3/ Folding segments cut off
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	DONE_LOOP = .FALSE.
C	First point
	OUT_POINTS(1,1) = IN_POINTS(1,1)
	OUT_POINTS(2,1) = IN_POINTS(2,1)
	NUMBER_OUT = 1
C
	IP = 1
10	IF (IP.EQ.NUMBER_IN.OR.DONE_LOOP) GOTO 60	! end of line
	IP = IP+1
20	DX = IN_POINTS(1,IP)-OUT_POINTS(1,NUMBER_OUT)
	DY = IN_POINTS(2,IP)-OUT_POINTS(2,NUMBER_OUT)
	SQLEN = DX**2+DY**2
	IF (SQLEN.LT.SQMINLEN) GOTO 10
	IF (SQLEN.LT.SQMAXLEN) GOTO 40
C
C add extra pts along segment
	NDIVS = 1+(SQRT(SQLEN)-RTOL)/MAXLEN
	DX = DX/NDIVS
	DY = DY/NDIVS
	DO 30 I = 1,NDIVS-1
	  NUMBER_OUT = NUMBER_OUT+1
	  IF(NUMBER_OUT.GT.MAXPTS) THEN
	    ERROR=1
	    GOTO 999
	  ENDIF
C
	  OUT_POINTS(1,NUMBER_OUT) = OUT_POINTS(1,NUMBER_OUT-1)+DX
	  OUT_POINTS(2,NUMBER_OUT) = OUT_POINTS(2,NUMBER_OUT-1)+DY
30	CONTINUE
C
C check for folding segments
40	IF (NUMBER_OUT.LT.2) GOTO 50
	LASTDX = OUT_POINTS(1,NUMBER_OUT)-OUT_POINTS(1,NUMBER_OUT-1)
	LASTDY = OUT_POINTS(2,NUMBER_OUT)-OUT_POINTS(2,NUMBER_OUT-1)
	IF (ABS(DX*LASTDY-DY*LASTDX).GT.RTOL) GOTO 50
	IF (DX*LASTDX+DY*LASTDY.GT.0) GOTO 50
C
C here if segs are folded, so remove fold by skipping join betw segs
	NUMBER_OUT = NUMBER_OUT-1
	DX = ABS(LASTDX-DX)
	DY = ABS(LASTDY-DY)
	GOTO 40
C
C move on to next pt in P
50	NUMBER_OUT = NUMBER_OUT+1
	IF (NUMBER_OUT.GT.MAXPTS) THEN
	  ERROR=1
	  GOTO 999
	ENDIF
C
	OUT_POINTS(1,NUMBER_OUT) = OUT_POINTS(1,NUMBER_OUT-1)+DX
	OUT_POINTS(2,NUMBER_OUT) = OUT_POINTS(2,NUMBER_OUT-1)+DY
	GOTO 10
C
C here for end of line
60	IF (LOOPED)THEN
	  DX = OUT_POINTS(1,NUMBER_OUT)-OUT_POINTS(1,1)
	  DY = OUT_POINTS(2,NUMBER_OUT)-OUT_POINTS(2,1)
	  IF (DX**2+DY**2.LT.SQMINLEN) THEN
	    NUMBER_OUT = NUMBER_OUT-1	! don't close loop
	  ELSE
	    DONE_LOOP = .TRUE.
	    IP = 1
	    GOTO 20
	  END IF
	ENDIF
C
999	RETURN
C
	END
