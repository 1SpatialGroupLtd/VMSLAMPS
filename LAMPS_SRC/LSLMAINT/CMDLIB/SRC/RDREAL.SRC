	LOGICAL FUNCTION RDREAL(R, CALLERS_HADDOT)
C
***	MODULE	RDREAL
***	IDENT	17SE84
C
	IMPLICIT CHARACTER*1 (A-Z)
C
C Copyright Laser-Scan Laboratories, Ltd., Cambridge, England
C Author  R. Fairbairns
C
C Coded 12.xii.78
C
C To read a real number from the command line
C Deals with 'rational format' and numbers-with-exponents
C Was RDREAL: renamed 3.xii.81 by RF
C
	REAL R
C
C R is to hold the single-length real result
C
	LOGICAL*1 CALLERS_HADDOT	! (optional argument)
C
C CALLERS_HADDOT is set TRUE by the function if a '/' or 'E'
C		 is encountered by us, or a '.' by RDREAL_CMPT
C
C Function result is TRUE if there's no number left on the line
C
	INCLUDE '($SSDEF)/NOLIST'
C
***	COMMON/HERE:CMDCOM/
***	COMMON/LSL$CMNVIO:TXTC/
C
C w/s
	DOUBLE PRECISION NUMTOR, DENTOR	! the parts of the number
	INTEGER*2	SVDCP		! for remembering our position
	INTEGER*2	XPNT		! the exponent
	INTEGER*2	I		! loop variable
	LOGICAL*1	INT_HADDOT	! internal 'had decimal point'
	LOGICAL*1	HADSGN		! 'had sign'
	BYTE		CH		! a character
C
C functions called
	LOGICAL		RDCH		! read a single character
	LOGICAL		RDREAL_CMPT	! read one component
	LOGICAL		RDINT		! read an integer
	LOGICAL		HAVE_I_AN_ARG	! check on optional argument
C
C condition handler
	EXTERNAL	RDCOMM_CHAND
	INTEGER*4	RDCOMM_CHAND
C
C establish handler in our call frame
	CALL LIB$ESTABLISH(RDCOMM_CHAND)
C
C no exception yet
	RDCOMM_EXCP = SS$_NORMAL
C
C initial values
	DENTOR = 1.0D0
	INT_HADDOT = .FALSE.
	HADSGN = .FALSE.
	XPNT = 0
C
C get the numerator
	RDREAL = RDREAL_CMPT(NUMTOR, HADSGN, INT_HADDOT)
	SVDCP = DCPTR
	IF (RDREAL) GOTO 20
C
C look for a rational-format number
	IF (RDCH(CH)) GOTO 20
	IF (CH.NE.'/') GOTO 10
	IF (.NOT.RDCH(CH)) THEN		! check followed by numeral
	   CALL BSCH			! over the putative numeral
	   IF (CH.LT.'0' .OR. CH.GT.'9') THEN ! not a numeral
	      CALL BSCH			! over the '/'
	      GOTO 10			! it's not rational format -
C					!  must be a switch or something
	   ENDIF
	ENDIF
	HADSGN = .TRUE.
	IF (RDREAL_CMPT(DENTOR, HADSGN, INT_HADDOT)) GOTO 80
	INT_HADDOT = .TRUE.
C
C prepare to look for exponent
	IF (RDCH(CH)) GOTO 20
	SVDCP = DCPTR
C
C look for exponent (NB the & is for compatibility with S T R E T C H)
10	IF (CH.NE.'E'.AND.CH.NE.'e'.AND.CH.NE.'&') GOTO 20
	IF (RDINT(XPNT)) GOTO 20
	INT_HADDOT = .TRUE.
	SVDCP = DCPTR
C
C return result
20	NUMTOR = NUMTOR/DENTOR
	IF (.NOT.RDCOMM_EXCP) GOTO 70
	IF (XPNT) 30,70,50
C
C negative exponent
30	DO 40 I = 1,-XPNT
	   NUMTOR = NUMTOR*0.1D0
	   IF (.NOT.RDCOMM_EXCP) GOTO 70
40	CONTINUE
	GOTO 70
C
C positive exponent
50	DO 60 I = 1,XPNT
	   NUMTOR = NUMTOR*10.0D0
	   IF (.NOT.RDCOMM_EXCP) GOTO 70
60	CONTINUE
C
C zero exponent joins - was there a failure somewhere?
70	IF (.NOT.RDCOMM_EXCP) THEN
	   RDREAL = .TRUE.		! mark failure -
C					! NB format of NUMTOR
C					!    may be invalid
	ELSE
	   R = NUMTOR			! return result
	ENDIF
C
C does caller want HADDOT?
	IF (.NOT.RDREAL .AND. INT_HADDOT .AND. HAVE_I_AN_ARG(2))
     &                      CALLERS_HADDOT = .TRUE.
C
C tidy up pointer and, go
	DCPTR = SVDCP
C
C force result zero if any error
	IF (RDREAL) R = 0.0
	RETURN
C
C failed to read denominator - force 'floating overflow' error
80	ERRNUM = ERRFDV
	RDCOMM_EXCP = SS$_FLTDIV
	GOTO 10
C
	END
