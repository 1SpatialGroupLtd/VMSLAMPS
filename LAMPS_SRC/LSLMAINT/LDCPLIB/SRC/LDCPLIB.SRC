C
C Copyright Laser Scan Laboratories Limited, Cambridge, England
C Author R.Daly.
C
C Pseudo LDLIB to produce CALCOMP output 
C
C Third argument to LDINIT sets WTYPE, which is bit set, and controls
C whether SHEET or ROLL plotter (advance at end or not), and initial
C pen position (BENSON is min x, max y  CALCOMP is min x, min y)
C
C Plotter units are assumed to be mm
C
	SUBROUTINE LINTO(X,Y)
C
***	MODULE	LINTO
***	IDENT	19FE91
C
	IMPLICIT NONE
	ENTRY DRAWTO(X,Y)
***	COMMON/CALLIB/
	REAL	X,Y
	CURX=(X*SCALE)+OX
	CURY=(Y*SCALE)+OY
C Do we want to use a line pattern?
	IF (LINPAT) THEN
	   CALL CPPGEN(CURX,CURY)
	ELSE
	   CALL GENLIN(CURX,CURY)
	ENDIF
	RETURN
	END
C
	SUBROUTINE LINBY(X,Y)
C
***	MODULE	LINBY
***	IDENT	23MR82
	IMPLICIT NONE
C
	ENTRY DRAWBY(X,Y)
***	COMMON/CALLIB/
	REAL	X,Y
	CURX=CURX+(X*SCALE)
	CURY=CURY+(Y*SCALE)
C Do we want to use a line pattern?
	IF (LINPAT) THEN
	   CALL CPPGEN(CURX,CURY)
	ELSE
	   CALL GENLIN(CURX,CURY)
	ENDIF
	RETURN	
	END
C
	SUBROUTINE MOVTO(X,Y)
C
***	MODULE	MOVTO
***	IDENT	23MR82
	IMPLICIT NONE
C
	ENTRY MOVETO(X,Y)
***	COMMON/CALLIB/
***	COMMON/CPPGWS/
	REAL	X,Y
	REAL	NEWX,NEWY
	NEWX=(X*SCALE)+OX
	NEWY=(Y*SCALE)+OY
C If line pattern being used then set variables up for next line.
	IF (LINPAT) THEN
	   LASTX=NEWX
	   LASTY=NEWY
	   DREPOS=0
	   DDCSTG=4
	   DDCRES=0.0
	ENDIF
	IF (NEWX.NE.CURX.OR.NEWY.NE.CURY) THEN
	   CURX = NEWX
	   CURY = NEWY
	   CALL GENMOV(CURX,CURY)
	ENDIF
	RETURN
	END
C
	SUBROUTINE MOVBY(X,Y)
C
***	MODULE	MOVBY
***	IDENT	23MR82
	IMPLICIT NONE
C
	ENTRY MOVEBY(X,Y)
***	COMMON/CALLIB/
***	COMMON/CPPGWS/
	REAL	X,Y
	REAL	NEWX,NEWY
	NEWX=X*SCALE
	NEWY=Y*SCALE
C If line patterns being used then set up variables for next line.
	IF (LINPAT) THEN
	   LASTX=CURX+NEWX
	   LASTY=CURY+NEWY
	   DREPOS=0
	   DDCSTG=4
	   DDCRES=0.0
	ENDIF
	IF (NEWX.NE.0.0.OR.NEWY.NE.0.0) THEN
	   CURX=CURX+NEWX
	   CURY=CURY+NEWY
	   CALL GENMOV(CURX,CURY)
	ENDIF
	RETURN
	END
C
	SUBROUTINE GENLIN(X,Y)
C
***	MODULE	GENLIN
***	IDENT	26SE83
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL X,Y
	REAL XP,YP
	INTEGER*4 PENDWN
	PARAMETER (PENDWN=2)
C Now plot the line.
	CALL LDCPTR(X,Y,XP,YP)
	CALL PLOT(XP,YP,PENDWN)
	RETURN
	END
C
	SUBROUTINE GENMOV(X,Y)
C
***	MODULE	GENMOV
***	IDENT	26SE83
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL X,Y
	REAL XP,YP
	INTEGER*4 PENUP
	PARAMETER (PENUP=3)
C Now plot the line (with the pen up).
	CALL LDCPTR(X,Y,XP,YP)
	CALL PLOT(XP,YP,PENUP)
	RETURN
	END
C
	SUBROUTINE LDINIT(N,LUN,TYPE)
C
***	MODULE	LDINIT
***	IDENT	29APR5
C
	IMPLICIT NONE
***	COMMON/CALCMP/
***	COMMON/CALLIB/
	INTEGER N,LUN,TYPE
	INTEGER*4 LUNI4
	LOGICAL	HAVE_I_AN_ARG		! VIOLIB function
	INTEGER*4 ENDPLT
	PARAMETER (ENDPLT=999)
C Beginning or end?
	IF (N.EQ.0) GOTO 9
	LINPAT=.FALSE.
	MAXX=-1000000.0
	CURX=0.0
	CURY=0.0
	OX=0.0
	OY=0.0
	SCALE=1.0/UNIT
	HEIGHT=0.25*SCALE
	ANGLE=0.0
	CX=0.3*SCALE
	CY=0.0
	IF (HAVE_I_AN_ARG(2)) THEN
	   LUNI4=LUN			! take lun from second argument
	ELSE
	   LUNI4=CALLUN			! use lun in common
	ENDIF
	IF (HAVE_I_AN_ARG(3)) THEN
	   WTYPE=TYPE-100
	ELSE
	   WTYPE=0
	ENDIF
	CALL PLOTS(0,0,LUNI4)
	RETURN
C End of plot - move paper on 2cms past x-limit of plot if roll
C End of plot - return to origin in sheet version
9	CONTINUE
	CALL NEWPEN(1)			! select pen 1
	IF ((WTYPE.AND.SHEET).NE.0) THEN
	   CALL PLOT(0.0,0.0,ENDPLT)	! return to origin
	ELSE
	   IF (MAXX.EQ.-1000000.0) MAXX=0.0	! has MAXX been set.
	   CALL PLOT(MAXX+2,0.0,ENDPLT)	! move on 2cms to finish off.
	ENDIF
	RETURN
	END
C
	SUBROUTINE DISMOD(N)
C
***	MODULE	DISMOD
***	IDENT	23MR82
C
	IMPLICIT NONE
	INTEGER N
	IF (N.EQ.0) GOTO 1
	TYPE *,'LDCPLIB - Illegal display mode'
1	RETURN
	END
C
	SUBROUTINE ORIGIN(X,Y,N)
C
***	MODULE	ORIGIN
***	IDENT	23MR82
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL	X,Y
	INTEGER N
	IF (N.NE.-1) GOTO 1
C absolute device units
	OX=X/UNIT
	OY=Y/UNIT
	GOTO 5
1	IF (N.NE.-2) GOTO 2
C absolute user units
	OX=X*SCALE
	OY=Y*SCALE
	GOTO 5
2	IF (N.NE.0) GOTO 3
C user units relative to origin
	OX=OX+(X*SCALE)
	OY=OY+(Y*SCALE)
	GOTO 5
3	IF (N.NE.1) GOTO 4
C user units relative to pen position
	OX=CURX+(X*SCALE)
	OY=CURY+(Y*SCALE)
	GOTO 5
4	TYPE *,'LDCPLIB - Illegal origin type'
5	RETURN
	END
C
	SUBROUTINE UNITS(F)
C
***	MODULE	UNITS
***	IDENT	23MR82
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL F
	SCALE=F/UNIT		! work with mm device coords
	RETURN
	END
C
	SUBROUTINE LDFPPM(N,F1,F2,F3)
C
***	MODULE	LDFPPM
***	IDENT	25NO83
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	INTEGER	N
	REAL	F1,F2,F3
C
	IF (N.NE.1) GOTO 10
	F1=1.0			! current intensity level.
	F2=(CURX-OX)/SCALE	! current beam position in user units.
	F3=(CURY-OY)/SCALE
	GOTO 100
C
10	IF (N.NE.4) GOTO 20
	F1=0.0			! null (unused).
	F2=A0SIZX*UNIT		! size of paper (device units)
	F3=A0SIZY*UNIT
	GOTO 100
C
20	TYPE *,'LDCPLIB - Illegal LDFPPM'
100	RETURN
	END
C
	SUBROUTINE PRTCHR(N)
C
***	MODULE	PRTCHR
***	IDENT	19MY83
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	INTEGER*2 N
	CALL PLTCHR(N)
	CURX=CURX+CX
	CURY=CURY+CY
	RETURN
	END
C
	SUBROUTINE PLTCHR(N)
C
***	MODULE	PLTCHR
***	IDENT	01MR84
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	INTEGER*2 N
	INTEGER*4 NI4
	REAL XP,YP
C
	NI4=N
C Make lower case upper case (only if a Benson for now)
	IF ((NI4.GE.128)) GOTO 9
	IF ((WTYPE.AND.BENSON).NE.0) THEN
	   IF ((NI4.GE.97).AND.(NI4.LE.122)) NI4=NI4-32
	ENDIF
	CALL LDCPTR(CURX,CURY,XP,YP)
	CALL SYMBOL(XP,YP,HEIGHT,CHAR(NI4),0,ANGLE,1)
	RETURN
9	TYPE *,'LDCPLIB - Illegal character'
	RETURN
	END
C
	SUBROUTINE CHARZ(TEXT)
C
***	MODULE	CHARZ
***	IDENT	23MR82
	IMPLICIT NONE
C
	BYTE TEXT(80)
	INTEGER I,N
	I=0
1	I=I+1
	N=TEXT(I)
	N=(N.AND."177)
	IF (N.EQ.0) RETURN
	CALL PRTCHR(N)
	GOTO 1
	END
C
	SUBROUTINE CHARS(STRING)
C
***	MODULE	CHARS
***	IDENT	04SE85
	IMPLICIT NONE
C
***	COMMON/CALLIB/
C
	CHARACTER*(*)	STRING
	INTEGER		I,PTR
	INTEGER*4	NI4
	REAL		XP,YP
	CHARACTER*255	STR
C
CCC Changed CHARS to output the characters in one go in the interests
CCC of efficiency, CHARZ etc. left alone. Some change in character
CCC spacing may be caused.
CCC Clarke Brunt 19-Feb-91
CCC
CCC	DO 10 I=1,LEN(STRING)
CCC	   CALL PRTCHR(ICHAR(STRING(I:I)))
CCC10	CONTINUE
C
	PTR = 0
	DO 10 I=1,LEN(STRING)
	   NI4=ICHAR(STRING(I:I))
C Make lower case upper case (only if a Benson for now)
	   IF ((NI4.GE.128)) THEN
	      TYPE *,'LDCPLIB - Illegal character'
	      GOTO 10
	   ENDIF
	   IF ((WTYPE.AND.BENSON).NE.0) THEN
	      IF ((NI4.GE.97).AND.(NI4.LE.122)) NI4=NI4-32
	   ENDIF
	   IF (PTR.EQ.255) GOTO 10
	   PTR = PTR+1
	   STR(PTR:PTR) = CHAR(NI4)
10	CONTINUE
	IF (PTR.GT.0) THEN
	   CALL LDCPTR(CURX,CURY,XP,YP)
	   CALL SYMBOL(XP,YP,HEIGHT,STR,0,ANGLE,PTR)
	   CURX=CURX+PTR*CX
	   CURY=CURY+PTR*CY
	ENDIF
	RETURN
	END
C
	SUBROUTINE CHSIZE(HIGHT,CX1,CY1)
C
***	MODULE	CHSIZE
***	IDENT	23MR82
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL CX1,CY1,HIGHT
	ANGLE=ATAN2(CY1,CX1)*180./3.141592
	IF (ANGLE.LT.0) ANGLE=ANGLE+360.
	CX=CX1*SCALE
	CY=CY1*SCALE
	HEIGHT=HIGHT*SCALE
	RETURN
	END
C
	SUBROUTINE THICK(NESS)
C
***	MODULE	THICK
***	IDENT	23MR82
	IMPLICIT NONE
C
	REAL NESS
	ENTRY FANCY(BLA,BLAH,BLAR,BLAF)
	INTEGER BLA
	REAL BLAH,BLAR,BLAF
	RETURN
	END
C
	SUBROUTINE DIFRAM(NULL)
	ENTRY	   PCFRAM(NULL1)
C
***	MODULE	DIFRAM
***	IDENT	23MR82
	IMPLICIT NONE
C
***	COMMON/CALCMP/
***	COMMON/CALLIB/
C
	INTEGER NULL
	REAL	NULL1
	INTEGER PENUP
	PARAMETER (PENUP=3)
C
	CALL NEWPEN(1)			! select pen 1
	IF ((WTYPE.AND.SHEET).NE.0) THEN
	   CALL PLOT(0.0,0.0,-PENUP)	! return to origin
	ELSE
	   IF (MAXX.EQ.-1000000.0) MAXX=0.0	! has MAXX been set.
	   CALL PLOT(MAXX+2,0.0,-PENUP)	! move on 2cms to finish off.
	ENDIF
	RETURN
	END
C
	SUBROUTINE HRDMOD(NULL)
C
***	MODULE	HRDMOD
***	IDENT	23MR82
	IMPLICIT NONE
C
	INTEGER NULL
	RETURN
	END
C
	SUBROUTINE CHFONT(NULL1,NULL2,NULL3)
C
***	MODULE	CHFONT
***	IDENT	23MR82
	IMPLICIT NONE
C
	INTEGER NULL1,NULL2,NULL3
	RETURN
	END
C
	SUBROUTINE LDFLSH
C
***	MODULE	LDFLSH
***	IDENT	23MR82
	IMPLICIT NONE
C
	RETURN
	END
C
	SUBROUTINE DASHED(LPTYPE,D,D1,D2)
C
***	MODULE	DASHED
***	IDENT	14JN83
	IMPLICIT NONE
C
***	COMMON/CALLIB/
***	COMMON/CPPGWS/
	INTEGER LPTYPE
	REAL D,D1,D2
	INTEGER	I
	LINPAT=.TRUE.
C Are we setting or unsetting line patterns.
	IF (LPTYPE.EQ.0) GOTO 30
C Set up the line pattern.
	DDCSTG=4
	LASTX=CURX
	LASTY=CURY
C Check line pattern parameters are set up so that CPPGEN
C will not loop infinitely on a period length of 0.
	IF (D.GT.0.0) GOTO 10
	TYPE *,'LDCPLIB - No line pattern parameters set up'
	D=2		! default pattern parameters.
	D1=1
	D2=0.5
10	DDCMAJ=D1*SCALE
	DDCMIN=D2*SCALE
	DDCGAP=AMAX1(0.5*(D-D1-D2),0.0)*SCALE
	DREPOS=0
	DSUBTP=0
	DSUBTL=0
	DO 20 I=1,2
	   DREPCT(I)=0
	   DSUBSP(I)=0
	   DSUBSL(I)=0
20	CONTINUE
	DDCRES=0.0
	RETURN
C Unset line pattern.
30	LINPAT=.FALSE.
	RETURN
	END
C
	SUBROUTINE DOTTED(NULL1)
C
***	MODULE	DOTTED
***	IDENT	23MR82
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	INTEGER NULL1
C Unset line pattern.
	LINPAT=.FALSE.
	RETURN
	END
C
	SUBROUTINE LDCMPL
C
***	MODULE	LDCMPL
***	IDENT	06MY83
	IMPLICIT NONE
C
	RETURN
	END
C
	SUBROUTINE LDWAIT
C
***	MODULE	LDWAIT
***	IDENT	06MY83
	IMPLICIT NONE
C
	RETURN
	END
C
	SUBROUTINE PEN(NUMBER)
C
***	MODULE	PEN
***	IDENT	01JN83
	IMPLICIT NONE
C
	INTEGER*2 NUMBER
	INTEGER*4 NUMBI4
C
	NUMBI4=NUMBER
	CALL NEWPEN(NUMBI4)
C
	RETURN
	END
C
	SUBROUTINE LDCPTR(X,Y,XP,YP)
C
***	MODULE	LDCPTR
***	IDENT	26FE86
	IMPLICIT NONE
C
***	COMMON/CALLIB/
	REAL	X,Y,XP,YP
C
C transform coordinate, depending on whether initial pen position
C was minx,miny (usual Calcomp) or minx,maxy (usual Benson)
	XP = X+HLFA0X
	IF (MAXX.LT.XP) MAXX=XP		! accumulate maximum x
	IF ((WTYPE.AND.BENSON).NE.0) THEN
	   YP = Y-HLFA0Y
	ELSE
	   YP = Y+HLFA0Y
	ENDIF
	RETURN
	END
