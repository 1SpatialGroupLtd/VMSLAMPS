	LOGICAL FUNCTION RDFANG( LARGE, TENTH, HEMI, RESULT )
C
***	IDENT	08NO83
***	MODULE	RDFANG
C
C	Copyright LaserScan Laboratories Ltd., Cambridge, England
C
C Author TJ Ibbs, 22 March 1983
C Modified CC Brunt, 10 October 1983 (TENTH arg added)
C Modified CC Brunt, 27 October 1983 (HEMI arg added)
C
C To read a fixed format angle from TXTC the current text buffer
C returning TRUE if an error occurs, FALSE if it all works
C
C The different forms are:
C			[D]DDMMSS[.S][H]	where H is hemisphere
C
C if LARGE then 3 digit degrees, if TENTH then have TENTH seconds
C if HEMI then has a hemisphere letter
C
	IMPLICIT NONE
C
C parameters - hemisphere letters
C
	PARAMETER	POSN = 'N'
	PARAMETER	POSE = 'E'
	PARAMETER	NEGS = 'S'
	PARAMETER	NEGW = 'W'
C
C we call
C
	LOGICAL		RDCH	! read a char, exact
	LOGICAL		RDINT	! read a number (int*2)
	LOGICAL		RDREAL	! read a real number
C
C we were passed
C
	LOGICAL		LARGE	! true if we have 3 digit degrees
	LOGICAL		TENTH	! true if decimal seconds
	LOGICAL		HEMI	! true if hemisphere letter
C
C and we return
C
	INTEGER*4	RESULT	! in tenths of a second
C
C and workspace is
C
	INTEGER*4	ACCUM	! accumulate angle in here
	INTEGER*2	NUM	! a number
	INTEGER*4	NUMBER	! a bigger number
	REAL		RNUM	! a real number
	BYTE		CHAR	! a character
	INTEGER*2	DCP1,DCP2	! decode pointer saves
	INTEGER*2	LENGTH	! expected no. of chars
C
	EQUIVALENCE	(NUM,NUMBER)
C
C
	RDFANG = .TRUE.		! be pessimistic
	NUMBER = 0		! make sure upper two bytes are zero
	CALL DCPSAV( DCP1 )	! decode pointer on entry
C
C deal with degrees first...
C
C the degrees field occupies the next 2 or 3 characters
C
C we want to concern ourselves with the next few characters alone, so
C we set a window from this position onwards
C
	IF (LARGE) THEN
	   CALL SETWIN( ,3 )		! 3 digits
	   LENGTH = 7
	ELSE
	   CALL SETWIN( , 2 )		! 2 digits
	   LENGTH = 6
	ENDIF
C
C and read the degrees
C
	IF ( RDINT(NUM) ) THEN
	   CALL EXPAND('*** Degrees field of angle blank/missing')
	   CALL WRITAP(' - angle abandoned')
	   RETURN
	ENDIF
C
C and accumulate our result...
C
	ACCUM = NUMBER * 36000		! in tenths of a second
C
C we now want to deal with the next field - the minutes
C
	CALL SETWIN( ,2 )		! 2 digits
C
	IF ( RDINT(NUM) ) THEN
	   CALL EXPAND('*** Minutes field of angle blank/missing')
	   CALL WRITAP(' - angle abandoned')
	   RETURN
	ENDIF
C
C and accumulate...
C
	ACCUM = ACCUM + NUMBER*600	! in tenths of a second
C
C lastly (for numbers) we have the seconds field
C
	IF (TENTH) THEN
	   CALL SETWIN( ,4 )		! 4 characters
	   LENGTH = LENGTH + 2
	ELSE
	   CALL SETWIN( ,2 )		! 2 characters
	ENDIF
C
	IF ( RDREAL(RNUM) ) THEN
	   CALL EXPAND('*** Seconds field of angle blank/missing')
	   CALL WRITAP(' - angle abandoned')
	   RETURN
	ENDIF
C
C otherwise, accumulate this too
C
	ACCUM = ACCUM + (RNUM*10.0)	! again, tenths of a second
C
	CALL SETWIN( , )		! unset our window constraints
C
C Now check the decode pointer
C
	CALL DCPSAV( DCP2 )
	IF ( (DCP2-DCP1).NE.LENGTH ) THEN
	   CALL TTWSTR('*** Error reading angle - angle abandoned')
	   RETURN
	ENDIF
C
	IF (HEMI) THEN
C
C now we must inspect what hemisphere the angle is in, to decide
C whether it should be positive or negative
	   IF ( RDCH(CHAR) ) THEN
	      CALL EXPAND('*** No hemisphere character found in angle')
	      CALL WRITAP(' (found ''%C'') - angle abandoned',CHAR)
	      RETURN
	   ENDIF
C
C is it a negative type hemisphere, then?
C
	   IF ( CHAR.EQ.NEGS .OR. CHAR.EQ.NEGW ) THEN
	      ACCUM = -ACCUM		! was negative
	   ELSE IF ( CHAR.NE.POSN .AND. CHAR.NE.POSE ) THEN
	      CALL EXPAND('*** Unrecognised hemisphere letter in angle')
	      CALL WRITAP(' (letter ''%C'') - angle abandoned',CHAR)
	      RETURN
	   ENDIF
C
	ENDIF
C
C so we have a sensible (?) angle - return it to the user
C
	RESULT = ACCUM
	RDFANG = .FALSE.
C
	RETURN
	END
