C
C * This file is part of the LAMPS distribution, released as a software
C * preservation project to archive digital history for future historians.
C * Copyright (c) 1980-2002 Laser-Scan Ltd, 1Spatial Group Ltd
C *
C * Timestamp of this file for the 2002 release was: 2001-12-21 10:25:32.000000000 +0000
C *
C * This program is free software: you can redistribute it and/or modify
C * it under the terms of the GNU General Public License as published by
C * the Free Software Foundation, version 3.
C *
C * This program is distributed in the hope that it will be useful, but
C * WITHOUT ANY WARRANTY; without even the implied warranty of
C * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
C * General Public License for more details.
C *
C * You should have received a copy of the GNU General Public License
C * along with this program. If not, see http://www.gnu.org/licenses/.
C
C
C Text functions
C ==============
C
C *********************************************************************
C
C   	TEXT OUTPUT PRIMITIVE
C	=====================
C
C
	SUBROUTINE	GTX(PX,PY,STRING)
C
**	MODULE	GTX
**	IDENT	21DE01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	24-Jul-1985
C
C TEXT
C
	IMPLICIT NONE
C
C Arguments:
C
	REAL	PX			! X coord
	REAL	PY			! Y coord
	CHARACTER*(*) STRING		! text
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
***	PARAMETER/DDSC/
***	COMMON/GKSDAT2/
***	COMMON/GKSDECW/
***	COMMON/GKSESL/
C
C Workspace
	RECORD	/DDSC/	CSTR
	INTEGER	CLEN
	REAL	DX,DY			! device coordinate
	INTEGER	IX,IY			! pixel coordinates
	REAL	RX,RY			! PostScript coords
	INTEGER	DEV
C
	IF (GKS_INUSE) CALL GKS_CALL(%VAL(GKS_ADDR(XGTX)))
C
	GKSERR	= 0			! no error (yet!)
C
C draw the text on the workstations
	DO 200 DEV = 1,WSMAX
C
C is this workstation active? - if not ignore it
	IF (.NOT.WSACT(DEV)) GOTO 200
C
C ensure that our transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)	! update it
C
C is everything clipped (ie nothing visible)
	IF (CLPALL(DEV)) GOTO 200
C
C Make sure text attributes are up to date
	IF (UPTX(DEV)) CALL GUPTX(DEV)
C
	CALL GKSW2D(WKIDS(DEV),PX,PY,DX,DY)
C
	RX = DX/GNOMLW
	RY = DY/GNOMLW
	IX = INT(RX)
	IY = INT(DCMAXY(DEV)/GNOMLW - RY)
C
C If not display PostScript, then X hardware text will be used,
C so if LSL$COMPOSITE_CHARACTERS, process the string to approximate
C composites by first letter of name
	IF (XDPSC(DEV).EQ.0.AND..NOT.XUSE_TEXT_RENDER) THEN
	   CALL STR$GET1_DX(LEN(STRING),CSTR)
	   IF (ICHCOMP) THEN
	      CALL GKS_PROCESS_COMP(CSTR,STRING,CLEN)
	      CALL STR$LEFT(CSTR,CSTR,CLEN)
	   ELSE
	      CALL STR$COPY_DX(CSTR,STRING)
	   ENDIF
	ENDIF
C
C mark about to do some DPS output
	AST_ON = AST_ON+1
	IF (XDPSC(DEV).NE.0.AND..NOT.XUSE_TEXT_RENDER) XDPS_DONE(DEV) = .TRUE.
	IF (XPIXMAP(DEV).NE.0) THEN
	  IF (XDPSC(DEV).NE.0.OR.XUSE_TEXT_RENDER) THEN
	    CALL GKS_SHOW_STRING(DEV,XPIXMAP(DEV),XDPSC(DEV),RX,RY,STRING)
	  ELSE
	    CALL X$DRAW_STRING(
     &			       XDISPLAY,XPIXMAP(DEV),XGC(1,DEV),
     &			       IX,IY,CSTR)
	  ENDIF
	ENDIF
	IF (XMODE.NE.0.OR.XPIXMAP(DEV).EQ.0) THEN
	  IF (XDPSC(DEV).NE.0.OR.XUSE_TEXT_RENDER) THEN
C
	    IF (XPIXMAP(DEV).NE.0) CALL GWRAP_CHANGE_DRAWABLE(
     &		%VAL(XDPSC(DEV)),%VAL(XWINDOW(DEV)))
	    CALL GKS_SHOW_STRING(DEV,XWINDOW(DEV),XDPSC(DEV),RX,RY,STRING)
	    IF (XPIXMAP(DEV).NE.0) CALL GWRAP_CHANGE_DRAWABLE(
     &		%VAL(XDPSC(DEV)),%VAL(XPIXMAP(DEV)))
	  ELSE
	    CALL X$DRAW_STRING(XDISPLAY,XWINDOW(DEV),XGC(1,DEV),
     &			       IX,IY,CSTR)
	  ENDIF
	ELSE
C
C accumulate the number of lines drawn, and perhaps flush out
	  XLINES(DEV) = XLINES(DEV)+10*LEN(STRING)
	  IF (XLINES(DEV).GT.XLMAX) CALL GUWK(WKIDS(DEV),0)
	ENDIF
	AST_ON = AST_ON-1
	IF (XDPSC(DEV).EQ.0) CALL STR$FREE1_DX(CSTR)
C
200	CONTINUE
	RETURN
	END
C
C
C***********************************************************************
C
	SUBROUTINE	GSTXCI(COLI)
C
**	MODULE	GSTXCI
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET TEXT COLOUR INDEX
C (Don't bother with aspect source flags for now)
C
	IMPLICIT NONE
C
C Arguments:
	INTEGER	COLI			! text colour index
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C workspace
C
C workspace
	INTEGER	DEV
C
	IF (GKS_INUSE) CALL GKS_CALL(%VAL(GKS_ADDR(XGSTXCI)))
C
	GKSERR = 0
	IF (COLI.LT.0) GOTO 10
	ITXCOL = COLI
	DO 5 DEV=1,WSMAX
	   UPTX(DEV) = .TRUE.		! attributes need updating
5	CONTINUE
	GOTO 20
10	GKSERR = 85			! colour index .LT. 0
20	RETURN
	END
C
	SUBROUTINE	GSCHXP(CHXP)
C
**	MODULE	GSCHXP
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET CHARACTER EXPANSION FACTOR
C (Don't bother with aspect source flags for now)
C
	IMPLICIT NONE
C
C Arguments:
	REAL	CHXP		! character expansion factor
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	GKSERR = 0
	IF (CHXP.LE.0.0) GOTO 10
C
C ignore for now
	GOTO 999
C
10	GKSERR = 72			! expansion factor .le.0
999	RETURN
	END
C
	SUBROUTINE	GSCHSP(CHSP)
C
**	MODULE	GSCHSP
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET CHARACTER SPACING
C (Don't bother with aspect source flags for now)
C
	IMPLICIT NONE
C
C Arguments:
	REAL	CHSP		! character expansion factor
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	GKSERR = 0
C
C ignore for now
	RETURN
	END
C
	SUBROUTINE	GSCHH(HGT)
C
**	MODULE	GSCHH
**	IDENT	09JA96
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET CHARACTER HEIGHT
C
	IMPLICIT NONE
C
C Arguments:
	REAL	HGT			! height (w.c.)
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C workspace
	INTEGER	DEV
C
	IF (GKS_INUSE) CALL GKS_CALL(%VAL(GKS_ADDR(XGSCHH)))
C
	GKSERR = 0
	IF (HGT.LE.0) GOTO 10
C
	ICHH = HGT
	DO 200 DEV = 1,WSMAX
	   UPTX(DEV) = .TRUE.		! attributes need updating
200	CONTINUE
	GOTO 999
C
10	GKSERR = 73			! character height .le.0
999	RETURN
	END
C
	SUBROUTINE	GSCHUP(CUX,CUY)
C
**	MODULE	GSCHUP
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET CHARACTER UP VECTOR
C
	IMPLICIT NONE
C
C Arguments:
	REAL	CUX,CUY			! vector (w.c.)
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
	INTEGER	DEV
	REAL	HX,HY,ANGLE
C
	IF (GKS_INUSE) CALL GKS_CALL(%VAL(GKS_ADDR(XGSCHUP)))
C
	GKSERR = 0
	IF (CUX.EQ.0.0.AND.CUY.EQ.0.0) GOTO 10
C
C for each workstation
	DO 200 DEV = 1,WSMAX
	IF (WKIDS(DEV).LT.0) GOTO 200	! not open
C
C ensure that our transformation is up to date
	IF (UPTRN(DEV)) CALL GUPTRN(DEV)	! update it
C
	CALL GW2D(WKIDS(DEV),CUX,CUY,HX,HY)
	ICHANG = ATAN2(-HX,HY)
	UPTX(DEV) = .TRUE.		! attributes need updating
C
200	CONTINUE
C
	GOTO 999
C
10	GKSERR = 74			! vector length is 0.0
999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE	GSTXFP(FNT,PREC)
C
**	MODULE	GSTXFP
**	IDENT	26AP84
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C SET TEXT FONT & PRECISION
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Arguments:
	INTEGER	FNT,PREC
C
	INTEGER	DEV
C
	IF (GKS_INUSE) CALL GKS_CALL(%VAL(GKS_ADDR(XGSTXFP)))
C
	GKSERR = 0
	IF (FNT.LE.0) GOTO 10
C
	ICHFNT = FNT
	DO 200 DEV = 1,WSMAX
	   UPTX(DEV) = .TRUE.		! attributes need updating
200	CONTINUE
C
	GOTO 999
C
10	GKSERR = 70			! font .le. 0
C
999	RETURN
	END
C
C***********************************************************************
C
	SUBROUTINE GUPTX(DEV)
C
***	MODULE	GUPTX
***	IDENT	23OC01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	16-April-1991
C
C Update the text attributes
C
	IMPLICIT NONE
C
C argument
	INTEGER	DEV
C
C local variables
	INTEGER	NCOLI,NMASK,NFNTID
	LOGICAL	FST
	INTEGER	GC_MASK
	INTEGER	IPX
C
C functions
	INTEGER		EXPAND
	INTEGER		GUPTX_C	! actually returns a font id
	INTEGER		GKS_C_FIND_FONT
	INTEGER		GKS_C_FIND_VALID_FONT
C
	INCLUDE	'($LIBDEF)'
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
	INCLUDE 'LSL$CMNLSL:EXPC.CMN'
***	COMMON/GKSDECW/
***	COMMON/GKSDAT2/		! GKS data structures
C
C workspace
	INTEGER	PIXEL
	REAL	HX,HGT
	LOGICAL	SETFNT		! set the font for text rendering
	INTEGER USEFNT
C
	SETFNT = .FALSE.
	NCOLI = ITXCOL
	USEFNT = ICHFNT
C
	FST = .FALSE.
10	FST = .NOT.FST
	IF (NCOLI.NE.0) THEN			! not background
	   IF (POFF(DEV).NE.0) NCOLI = ISHFT(NCOLI,POFF(DEV))! offset
	   NCOLI = NCOLI.AND.PSEL(DEV).AND.USED_PLANES(DEV)  ! mask
	   IF (NCOLI.GT.MAXCOL(DEV).OR.NCOLI.EQ.0) THEN
C
C First time, try again with colour 1, otherwise just use 1
	      NCOLI = 1
	      IF (FST) GOTO 10
	   ENDIF
	   IF (NCOLI.EQ.0) NCOLI = 1	! don't want background
	ENDIF
C
	GC_MASK = 0
C
	IF (XDPSC(DEV).NE.0) THEN
	  IF (NCOLI.NE.CPCOLI(DEV)) THEN
	    CPCOLI(DEV) = NCOLI
	    IF (XINVERT(DEV)) THEN
	      PIXEL = USED_PLANES(DEV)-CPCOLI(DEV)
	    ELSE
	      PIXEL = CPCOLI(DEV)
	    ENDIF
	    PIXEL = ISHFT(PIXEL,XOFF(1,DEV))
	    AST_ON = AST_ON+1
	    CALL GWRAP_SET_COLOR(%VAL(XDPSC(DEV)),%VAL(PIXEL))
	    AST_ON = AST_ON-1
	  ENDIF
	ELSE
C
C	  if last thing drawn in this colour was a line or an area,
C	  make sure the graphical context is reset for rendered text
C
	  IF ((NCOLI.NE.CCOLI(DEV)) .OR.
     &	      (XUSE_TEXT_RENDER .AND. (XLAST_GC(DEV) .NE. 5))) THEN
	    CCOLI(DEV) = NCOLI
	    XGCV.X$L_GCVL_FOREGROUND = ISHFT(NCOLI,XOFF(1,DEV))
	    IF (XDECOMP) THEN
	      XGCV.X$L_GCVL_FOREGROUND = XGCV.X$L_GCVL_FOREGROUND .OR.
     &		ISHFT(NCOLI,XOFF(2,DEV)) .OR. ISHFT(NCOLI,XOFF(3,DEV)) 
	    ENDIF
	    GC_MASK = GC_MASK.OR.X$M_GC_FOREGROUND
	    UPLIN(DEV)  = .TRUE.		! line update
	    UPFA(DEV)  = .TRUE.		! and fill area update
	  ENDIF
	ENDIF
C
	CALL GW2D(WKIDS(DEV),ICHH,ICHH,HX,HGT)
	IF (XDPSC(DEV).NE.0.OR.XUSE_TEXT_RENDER) THEN
	  IF (	HGT.NE.CCHHGT(DEV) .OR.
     &		ICHFNT.NE.CCHFNT(DEV) .OR.
     &		(XUSE_TEXT_RENDER .AND.
     &	         (HGT .NE. XTEXT_RENDER_HGT .OR.
     &	          ICHANG .NE. XTEXT_RENDER_ANG)) ) THEN
	    CCHHGT(DEV) = HGT
	    CCHFNT(DEV) = ICHFNT
	    CCHANG(DEV) = ICHANG+1.0		! anything different
	    ICHWID = .FALSE.
	    ICHPTR = GKS_C_FIND_FONT(ICHFNT,ICHSCALE,ICHKERN,ICHWID,
     &			ICHTAB,ICHRTOL,ICHARAB)
	    IF (.NOT.XUSE_TEXT_RENDER) THEN
 	       CALL EXPAND('F%N',ICHFNT)	! already null terminated
 	       AST_ON = AST_ON+1
	       CALL GWRAP_SET_FONT(%VAL(XDPSC(DEV)),
     &			           EXPBUF,
     &			           %VAL(HGT/GNOMLW))
	       AST_ON = AST_ON-1
	    ELSE
	      SETFNT = .TRUE.	! need to set the font
C
C if the selected font cannot be set, use the default one
C
	      IF ((ICHPTR .EQ. 0) .AND. (XDEFAULT_FONT .GT. 0)) THEN
	         ICHPTR = GKS_C_FIND_FONT(XDEFAULT_FONT,ICHSCALE,ICHKERN,
     &			         ICHWID,ICHTAB,ICHRTOL,ICHARAB)
	         USEFNT = XDEFAULT_FONT
	      ENDIF
C
C make sure there is some width data for the font - it is important
C for text rendering
C
	      IF (.NOT. ICHWID) THEN
     	         ICHPTR = GKS_C_FIND_VALID_FONT(ICHSCALE,ICHKERN,
     &			            ICHTAB,ICHRTOL,ICHARAB)
	         USEFNT = XDEFAULT_FONT
	      ENDIF
 	    ENDIF
	  ENDIF
C
	  IF (ICHANG.NE.CCHANG(DEV) .OR.
     &	      (XUSE_TEXT_RENDER .AND. 
     &	       XTEXT_RENDER_ANG .NE. ICHANG) ) THEN
	    CCHANG(DEV) = ICHANG
	    IF (ICHPTR.NE.0.AND.(XUSE_TEXT_RENDER.OR.
     &	        ICHKERN.OR.ICHRTOL.OR.
     &		((ICHCOMP.OR.ICHARAB).AND.ICHWID))) THEN
	       ICOSVEC = COS(ICHANG)*HGT/GNOMLW*ICHSCALE
	       ISINVEC = SIN(ICHANG)*HGT/GNOMLW*ICHSCALE
C
	       IF (XUSE_TEXT_RENDER) SETFNT = .TRUE.
	    ENDIF
	  ENDIF
	ELSE
	  IF (HGT.NE.CCHHGT(DEV)) THEN
	    CCHHGT(DEV) = HGT
C
C convert height to a point size
	    IPX = NINT(HGT/GNOMLW)		! size in pixels
	    NFNTID = GUPTX_C(IPX)
	    IF (NFNTID.NE.CFNTID(DEV).AND.NFNTID.NE.0) THEN
	      CFNTID(DEV) = NFNTID
	      XGCV.X$L_GCVL_FONT = NFNTID
	      GC_MASK = GC_MASK.OR.X$M_GC_FONT
	    ENDIF
	  ENDIF
	ENDIF
C
C have considered possible change of font, height and angle - if
C any changed, then set font for text rendering
C
	IF (SETFNT) THEN
 	   CALL EXPAND('F%N',USEFNT)	! already null terminated
	   CALL GKS_C_SET_TEXTREN_FONT(EXPBUF,
     &	                               %VAL(HGT/GNOMLW*ICHSCALE),
     &	                               %VAL(ICHANG))
	   XTEXT_RENDER_HGT = HGT
	   XTEXT_RENDER_ANG = ICHANG
	ENDIF
C
	NMASK = PSEL(DEV)
	IF (XDECOMP) THEN
	   NMASK =
     &		(ISHFT(NMASK,XOFF(1,DEV)).AND.XMASKS(1,DEV)) .OR.
     &		(ISHFT(NMASK,XOFF(2,DEV)).AND.XMASKS(2,DEV)) .OR.
     &		(ISHFT(NMASK,XOFF(3,DEV)).AND.XMASKS(3,DEV))
	ELSE
	   NMASK = ISHFT(NMASK,XOFF(1,DEV)).AND.XMASK(DEV)
	ENDIF
C
	IF (XDPSC(DEV).NE.0) THEN
	   IF (NMASK.NE.CPMASK(DEV)) THEN
	      CPMASK(DEV) = NMASK
	      XGCV.X$L_GCVL_PLANE_MASK = NMASK
	      GC_MASK = GC_MASK.OR.X$M_GC_PLANE_MASK
	   ENDIF
	ELSE
	   IF (NMASK.NE.CMASK(DEV)) THEN
	      CMASK(DEV) = NMASK
	      XGCV.X$L_GCVL_PLANE_MASK = NMASK
	      GC_MASK = GC_MASK.OR.X$M_GC_PLANE_MASK
	   ENDIF
	ENDIF
C
	IF (GC_MASK.NE.0) THEN
	   AST_ON = AST_ON+1
	   IF (XDPSC(DEV).NE.0) THEN
	      IF (XDPS_DONE(DEV)) THEN	! flush DPS already done
	         XDPS_DONE(DEV) = .FALSE.
	         CALL DPS$WAIT_CONTEXT(XDPSC(DEV))
	      ENDIF
	      CALL X$CHANGE_GC(XDISPLAY,XGC(5,DEV),GC_MASK,XGCV)
	      CALL GUPTX2_C(XGC(5,DEV))	! call C to flush out GC change
	   ELSE
	      IF (XUSE_TEXT_RENDER) THEN
	         CALL X$CHANGE_GC(XDISPLAY,XGC(5,DEV),GC_MASK,XGCV)
	         XLAST_GC(DEV) = 5
              ELSE
	         CALL X$CHANGE_GC(XDISPLAY,XGC(1,DEV),GC_MASK,XGCV)
	         XLAST_GC(DEV) = 1
	      ENDIF
	   ENDIF
	   AST_ON = AST_ON-1
	ENDIF
C
	UPTX(DEV) = .FALSE.		! text now up to date
	RETURN
	END
C
C**********************************************************************
C
	LOGICAL FUNCTION LSG_STRING_WIDTH(STRING,FONT,WIDTH)
C
**	MODULE	LSG_STRING_WIDTH
**	IDENT	29OC92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-April-1984
C
C Get the width of a string if plotted at unit height
C Returns .TRUE. if unable to return the information
C
	IMPLICIT NONE
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
	INCLUDE 'LSL$CMNLSL:EXPC.CMN'
***	PARAMETER/DDSC/
***	COMMON/GKSDECW/
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Arguments:
	CHARACTER*(*)	STRING
	INTEGER		FONT
	REAL		WIDTH
C
C functions
	INTEGER		GKS_C_FIND_FONT
	INTEGER		GKS_C_FIND_VALID_FONT
	REAL		GKS_STRING_WIDTH
	REAL		GKS_DEFAULT_STRING_WIDTH
	LOGICAL		GKS_CALL
C
C w/s
	INTEGER		DEV
	INTEGER		FPTR
	REAL		SCALE
	LOGICAL		KERNED
	LOGICAL		GOT_WIDTH
	INTEGER*4	CHTAB
	LOGICAL		RTOL
	LOGICAL		ARABIC
	RECORD/DDSC/	CSTR
	INTEGER		CLEN
	LOGICAL		FIRST_TIME
C
	GKSERR = 0
	LSG_STRING_WIDTH = .TRUE.
C
	IF (FONT.LE.0) GOTO 10
C
	FIRST_TIME = .TRUE.
C
C for each workstation
2	DO 200 DEV = 1,WSMAX
C
C First time round, find active workstation.
C Next time, make do with just an open one.
	IF (WKIDS(DEV).LT.0.OR.
     &	    (XDPSC(DEV).EQ.0.AND..NOT.XUSE_TEXT_RENDER).OR.
     &			(FIRST_TIME.AND..NOT.WSACT(DEV))) GOTO 200 ! not open
C
	FPTR = GKS_C_FIND_FONT(FONT,SCALE,KERNED,GOT_WIDTH,
     &			CHTAB,RTOL,ARABIC)
C
C if the font had been defined, and has widths from an AFM file, then
C use them (when using TextRendering, great efforts have been made to
C read an AFM file of some sort)
	IF (FPTR.NE.0.AND.GOT_WIDTH) THEN
	   WIDTH = GKS_STRING_WIDTH(FPTR,KERNED,CHTAB,
     &					RTOL,ARABIC,STRING)
	   WIDTH = WIDTH*SCALE
	ELSE
C
C otherwise, inquire of the X-server, after approximating composites
	   CALL STR$GET1_DX(LEN(STRING),CSTR)
	   IF (ICHCOMP) THEN
	      CALL GKS_PROCESS_COMP(CSTR,STRING,CLEN)
	      CALL STR$LEFT(CSTR,CSTR,CLEN)
	   ELSE
	      CALL STR$COPY_DX(CSTR,STRING)
	   ENDIF
	   CALL STR$APPEND(CSTR,CHAR(0))
	   CALL EXPAND('F%N',FONT)	! already null terminated
	   IF (.NOT.XUSE_TEXT_RENDER) THEN
	      AST_ON = AST_ON+1
	      CALL GWRAP_STRING_WIDTH(%VAL(XDPSC(DEV)),
     &				      %VAL(CSTR.DSC_POINTER),
     &				      EXPBUF,
     &				      WIDTH)
	      AST_ON = AST_ON-1
	   ELSE
C
C no server to enquire of, either use another valid font, or guess
	      WIDTH = GKS_DEFAULT_STRING_WIDTH(CSTR)
	   ENDIF
	   CALL STR$FREE1_DX(CSTR)
	ENDIF
	LSG_STRING_WIDTH = .FALSE.
	GOTO 999
C
200	CONTINUE
C
C first time round, try the plotting library
	IF (FIRST_TIME) THEN
	   FIRST_TIME = .FALSE.
	   IF (GKS_INUSE.AND.GKS_ADDR(XLSG_STRING_WIDTH).NE.0
     & ) LSG_STRING_WIDTH = GKS_CALL(%VAL(GKS_ADDR(XLSG_STRING_WIDTH)))
C
C still no answer, so try any open workstation
	   IF (LSG_STRING_WIDTH) GOTO 2
	ENDIF
C
	GOTO 999
C
10	GKSERR = 70			! font .le. 0
C
999	RETURN
	END
C
C**********************************************************************
C
	LOGICAL FUNCTION LSG_STRING_BOUNDS(STRING,FONT,BORDER,ROUTINE)
C
**	MODULE	LSG_STRING_BOUNDS
**	IDENT	26AU94
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-August-1994
C
C Call the callback ROUTINE for each character in the string, passing
C the width and bounding box of the character.
C It is used to build up a region around the string.
C Returns .TRUE. if unable to return the information
C
	IMPLICIT NONE
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
	INCLUDE 'LSL$CMNLSL:EXPC.CMN'
***	PARAMETER/DDSC/
***	COMMON/GKSDECW/
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C Arguments:
	CHARACTER*(*)	STRING
	INTEGER		FONT
	REAL		BORDER
	EXTERNAL	ROUTINE
C
C functions
	INTEGER		GKS_C_FIND_FONT
	INTEGER		GKS_C_FIND_VALID_FONT
	LOGICAL		GKS_CALL
	CHARACTER*1	STR$POS_EXTR
C
C w/s
	INTEGER		DEV
	INTEGER		FPTR
	REAL		SCALE
	LOGICAL		KERNED
	LOGICAL		GOT_WIDTH
	INTEGER*4	CHTAB
	LOGICAL		RTOL
	LOGICAL		ARABIC
	RECORD/DDSC/	CSTR
	INTEGER		CLEN
	LOGICAL		FIRST_TIME
	INTEGER		I
	REAL		W
	REAL		BOX(4)
	INTEGER		C
C
	GKSERR = 0
	LSG_STRING_BOUNDS = .TRUE.
C
	IF (FONT.LE.0) GOTO 10
C
	FIRST_TIME = .TRUE.
C
C for each workstation
2	DO 200 DEV = 1,WSMAX
C
C First time round, find active workstation.
C Next time, make do with just an open one.
	IF (WKIDS(DEV).LT.0.OR.
     &      (XDPSC(DEV).EQ.0.AND..NOT.XUSE_TEXT_RENDER).OR.
     &			(FIRST_TIME.AND..NOT.WSACT(DEV))) GOTO 200 ! not open
C
	FPTR = GKS_C_FIND_FONT(FONT,SCALE,KERNED,GOT_WIDTH,
     &			CHTAB,RTOL,ARABIC)
C
C if the font had been defined, and has widths from an AFM file, then
C use them
	IF (FPTR.NE.0.AND.GOT_WIDTH) THEN
	   CALL GKS_STRING_BOUNDS(FPTR,SCALE,KERNED,CHTAB,
     &				RTOL,ARABIC,STRING,BORDER,ROUTINE)
	ELSE
	   IF (.NOT.XUSE_TEXT_RENDER) THEN
C
C otherwise, inquire of the X-server, after approximating composites
	      CLEN = LEN(STRING)
	      CALL STR$GET1_DX(CLEN,CSTR)
	      IF (ICHCOMP) THEN
	         CALL GKS_PROCESS_COMP(CSTR,STRING,CLEN)
	         CALL STR$LEFT(CSTR,CSTR,CLEN)
	      ELSE
	         CALL STR$COPY_DX(CSTR,STRING)
	      ENDIF
	      CALL EXPAND('F%N',FONT)	! already null terminated
	      AST_ON = AST_ON+1
	      DO 5 I=1,CLEN
C
C pass integer as null terminated one char string
	         C = ICHAR(STR$POS_EXTR(CSTR,I,I))
	         CALL GWRAP_STRING_WIDTH(%VAL(XDPSC(DEV)),
     &	                              C,
     &				      EXPBUF,
     &				      W)
	         CALL GWRAP_STRING_BOX(%VAL(XDPSC(DEV)),
     &				   C,
     &				   EXPBUF,
     &				   BOX(1),BOX(2),BOX(3),BOX(4))
	         IF (BOX(1).EQ.BOX(3).AND.BOX(2).EQ.BOX(4)) THEN
	            BOX(1) = 0.0
	            BOX(2) = 0.0
	            BOX(3) = W
	            BOX(4) = 0.0
	         ELSE
	            BOX(1) = BOX(1) - BORDER
	            BOX(2) = BOX(2) - BORDER
	            BOX(3) = BOX(3) + BORDER
	            BOX(4) = BOX(4) + BORDER
	         ENDIF
	         CALL ROUTINE(W,BOX(1),BOX(3),BOX(2),BOX(4))
5	      CONTINUE
	      AST_ON = AST_ON-1
	      CALL STR$FREE1_DX(CSTR)
	   ELSE
C
C if using text rendering, cannot inquire of server, so get a good font
C from somewhere and use that
	      FPTR = GKS_C_FIND_VALID_FONT(SCALE,KERNED,
     &			                   CHTAB,RTOL,ARABIC)
	      IF (FPTR.NE.0) THEN
	         CALL GKS_STRING_BOUNDS(FPTR,SCALE,KERNED,CHTAB,
     &				   RTOL,ARABIC,STRING,BORDER,ROUTINE)
	      ENDIF
	   ENDIF
	ENDIF
	LSG_STRING_BOUNDS = .FALSE.
	GOTO 999
C
200	CONTINUE
C
C first time round, try the plotting library
	IF (FIRST_TIME) THEN
	   FIRST_TIME = .FALSE.
	   IF (GKS_INUSE.AND.GKS_ADDR(XLSG_STRING_BOUNDS).NE.0
     &		) LSG_STRING_BOUNDS =
     &			GKS_CALL(%VAL(GKS_ADDR(XLSG_STRING_BOUNDS)))
C
C still no answer, so try any open workstation
	   IF (LSG_STRING_BOUNDS) GOTO 2
	ENDIF
C
	GOTO 999
C
10	GKSERR = 70			! font .le. 0
C
999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKS_SHOW_STRING(DEVNUM,XDEV,CTX,X,Y,STRING)
C
**	MODULE	GKS_SHOW_STRING
**	IDENT	09OC01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	14-July-1993
C
C Show a (possibly kerned) string using Display PostScript or
C Text rendering
C
	IMPLICIT NONE
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
***	PARAMETER/DDSC/
***	COMMON/GKSDAT2/
***	COMMON/GKSDECW/
C
C Arguments:
	INTEGER		DEVNUM		! device index
	INTEGER		XDEV            ! X device to draw on
	INTEGER		CTX             ! dps context, if using dps
	REAL		X,Y
	CHARACTER*(*)	STRING
C
C functions
	REAL		GKS_C_GET_KERN_PAIR
	REAL		GKS_C_GET_CHAR_WIDTH
	INTEGER		GKS_C_GET_ARABIC
	INTEGER		GKS_FIND_COMPOSITE
C
C w/s
	RECORD	/DDSC/	CSTR
	INTEGER		CLEN
	INTEGER		P,P0,P1,P2
	INTEGER		C1,C2		! two consecutive chars
	LOGICAL		CC1,CC2		! composite or not
	INTEGER		C1A,C2A		! after glyph substitution
	LOGICAL		ARABIC1,ARABIC2
	REAL		K,KK
	INTEGER		N
	LOGICAL		DO_COMP,DO_ARABIC
	REAL		TX,TY
C
	TX = X
	TY = Y
C
C do composites if both LSL$COMPOSITE_CHARACTERS (ICHCOMP),
C and we have AFM info (ICHWID)
C ICHKERN and ICHRTOL only true if have AFM widths also, so if no AFM
C info, we don't do this section at all.
C In principal, we could do Arabic glyph substitution with no AFM
C file (so long as going L to R), but for now, insist on AFM widths
	DO_COMP = ICHCOMP.AND.ICHWID
	DO_ARABIC = ICHARAB.AND.ICHWID
	IF (ICHPTR.NE.0.AND.
     &		(ICHKERN.OR.DO_COMP.OR.ICHRTOL.OR.DO_ARABIC)) THEN
	  P = 0
	  P0 = 1
	  P2 = 0
	  C2 = -1
	  CC2 = .FALSE.
	  K = 0.0
C
C get next character
5	  CONTINUE
C
C shuffle down one character position
	  C1 = C2
	  CC1 = CC2
	  C1A = C2A
	  ARABIC1 = ARABIC2
	  P1 = P2
	  P = P+1
	  P2 = P		! position of *start* of character
C
C get next char, or flag reached end of string
	  CC2 = .FALSE.
	  IF (P.GT.LEN(STRING)) THEN
	    C2 = -1
	  ELSE
	    C2 = ICHAR(STRING(P:P))
	    IF (DO_COMP.AND.CHAR(C2).EQ.'{') THEN
	      CC2 = .TRUE.
	      C2 = GKS_FIND_COMPOSITE(ICHTAB,STRING(P:),N)
	      P = P+N-1		! position of *end* of character
	    ENDIF
	  ENDIF
C
	  IF (C2.GE.0) THEN
	    C2A = C2		! assume no Arabic glyph
	    ARABIC2 = .FALSE.
	    IF (DO_ARABIC.AND..NOT.CC2) THEN
	      C2A = GKS_C_GET_ARABIC(%VAL(ICHPTR),%REF(STRING),
     &					LEN(STRING),P2-1,DO_COMP)
	      IF (C2A.GT.0) THEN
	        ARABIC2 = .TRUE.
	      ELSE
	        C2A = C2
	      ENDIF
	    ENDIF
	  ENDIF
C
C once 2nd char has been read, then we have a char in C1
	  IF (C1.GE.0) THEN
C
C check if need to draw the char individually i.e. composite,
C right-to-left, Arabic
C draw composite character
	    IF (CC1 .OR. ICHRTOL .OR. ARABIC1) THEN
C
C flush out accumulated string
	      IF (P1.GT.P0) THEN
	        IF (.NOT.XUSE_TEXT_RENDER) THEN
	           CALL GWRAP_SHOW_AT(%VAL(CTX),
     &			   %VAL(TX),%VAL(TY),
     &			   %VAL(ICHANG*TODEG),
     &			   %REF(STRING(P0:P1-1)//CHAR(0)))
	        ELSE
	           CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                                 XDEV,
     &	                                 TX,TY,ICHANG,
     &	                                 STRING(P0:P1-1))
	        ENDIF
	        TX = TX + K*ICOSVEC
	        TY = TY + K*ISINVEC
	      ENDIF
C
C Kerning and Width use the glyphs *after* substitution
	      K = GKS_C_GET_CHAR_WIDTH(%VAL(ICHPTR),C1A)
	      IF (ICHRTOL) THEN
	        TX = TX - K*ICOSVEC
	        TY = TY - K*ISINVEC
	        K = 0.0
	      ENDIF
	      IF (CC1) THEN
	        CALL GKS_SHOW_COMPOSITE(DEVNUM,XDEV,CTX,TX,TY,C1)
	      ELSE
	        IF (.NOT.XUSE_TEXT_RENDER) THEN
	           CALL GWRAP_SHOW_AT(%VAL(CTX),
     &			              %VAL(TX),%VAL(TY),
     &			              %VAL(ICHANG*TODEG),
     &			              %REF(CHAR(C1A)//CHAR(0)))
	        ELSE
	           CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                                 XDEV,
     &	                                 TX,TY,ICHANG,
     &	                                 CHAR(C1A))
	        ENDIF
	      ENDIF
	      IF (ICHKERN.AND.C2.GE.0) K = K +
     &			GKS_C_GET_KERN_PAIR(%VAL(ICHPTR),C1A,C2A)
	      IF (ICHRTOL) K = -K
	      TX = TX + K*ICOSVEC
	      TY = TY + K*ISINVEC
	      K = 0.0
	      P0 = P2
	    ELSE
C
C non-composite character
	      K = K + GKS_C_GET_CHAR_WIDTH(%VAL(ICHPTR),C1A)
	      KK = 0.0
	      IF (ICHKERN.AND.C2.GE.0) THEN
	        KK = GKS_C_GET_KERN_PAIR(%VAL(ICHPTR),C1A,C2A)
	        K = K+KK
	      ENDIF
C
C if we got a kern pair, or at end of string, then flush out
	      IF (KK.NE.0.OR.C2.LT.0) THEN
	        IF (.NOT.XUSE_TEXT_RENDER) THEN
	           CALL GWRAP_SHOW_AT(%VAL(CTX),
     &			   %VAL(TX),%VAL(TY),
     &			   %VAL(ICHANG*TODEG),
     &			   %REF(STRING(P0:P2-1)//CHAR(0)))
	        ELSE
	           CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                                 XDEV,
     &	                                 TX,TY,ICHANG,
     &	                                 STRING(P0:P2-1))
	        ENDIF
	        TX = TX + K*ICOSVEC
	        TY = TY + K*ISINVEC
	        K = 0
	        P0 = P2
	      ENDIF
	    ENDIF
	  ENDIF
C
C round again, unless we have reached end of string
	  IF (C2.GE.0) GOTO 5
C
	ELSE
C
C Not kerned, and not composite, so just display ordinarily.
C If composite was requested, but cannot be done, then approximate it.
	  CALL STR$GET1_DX(LEN(STRING),CSTR)
	  IF (ICHCOMP) THEN
	    CALL GKS_PROCESS_COMP(CSTR,STRING,CLEN)
	    CALL STR$LEFT(CSTR,CSTR,CLEN)
	  ELSE
	    CALL STR$COPY_DX(CSTR,STRING)
	  ENDIF
	  CALL STR$APPEND(CSTR,CHAR(0))
	  IF (.NOT.XUSE_TEXT_RENDER) THEN
	     CALL GWRAP_SHOW_AT(%VAL(CTX),
     &	                   %VAL(TX),%VAL(TY),
     &		   	   %VAL(ICHANG*TODEG),
     &			   %VAL(CSTR.DSC_POINTER))
	  ELSE
	     CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                           XDEV,
     &	                           TX,TY,ICHANG,
     &	                           CSTR)
	  ENDIF
C
	  CALL STR$FREE1_DX(CSTR)
	ENDIF
C
999	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKS_SHOW_COMPOSITE(DEVNUM,XDEV,CTX,X,Y,C)
C
**	MODULE	GKS_SHOW_COMPOSITE
**	IDENT	29OC92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	14-July-1993
C
C Show a composite character
C
	IMPLICIT NONE
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
***	COMMON/GKSDAT2/
***	COMMON/GKSDECW/
C
C Arguments:
	INTEGER		DEVNUM
	INTEGER		XDEV
	INTEGER		CTX
	REAL		X,Y
	INTEGER		C
C
C functions
	INTEGER		GKS_C_GET_COMPONENT
C
C w/s
	INTEGER		N
	INTEGER		CH
	REAL		DELTAX,DELTAY
	REAL		RX,RY
C
C Ordinary characters can be displayed simply, with a zero offset
	IF (C.LE.255) THEN
	   IF (.NOT.XUSE_TEXT_RENDER) THEN
	     CALL GWRAP_SHOW_AT(%VAL(CTX),
     &			   %VAL(X),%VAL(Y),
     &			   %VAL(ICHANG*TODEG),
     &			   %REF(CHAR(C)//CHAR(0)))
	   ELSE
	      CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                            XDEV,
     &	                            X,Y,ICHANG,
     &	                            CHAR(C))
	   ENDIF
	ELSE
C
C but for a real composite, get each component in turn
	  N = 0
10	  CH = GKS_C_GET_COMPONENT(%VAL(ICHPTR),C,N,DELTAX,DELTAY)
	  IF (CH.LT.0) GOTO 999
	  RX = DELTAX*ICOSVEC - DELTAY*ISINVEC
	  RY = DELTAX*ISINVEC + DELTAY*ICOSVEC
	  IF (.NOT.XUSE_TEXT_RENDER) THEN
	     CALL GWRAP_SHOW_AT(%VAL(CTX),
     &	       	      	   %VAL(X+RX),%VAL(Y+RY),
     &			   %VAL(ICHANG*TODEG),
     &			   %REF(CHAR(CH)//CHAR(0)))
	  ELSE
	     CALL GKS_TEXT_SHOW_AT(DEVNUM,
     &	                           XDEV,
     &	                           X+RX,Y+RY,ICHANG,
     &	                           CHAR(CH))
	  ENDIF
	  N = N+1
	  GOTO 10
	ENDIF
999	RETURN
	END
C
C**********************************************************************
C
	INTEGER FUNCTION GKS_FIND_COMPOSITE(CHTAB,STRING,N)
C
**	MODULE	GKS_FIND_COMPOSITE
**	IDENT	29OC92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	14-July-1993
C
C Look up name of composite character
C Called with STRING(1:1) = '{'
C Returns number of characters absorbed in N
C
	IMPLICIT NONE
C
	INCLUDE	'LSL$CMNLSL:CMDCOM.CMN'
	INCLUDE	'LSL$CMNLSL:TXTC.CMN'
	INCLUDE	'LSL$CMNLSL:WINDEF.CMN'
C
C Arguments:
	INTEGER		CHTAB	! character name table address
	CHARACTER*(*)	STRING
	INTEGER		N
C
C functions
	INTEGER		RDCOMM
	INTEGER		RDCHS
C
C w/s
	LOGICAL*1	SAV_NOMESS
	INTEGER*2	SAVPTR
	INTEGER*2	SAVORIG
	INTEGER*4	SAVTXB(2)
	LOGICAL*1	SAVWIN
	BYTE		CH
	INTEGER		CMD
	LOGICAL		HADAUX
C
	HADAUX = .FALSE.
C
C '{' at end of line just turns into spce
	IF (LEN(STRING).LE.1) THEN
	   N = 1			! just absorb the '{'
	   GKS_FIND_COMPOSITE = ICHAR(' ')	! return space
	   GOTO 999
	ENDIF
C
C repeated '{' is a single '{'
	IF (STRING(2:2).EQ.'{') THEN
	   N = 2
	   GKS_FIND_COMPOSITE = ICHAR('{')
	   GOTO 999
	ENDIF
C
C otherwise we will be skipping up to '}' or end of line
	N = INDEX(STRING,'}')
	IF (N.EQ.0) N = LEN(STRING)
C
C save line decoding context, including auxiliary buffer
	SAVPTR = DCPTR
	SAVORIG = ORIGTP
	SAVTXB(1) = AUXTXB(1)
	SAVTXB(2) = AUXTXB(2)
	SAVWIN = WINDEF
C
	CALL SETAUX(%REF(STRING(2:)),N-1)	! includes '}'
	HADAUX = .TRUE.
	IF (RDCHS(CH)) THEN
C
C only get here if we have '{' followed only by spaces/tabs
	   GKS_FIND_COMPOSITE = ICHAR(' ')	! return space
	   GOTO 999
	ENDIF
C
C First sig char after '{' is used if lookup fails
	GKS_FIND_COMPOSITE = CH.AND.255	! first char as default
C
C No character name table, so can't do lookup
	IF (CHTAB.EQ.0) GOTO 999
C
C Look up name in table - command number is char+1, and char>=256
C are composites
	CALL BSCH
	SAV_NOMESS = NOMESS
	NOMESS = .FALSE.
	CMD = RDCOMM(%VAL(CHTAB))
	NOMESS = SAV_NOMESS
	IF (CMD.LE.0) THEN
	   CALL TTWSTR('??? Error in composite character name')
	   GOTO 999
	ENDIF
	GKS_FIND_COMPOSITE = CMD-1
C
C check for rubbish after name
	IF (RDCHS(CH)) GOTO 999
	IF (CH.EQ.'}') GOTO 999
	CALL WRITEF('Unexpected "%S" after composite character name',
     &		STRING(DCPTR:N-1))
C
999	IF (HADAUX) THEN
	   DCPTR = SAVPTR
	   ORIGTP = SAVORIG
	   AUXTXB(1) = SAVTXB(1)
	   AUXTXB(2) = SAVTXB(2)
	   WINDEF = SAVWIN
	ENDIF
	RETURN
	END
C
C**********************************************************************
C
	REAL FUNCTION GKS_STRING_WIDTH(FPTR,KERNED,CHTAB,
     &					RTOL,ARABIC,STRING)
C
**	MODULE	GKS_STRING_WIDTH
**	IDENT	11MY95
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	14-July-1993
C
C Return width of hardware text string
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
C
C arguments
	INTEGER		FPTR	! font structure pointer
	LOGICAL		KERNED	! apply kerning?
	INTEGER		CHTAB	! character name table address
	LOGICAL		RTOL	! right to left?
	LOGICAL		ARABIC
	CHARACTER*(*)	STRING
C
C functions
	REAL		GKS_C_GET_KERN_PAIR
	REAL		GKS_C_GET_CHAR_WIDTH
	INTEGER		GKS_C_GET_ARABIC
	INTEGER		GKS_FIND_COMPOSITE
C
C w/s
	INTEGER		P
	INTEGER		C1,C2		! two consecutive chars
	LOGICAL		CC2		! composite or not
	INTEGER		C1A,C2A		! after glyph substitution
	INTEGER		N
	REAL		W
C
	W = 0.0
	P = 0
	C2 = -1
C
C get next character
5	CONTINUE
C
C shuffle down one character position
	C1 = C2
	C1A = C2A
	P = P+1
C
C get next char, or flag reached end of string
	CC2 = .FALSE.
	IF (P.GT.LEN(STRING)) THEN
	   C2 = -1
	ELSE
	   C2 = ICHAR(STRING(P:P))
	   IF (ICHCOMP.AND.CHAR(C2).EQ.'{') THEN
	      CC2 = .TRUE.
	      C2 = GKS_FIND_COMPOSITE(CHTAB,STRING(P:),N)
	      P = P+N-1
	   ENDIF
	ENDIF
C
	IF (C2.GE.0) THEN
	  C2A = C2		! assume no Arabic glyph
	  IF (ARABIC.AND..NOT.CC2) THEN
	    C2A = GKS_C_GET_ARABIC(%VAL(FPTR),%REF(STRING),
     &					LEN(STRING),P-1,ICHCOMP)
	    IF (C2A.LT.0) C2A = C2
	  ENDIF
	ENDIF
C
C Kerning and Width use the glyphs *after* substitution
	IF (C1.GE.0) THEN
	  W = W + GKS_C_GET_CHAR_WIDTH(%VAL(FPTR),C1A)
	  IF (KERNED.AND.C2.GE.0) W = W +
     &			GKS_C_GET_KERN_PAIR(%VAL(FPTR),C1A,C2A)
	ENDIF
C
C round again, unless we have reached end of string
	IF (C2.GE.0) GOTO 5
C
C negative width if Right-TO-Left font
	IF (RTOL) W = -W
	GKS_STRING_WIDTH = W
	RETURN
	END

C
C**********************************************************************
C
	SUBROUTINE GKS_STRING_BOUNDS(FPTR,SCALE,KERNED,CHTAB,
     &				RTOL,ARABIC,STRING,BORDER,ROUTINE)
C
**	MODULE	GKS_STRING_BOUNDS
**	IDENT	11MY95
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	26-August-1994
C
C Perform work for LSG_STRING_BOUNDS using .AFM info
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
C
C arguments
	INTEGER		FPTR	! font structure pointer
	REAL		SCALE	! scale factor from .PSFONTLIST
	LOGICAL		KERNED	! apply kerning?
	LOGICAL		RTOL	! right to left?
	LOGICAL		ARABIC
	INTEGER		CHTAB	! character name table address
	CHARACTER*(*)	STRING
	REAL		BORDER	! border width round each char
	EXTERNAL	ROUTINE	! callback for each char
C
C functions
	REAL		GKS_C_GET_KERN_PAIR
	REAL		GKS_C_GET_CHAR_METRICS
	INTEGER		GKS_C_GET_ARABIC
	INTEGER		GKS_FIND_COMPOSITE
C
C w/s
	INTEGER		P
	INTEGER		C1,C2
	LOGICAL		CC2		! composite or not
	INTEGER		C1A,C2A		! after glyph substitution
	INTEGER		N
	REAL		W
	REAL		BOX(4)
C
	P = 0
	C2 = -1
C
C get next character
5	CONTINUE
C
C shuffle down one character position
	C1 = C2
	C1A = C2A
	P = P+1
C
C get next char, or flag reached end of string
	CC2 = .FALSE.
	IF (P.GT.LEN(STRING)) THEN
	   C2 = -1
	ELSE
	   C2 = ICHAR(STRING(P:P))
	   IF (ICHCOMP.AND.CHAR(C2).EQ.'{') THEN
	      CC2 = .TRUE.
	      C2 = GKS_FIND_COMPOSITE(CHTAB,STRING(P:),N)
	      P = P+N-1
	   ENDIF
	ENDIF
C
	IF (C2.GE.0) THEN
	  C2A = C2		! assume no Arabic glyph
	  IF (ARABIC.AND..NOT.CC2) THEN
	    C2A = GKS_C_GET_ARABIC(%VAL(FPTR),%REF(STRING),
     &					LEN(STRING),P-1,ICHCOMP)
	    IF (C2A.LT.0) C2A = C2
	  ENDIF
	ENDIF
C
C Kerning and Width use the glyphs *after* substitution
	IF (C1.GE.0) THEN
	  W = GKS_C_GET_CHAR_METRICS(%VAL(FPTR),C1A,BOX)
	  IF (KERNED.AND.C2.GE.0) W = W +
     &			GKS_C_GET_KERN_PAIR(%VAL(FPTR),C1A,C2A)
	  W = W*SCALE
	  IF (BOX(1).EQ.0.0.AND.BOX(2).EQ.0.0.AND.
     &	      BOX(3).EQ.0.0.AND.BOX(4).EQ.0.0) THEN
	    BOX(3) = W
	  ELSE
	    BOX(1) = BOX(1)*SCALE - BORDER
	    BOX(2) = BOX(2)*SCALE - BORDER
	    BOX(3) = BOX(3)*SCALE + BORDER
	    BOX(4) = BOX(4)*SCALE + BORDER
	  ENDIF
	  IF (RTOL) THEN
	    CALL ROUTINE(-W,BOX(3)-W,BOX(1)-W,BOX(2),BOX(4))
	  ELSE
	    CALL ROUTINE(W,BOX(1),BOX(3),BOX(2),BOX(4))
	  ENDIF
	ENDIF
C
C round again, unless we have reached end of string
	IF (C2.GE.0) GOTO 5
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKS_PROCESS_COMP(DEST,SOURCE,DLEN)
C
**	MODULE	GKS_PROCESS_COMP
**	IDENT	29OC92
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Clarke Brunt	14-July-1993
C
C Remove {} sequences from string
C
	IMPLICIT NONE
C
C arguments
	INTEGER		DLEN
	CHARACTER*(*)	DEST,SOURCE
C
C functions
	INTEGER		GKS_FIND_COMPOSITE
C
C w/s
	INTEGER		D,S
	INTEGER		N
	CHARACTER*1	C
C
	D = 0
	S = 0
C
C get next character
5	S = S+1
	IF (S.GT.LEN(SOURCE)) GOTO 999
	C = SOURCE(S:S)
	IF (C.EQ.'{') THEN
	  C = CHAR(GKS_FIND_COMPOSITE(0,SOURCE(S:),N))
	  S = S+N-1
	ENDIF
	D = D+1
	DEST(D:D) = C
	GOTO 5
C
C rather grubby STR$ call - assumes argument is dynamic string
999	DLEN = D
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GKS_TEXT_SHOW_AT(DEV,XDEV,PX,PY,ANG,STRING)
C
**	MODULE	GKS_TEXT_SHOW_AT
**	IDENT	09OC01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Ron Russell	09-October-2001
C
C Display a text string on  a device at the given point
C
	IMPLICIT NONE
C
C arguments
	INTEGER	DEV			! device index
	INTEGER	XDEV			! Xdevice
	REAL	PX			! X coord
	REAL	PY			! Y coord
	REAL	ANG			! angle
	CHARACTER*(*) STRING		! text
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
***	COMMON/GKSDAT2/
***	COMMON/GKSDECW/
C
C functions
C
	REAL		GKS_C_GET_CHAR_WIDTH
C
C workspace
C
	INTEGER 	I
	REAL		WIDTH
	INTEGER         CH
	REAL		RX,RY	! pixel coords (from bl)
	REAL		DSPHGT
C
	DSPHGT = DCMAXY(DEV)/GNOMLW
	RX = PX
	RY = PY
	WIDTH = 0.0
C
	DO 100, I = 1,LEN(STRING)
C
	   CH = ICHAR(STRING(I:I))
	   IF (CH .EQ. 0) GOTO 100 
	   IF (ICHPTR .NE. 0)
     &	          WIDTH = GKS_C_GET_CHAR_WIDTH(%VAL(ICHPTR),CH)
C
C display character CH at pixel RX,RY
C
	   CALL GTX_DRAW_RENDERED_CHAR(DEV,
     &	                               XDEV,
     &				       DSPHGT,
     &				       RX,RY,
     &	                               CH)
C
C move origin of character on
C
	   RX = RX + (WIDTH * ICOSVEC)
	   RY = RY + (WIDTH * ISINVEC)
C
100	CONTINUE
C
	RETURN
	END
C
C**********************************************************************
C
	SUBROUTINE GTX_DRAW_RENDERED_CHAR(DEV,XDEV,DSPHGT,RX,RY,CH)
C
**	MODULE	GTX_DRAW_RENDERED_CHAR
**	IDENT	09OC01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Ron Russell	09-October-2001
C
C Draw a character at a given point
C
	IMPLICIT NONE
C
C arguments
	INTEGER	DEV			! device index
	INTEGER	XDEV			! Xdevice
	REAL	DSPHGT			! Height of display (in pixels)
	REAL	RX			! X coord (pixels)
	REAL	RY			! Y coord (pixels)
	INTEGER	CH
C
	INCLUDE	'SYS$LIBRARY:DECW$XLIBDEF'
***	COMMON/GKSDAT2/
***	COMMON/GKSDECW/
C
C functions
C
	INTEGER	GKS_C_GET_CHAR_BITMAP
	INTEGER XCreateImage
C
C workspace
C
	INTEGER		BITMAP
	INTEGER		HEIGHT
	INTEGER		WIDTH
	INTEGER		ORIGIN_X
	INTEGER		ORIGIN_Y
	RECORD/X$IMAGE/ IMAGE		! image structure
	INTEGER		XIMAGE_ADDR
	INTEGER		XPIX
	INTEGER		YPIX
	INTEGER		GC_MASK
	INTEGER		DRAWOP
	INTEGER		PIXVAL
	INTEGER		I
C
C get the rendered bitmap for the character
C
	BITMAP = 0
C
	IF (.NOT.GKS_C_GET_CHAR_BITMAP(%VAL(CH),%VAL(RX),%VAL(RY),
     &	                               BITMAP,
     &	                               WIDTH,HEIGHT,
     &	                               ORIGIN_X,ORIGIN_Y)) GOTO 1000
C
C if no bitmap produces, then nothing to do
C
	IF (BITMAP .EQ. 0) GOTO 1000
C
C use the bitmap to create the an X image - use C binding (see comment
C in GKS2.SRC)
C
	XIMAGE_ADDR = XCreateImage(%VAL(XDISPLAY),XVISUAL,
     &		%VAL(1),%VAL(X$C_XY_BITMAP),%VAL(0),%VAL(BITMAP),
     &		%VAL(WIDTH),%VAL(HEIGHT),%VAL(32),%VAL(0))
	CALL VIOMV3(%VAL(XIMAGE_ADDR),X$C_IMAG_SIZE,IMAGE)
	CALL XDestroyImage(%VAL(XIMAGE_ADDR))
C
C the bitmap produced by textrenlib has msb first 
C
	IMAGE.X$L_IMAG_BYTE_ORDER = X$C_MSB_FIRST
	IMAGE.X$L_IMAG_BITMAP_BIT_ORDER = X$C_MSB_FIRST
C
C set the pixel position on the window
C
	XPIX = ORIGIN_X
	YPIX = NINT(DSPHGT) - ORIGIN_Y - 1
C
C get the current foreground colour
C
	GC_MASK = X$M_GC_PLANE_MASK.OR.X$M_GC_FOREGROUND
	CALL X$GET_GC_VALUES(XDISPLAY,XGC(5,DEV),GC_MASK,XGCV)
C
	PIXVAL = '00000000'X
	DRAWOP = X$C_GX_OR
C
C draw image twice, first the foreground bits OR into the destination
C second time AND the image, with bits not to be plotted mapped to
C 'FFFFFF'X
C
	DO 100, I = 1,2
C
C 	   if first pass would not draw anything, then miss it out
C
	   IF ((I.EQ.1) .AND. ((XGCV.X$L_GCVL_FOREGROUND .AND.
     &	        XGCV.X$L_GCVL_PLANE_MASK) .EQ. 0)) GOTO 50
C
	   XGCV.X$L_GCVL_BACKGROUND = PIXVAL
	   XGCV.X$L_GCVL_FUNCTION = DRAWOP
C
	   GC_MASK = X$M_GC_FUNCTION.OR.X$M_GC_BACKGROUND
	   AST_ON = AST_ON + 1
	   CALL X$CHANGE_GC(XDISPLAY,XGC(5,DEV),GC_MASK,XGCV)
C
	   CALL X$PUT_IMAGE(XDISPLAY,XDEV,XGC(5,DEV),
     &			   IMAGE,0,0,XPIX,YPIX,WIDTH,HEIGHT)
	   AST_ON = AST_ON - 1
C
50	   CONTINUE
	   PIXVAL = NOT(PIXVAL)
	   DRAWOP = X$C_GX_AND
100	CONTINUE
C
C when destroying the image, make sure the bit map is not destroyed by X
C
	IMAGE.X$A_IMAG_DATA = '0000000'X
	CALL X$DESTROY_IMAGE(IMAGE)
C
C free the bitmap
C
	CALL GKS_FREE(%VAL(BITMAP))
C
1000	CONTINUE
	RETURN
	END


C
C**********************************************************************
C
	REAL FUNCTION GKS_DEFAULT_STRING_WIDTH(STRING)
C
**	MODULE	GKS_DEFAULT_STRING_WIDTH
**	IDENT	30OC01
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C Created				Ron Russell	30-October-2001
C
C Return width of hardware text string using some font or other
C
	IMPLICIT NONE
C
***	COMMON/GKSDAT2/
C
C arguments
	CHARACTER*(*)	STRING
C
C functions
	INTEGER		GKS_C_FIND_VALID_FONT
	REAL		GKS_STRING_WIDTH
C
C w/s
	INTEGER		FPTR	! font structure pointer
	REAL		SCALE
	LOGICAL		KERNED
	INTEGER*4	CHTAB
	LOGICAL		RTOL
	LOGICAL		ARABIC
	REAL		W
C
C try to find the first font that has widths in it
	FPTR = GKS_C_FIND_VALID_FONT(SCALE,KERNED,
     &			             CHTAB,RTOL,ARABIC)
C
C if a valid font had been found, the use it
	IF (FPTR.NE.0) THEN
	   W = GKS_STRING_WIDTH(FPTR,KERNED,CHTAB,
     &	                        RTOL,ARABIC,STRING)
	   W = W*SCALE
	ELSE
C
C just guess
	   W = LEN(STRING) * 0.6
	ENDIF
C
	GKS_DEFAULT_STRING_WIDTH = W
	RETURN
	END
