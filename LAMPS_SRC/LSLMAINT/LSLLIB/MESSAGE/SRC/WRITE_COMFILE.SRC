	LOGICAL FUNCTION WRITE_COMFILE
C
***	MODULE	WRITE_COMFILE
***	IDENT	20SE88
C
C Copyright Laser-Scan Laboratories Ltd., Cambridge, England
C Author TJ Ibbs, 10 July 1987
C
C This function writes the DCL command file that runs the MESSAGE
C utility to generate a .PROMSG_OBJ file, and also compiles, links
C and runs GENPAR.FOR to generate parameter files
C
C It returns TRUE if the program should exit, and FALSE otherwise.
C
	IMPLICIT NONE
C
C *****************************************************************************
C Parameter files
C
	INCLUDE	'LSL$CMNLSL:LSLLIBMSG.PAR'	! LSLLIB__ messages
	INCLUDE	'HERE:NEWMSGMSG.PAR'		! NEWMSG__ messages
C
C Common files
C
	INCLUDE 'LSL$CMNLSL:FILENAME.CMN'	! for filename bits
	INCLUDE	'HERE:QUALIFIERS.CMN'		! for command line
	INCLUDE	'HERE:FILES.CMN'		! for luns, etc
	INCLUDE	'HERE:MESSAGES.CMN'		! the messages themselves
C
C Workspace
C
	INTEGER		I		! for a DO loop counter
	INTEGER		OK,IERR		! used by ERRSNS
C
	CHARACTER*(C_MAX_SIZ)	COM_NAM	! the file we are writing
	INTEGER			COM_LEN	! the name's size
C
C **********************************************************************
C assume that things work
C
	WRITE_COMFILE = .FALSE.
C
C check to see whether we have anything to do
C
	IF ( .NOT.OUT_FORTRAN .AND.
     &	     .NOT.OUT_MACRO   .AND.
     &	     .NOT.OUT_C       .AND.
     &	     .NOT.OUT_OBJECT ) GOTO 9000
C
C work out the name of our output file
C
	COM_NAM = STUB_NAM(:STUB_LEN) // TEMP_COM
	COM_LEN = STUB_LEN + SZ_TEMP_COM
C
C open the output file - this is the command file that we are creating
C
	OPEN ( UNIT=COM_UNIT,
     &	       FILE=COM_NAM(:COM_LEN), STATUS='NEW',
     &	       CARRIAGECONTROL='LIST', ERR=9999)
C
	IF ( EXTRA_LOG ) THEN
	   CALL LSL_PUTMSG( NEWMSG__COMOPN, COM_NAM(:COM_LEN) )
	   CALL LSL_ADDMSG( NEWMSG__CRECOM )
	ENDIF
C
C start the file off
C
	WRITE (COM_UNIT,1000)
C
C are we outputting a .PROMSG file to use MESSAGE on?
C
	IF ( OUT_OBJECT ) THEN
	   WRITE (COM_UNIT,2000) STUB_NAM(:STUB_LEN) // PROMSG // '_TEMP'
     &				,STUB_NAM(:STUB_LEN) // PROMSG
     &				,STUB_NAM(:STUB_LEN) // PROMSG // '_OBJ'
     &				,STUB_NAM(:STUB_LEN) // PROMSG // '_TEMP'
     &				,STUB_NAM(:STUB_LEN) // PROMSG // '_OBJ'
     &				,STUB_NAM(:STUB_LEN) // PROMSG // '_OBJ'
	   IF (.NOT.KEEP)
     &	   WRITE (COM_UNIT,2010) STUB_NAM(:STUB_LEN) // PROMSG
     &				,STUB_NAM(:STUB_LEN) // PROMSG // '_TEMP'
	ENDIF
C
C if we are not generating parameter files, we don't need to do
C the GENPAR bits
C
	IF ( OUT_FORTRAN .OR. OUT_MACRO .OR. OUT_C ) THEN
	   WRITE (COM_UNIT,3000) STUB_NAM(:STUB_LEN) // PROMSG // '_OBJ'
	   IF ( OUT_FORTRAN ) WRITE (COM_UNIT,3010)
     &				 STUB_NAM(:STUB_LEN)//'MSG.PAR'
	   IF ( OUT_MACRO   ) WRITE (COM_UNIT,3010)
     &				 STUB_NAM(:STUB_LEN)//'MSG.MAR'
	   IF ( OUT_C       ) WRITE (COM_UNIT,3010)
     &				 STUB_NAM(:STUB_LEN)//'MSG.H'
	   IF (.NOT.KEEP) WRITE (COM_UNIT,3020)
	ENDIF
C
C and tidy up after ourselves
C
	WRITE (COM_UNIT,4000)
	IF (.NOT.KEEP) WRITE (COM_UNIT,4010)
	WRITE (COM_UNIT,4020)
C
C **********************************************************************
C and finally close the file, keeping it for later use
C
	CLOSE (UNIT=COM_UNIT,DISPOSE='KEEP')
	IF ( EXTRA_LOG ) CALL LSL_PUTMSG( NEWMSG__COMCLO )
	GOTO 9000
C
C **********************************************************************
C deal with an error in opening the file here
C
9999	CALL ERRSNS( , IERR, OK )
	IF ( OK.EQ.0 ) OK = IERR
C
	CALL LSL_PUTMSG( NEWMSG__ERROPN, COM_NAM(:COM_LEN) )
	CALL LSL_ADDMSG( OK )      
C
	WRITE_COMFILE = .TRUE.		! failure
C
9000	RETURN
C
C ======================================================================
C ------------------------  FORMAT statements  -------------------------
C ======================================================================
C Start off the command file
C
1000	FORMAT ('$!'/
     &		'$! Temporary command file generated by NEWMSG'/
     &		'$!'/
     &		'$	on error then continue')
C
C ......................................................................
C Use the MESSAGE utility
C - note that we use ADC with the /CO switch. This makes it "retain
C   comments", which in ordinary language means that it won't throw
C   away any lines starting with the letter 'C' in column 1!
C   (in fact, in START_NEW_MESSAGE we ensure that all message idents
C   start in column 2, anyway, so that there will never be a letter
C   'C' in column 1, but this is just making sure...)
C
2000	FORMAT ('$!'/
     &		'$	adc  ',A,'/co=',A/
     &		'$	message/nolist/obj=',A,'  ',A/
     &		'$	if .not.$status then goto had_an_error'/
     &		'$	pvv  ',A/
     &		'$	purge/nolog  ',A)
C
2010	FORMAT ('$	delete/noconfirm  ',A,';*'/
     &		'$	delete/noconfirm  ',A,';*'/
     &		'$	delete/noconfirm  ADC.IDE;*')
C
C ......................................................................
C Compile and link GENPAR.FOR, and process the parameter files
C
3000	FORMAT ('$!'/
     &		'$	fortran/nolist  GENPAR'/
     &		'$	if .not.$status then goto had_an_error'/
     &		'$	link/nomap	GENPAR,',A/
     &		'$	if .not.$status then goto had_an_error'/
     &		'$	run  GENPAR'/
     &		'$!')
C
3010	FORMAT ('$	purge/nolog  ',A)
C
3020	FORMAT ('$!'/
     &		'$	delete/noconfirm  GENPAR.FOR;*'/
     &		'$	delete/noconfirm  GENPAR.OBJ;*'/
     &		'$	delete/noconfirm  GENPAR.EXE;*')
C
C ......................................................................
C and the standard ending for the command file
C
4000	FORMAT ('$!'/
     &		'$! ****************************************************'/
     &		'$!')
C
4010	FORMAT ('$	delete/noconfirm  ''f$environment("PROCEDURE")')
C
4020	FORMAT ('$	exit 1	! SS$_NORMAL'/
     &		'$!'/
     &		'$had_an_error:'/
     &		'$	set noverify'/
     &		'$	ws = "write sys$output"'/
     &		'$	ws ""'/
     &		'$	ws "Because of the previous error(s), this "+-'/
     &		'"command file (''''f$environment(""PROCEDURE"")'')"'/
     &		'$	ws "has not been deleted. Various intermediate "+-'/
     &		'"files will also be left around"'/
     &		'$!'/
     &		'$	exit 44	! SS$_ABORT')
C
C ......................................................................
C
	END
