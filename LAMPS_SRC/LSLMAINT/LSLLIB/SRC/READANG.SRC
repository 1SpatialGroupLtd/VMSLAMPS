	LOGICAL FUNCTION READANG(SECS,FLG)
C
***	MODULE READANG
***	IDENT 29AP94
C
C	Copyright Laser-Scan Laboratories Ltd., Cambridge, England.
C
C	Written					RWR	25-Aug-1988
C
CMOD	Mod M710				RWR	17-Nov-1988
C	Allow component of angle to begin with decimal point
C
C	Function that reads an angle in ddd mm ss.ss format
C	and returns the angle in seconds (as a R*8)
C
C	Function returns .FALSE. if valid angle returned, and .TRUE.
C	otherwise. The reason for invalid angles are returned in FLG.
C	Values of FLG when READANG is .TRUE. are:-
C
C	READANG_EOL	    end of line
C
C	READANG_ILLEGDECPT  error in format of angle
C			    (only last element is allowed a ".")
C
C	READANG_SGNHANDEMI  sign and hemisphere present
C
C	READANG_ILLEGANGVAL error in value of an element
C			    (eg degrees > 360, min > 60 etc)
C
C	READANG_ILLEGCHAR   unexpected character at start of number
C
C	Values of FLG when READANG is .FALSE. are:-
C
C	READANG_ANGLE	    for angle with no hemisphere
C
C	READANG_LONGITUDE   for longitude
C
C	READANG_LATITUDE    for latitude
C
	IMPLICIT	NONE
C
***	PARAMETER/LSL$CMNLSL:READANG/
C
C arguments (output)
C
	REAL*8		SECS	! angle returned in seconds of arc
	INTEGER*4	FLG
C
C functions
C
	LOGICAL		LSL_RDDBLE_CMPT
	LOGICAL		RDCHS
C
C working storage
C
	REAL*8		DEG,MIN,SEC	! elements of angle
	INTEGER		SIGN
	LOGICAL		HADSIGN
	LOGICAL		HADTERM
	LOGICAL		HADHEMI
	LOGICAL		HAD_DOT
	LOGICAL		DUMMY_SIGN
	BYTE		TERM
	REAL		TOTANG
C
C initialise
C
	READANG=.TRUE.			! assume failure
	FLG=READANG_EOL			! with blank line
	DUMMY_SIGN=.FALSE.		! LSL_RDDBLE_CMPT doesn't test
	HADSIGN=.FALSE.
	HADTERM=.FALSE.
	HADHEMI=.FALSE.
	SECS=0.0
	DEG=0.0
	MIN=0.0
	SEC=0.0
	SIGN=+1
C
C read next character from buffer
C
	IF (RDCHS(TERM)) THEN
	   GOTO 999			! end of line
	ELSE
C
C check for number
	   IF ((TERM.GE.'0'.AND.TERM.LE.'9').OR.TERM.EQ.'.') THEN
	      CALL BSCH
	   ELSEIF (TERM.EQ.'-'.OR.TERM.EQ.'+') THEN	! sign
	      HADSIGN=.TRUE.
	      IF (TERM.EQ.'-') SIGN=-SIGN
	   ELSE
	      CALL BSCH			! put character back in buffer
	      FLG=READANG_ILLEGCHAR	! invalid character
	      GOTO 999
	   ENDIF
	ENDIF
C
C read degrees
C
	HAD_DOT=.FALSE.
	IF (LSL_RDDBLE_CMPT(DEG,DUMMY_SIGN,HAD_DOT)) GOTO 800	! eol
C
C see if there is a terminator
C
	IF (RDCHS(TERM)) THEN		! end of line and end of angle
	   GOTO 800
	ELSE
C
C check for number
	   IF ((TERM.GE.'0'.AND.TERM.LE.'9').OR.TERM.EQ.'.') THEN
	      IF (HAD_DOT) THEN			! decimal degrees!!!
	         FLG=READANG_ILLEGDECPT		! invalid format
	         CALL BSCH			! put it back
	         GOTO 999
	      ELSE
	         CALL BSCH
	      ENDIF
	   ELSE					! angle terminated
	      HADTERM=.TRUE.
	      GOTO 800
	   ENDIF
	ENDIF
C
C read the minutes (cannot in fact be eol!)
C
	HAD_DOT=.FALSE.
	IF (LSL_RDDBLE_CMPT(MIN,DUMMY_SIGN,HAD_DOT)) GOTO 800	! eol
C
C see if there is a terminator
C
	IF (RDCHS(TERM)) THEN		! end of line and end of angle
	   GOTO 800
	ELSE
C
C check for number
	   IF ((TERM.GE.'0'.AND.TERM.LE.'9').OR.TERM.EQ.'.') THEN
	      IF (HAD_DOT) THEN			! decimal minutes!!!
	         FLG=READANG_ILLEGDECPT		! invalid format
	         CALL BSCH			! put it back 
	         GOTO 999
	      ELSE
	         CALL BSCH
	      ENDIF
	   ELSE					! angle terminated
	      HADTERM=.TRUE.
	      GOTO 800
	   ENDIF
	ENDIF
C
C read seconds (cannot in fact be end of line)
C	
	HAD_DOT=.FALSE.
	IF (LSL_RDDBLE_CMPT(SEC,DUMMY_SIGN,HAD_DOT)) GOTO 800	! eol
C
C check terminating character
C
	 IF (RDCHS(TERM)) THEN
	   GOTO 800			! eol
	ELSE
C
C check for number
	   IF ((TERM.GE.'0'.AND.TERM.LE.'9').OR.TERM.EQ.'.') THEN
	      CALL BSCH			! number
	   ELSE
	      HADTERM=.TRUE.
	   ENDIF
	ENDIF
C
C now sort out angle
C
  800	CONTINUE
	HADHEMI=HADTERM.AND.
     &	        (TERM.EQ.'E'.OR.TERM.EQ.'W'.OR.
     &	         TERM.EQ.'N'.OR.TERM.EQ.'S'.OR.
     &	         TERM.EQ.'e'.OR.TERM.EQ.'w'.OR.
     &	         TERM.EQ.'n'.OR.TERM.EQ.'s')
C
C put terminating character back in buffer, if it is not hemisphere
C
	IF (HADTERM.AND..NOT.HADHEMI) CALL BSCH
C
C check for hemisphere and sign
C
	IF (HADHEMI.AND.HADSIGN) THEN
	   FLG=READANG_SGNANDHEMI
	   GOTO 999
	ENDIF
C
C check for valid angular components
C
	IF (.NOT.HADHEMI) THEN
	   TOTANG=360.0
	ELSE
	   IF (TERM.EQ.'E'.OR.TERM.EQ.'W'.OR.TERM.EQ.'e'.OR.TERM.EQ.'w')
     &	                        THEN
	      TOTANG=180.0
	   ELSE
	      TOTANG=90.0
	   ENDIF
	ENDIF
C
	IF ((HADHEMI.AND.DEG.GT.TOTANG).OR.		! 180 or 90 OK
     &	    (.NOT.HADHEMI.AND.DEG.GE.TOTANG).OR.	! 360 too big
     &	    (DEG.EQ.TOTANG.AND.(MIN.NE.0.0.OR.SEC.NE.0.0)).OR.
     &	    (MIN.GE.60.0).OR.
     &	    (SEC.GE.60.0)) THEN
	   FLG=READANG_ILLEGANGVAL
	   GOTO 999
	ENDIF
C
C get hemishpere
C
	IF (.NOT.HADHEMI) THEN
	   FLG=READANG_ANGLE
	ELSEIF (TERM.EQ.'E'.OR.TERM.EQ.'e'.OR.
     &	        TERM.EQ.'W'.OR.TERM.EQ.'w') THEN
	   FLG=READANG_LONGITUDE			! longitude
	ELSE
	   FLG=READANG_LATITUDE				! latitude
	ENDIF
C
C get sign from hemisphere
C
	IF (HADHEMI.AND.
     &	   (TERM.EQ.'W'.OR.TERM.EQ.'w'.OR.
     &	    TERM.EQ.'S'.OR.TERM.EQ.'s')) SIGN=-SIGN
C
C construct angle and return
C
	SECS=SIGN*(DEG*3600.0+MIN*60+SEC)
	READANG=.FALSE.
C
  999	CONTINUE
	RETURN
	END
