	LOGICAL FUNCTION LSG_SET_LUT(WKID,FILENAME)
C
***	IDENT	02AP89
***	MODULE	LSG_SET_LUT
C
C	Copyright LaserScan Laboratories Ltd., Cambridge, England
C
C Author Clarke Brunt					17-Mar-1986
C
C To read a colour table file for VAXStation
C Table has same format as for Sigma ARGS just for compatibility
C See [LIB.VSLIB]RDSYSC.SRC
C All blink stuff is ignored (and need not be present)
C
C The system constants file has the following format...
C
C    <colour_number>     [; <comment>]
C                                                             N
C  { <red>   <green>   <blue>   [<blink>|;]      [<comment>] }
C
C where a line is in curly brackets ( { and } ) it is repeated the
C number of times given by the superscript. A parameter in square
C brackets ( [ and ] ) is optional.
C
C spaces and tabs are equivalent, and serve merely as field separators-
C they are otherwise ignored.
C
C N is equal to the <colour_number>
C
C Comment lines are preceded by a semi-colon, and may be interspersed
C at will.
C
	IMPLICIT NONE
C
C arguments
	INTEGER		WKID		! unused
	CHARACTER*(*)	FILENAME	! filename or logical name
C
	INCLUDE 'LSL$CMNLSL:LSLLIBMSG.PAR'
	INCLUDE 'HERE:GKSDAT2.CMN'
C
C functions used
	LOGICAL		FLROPN
	LOGICAL		FLRCLO
	INTEGER*4	FLRLIN
	LOGICAL		RDCHS
	LOGICAL		RDLONG
	LOGICAL		RDLHEX
	LOGICAL*4	LIB$GET_LUN
	LOGICAL*4	LIB$FREE_LUN
	INTEGER	GETDEV
C
C workspace
	INTEGER		DEV
	LOGICAL*4	OK
	INTEGER*4	ERROR
	INTEGER		I			! count variable
	BYTE		CH			! character read
	INTEGER*4	CNUM			! number of colours
	INTEGER*4	LUN
	INTEGER		LINTYP			! type of line
	INTEGER		INDEX			! colour index
	INTEGER		CVAL			! colour value
C
	LSG_SET_LUT = .FALSE.			! assume success
	ERROR = GETDEV(DEV,WKID)
	IF (ERROR.NE.0) GOTO 1000
C
C get a LUN to read the file on
	OK = LIB$GET_LUN(LUN)
	IF (.NOT.OK) THEN		! failed
	   CALL LSL_PUTMSG(OK)
	   GOTO 10000
	ENDIF
C
C open up the file (just give up on error)
	OK = FLROPN(LUN,FILENAME)	! open file
	IF (.NOT.OK) THEN
	   LSG_SET_LUT = .TRUE.		! indicate file not found
	   GOTO 999
	ENDIF
C
	LINTYP = 1			! want number of colours
	INDEX = 0			! start with colour 0
C
50	OK =  FLRLIN(,,,ERROR) 	! read into TXTBUF
	IF (.NOT.OK) THEN
	   IF (OK.EQ.LSL__EOF) GOTO 998		! end of file
	   CALL LSL_PUTMSG(OK)
	   CALL LSL_ADDMSG(ERROR)
	   GOTO 999
	ENDIF
C
C we have a line - what is it ?
	CALL BSLN				! start of line
	IF (RDCHS(CH)) GOTO 50			! empty line
	IF (CH.EQ.';') GOTO 50			! comment line
	CALL BSCH
C
	GOTO (1000,2000) LINTYP
C
C the first line contains a single integer which says how many colours
C are being defined
1000	IF (RDLONG(CNUM) ) GOTO 998	! read the (decimal) number
	IF (CNUM.LE.0.OR.CNUM.GT.256) GOTO 998	! out of range
	LINTYP = LINTYP+1
	GOTO 50				! next line
C
C data lines are 3 hex numbers, specifying Red, Green, Blue values in
C the video transformation table, optionally followed by a 4th hex
C value defining the blink byte in the table (which is zero by default)
C
2000	CONTINUE
C
	DO 2010 I = 1,3
	   IF (RDLHEX(CVAL)) GOTO 998
	   IF (CVAL.LT.0.OR.CVAL.GT.255) GOTO 998
	   RGB(INDEX,I,1,DEV) = CVAL/255.0
2010	CONTINUE
C
	INDEX = INDEX+1		! next colour index
	IF (INDEX.LT.CNUM.AND.INDEX.LE.MAXCOL(DEV)) GOTO 50
C
C load up the colours
	CALL LSG_PLANE_VISIBLE(WKID,PVIS(DEV))
C
C Ignore blink generator stuff
998	OK = FLRCLO(LUN,ERROR)
	IF (.NOT.OK) THEN
	   CALL LSL_PUTMSG(OK)
	   CALL LSL_ADDMSG(ERROR)
	ENDIF
C
999	OK = LIB$FREE_LUN(LUN)	! free LUN
	IF (.NOT.OK) CALL LSL_PUTMSG(OK)
C
10000	RETURN
C
	END
C
	SUBROUTINE LSG_SET_COLOURS(WKID,N,R,G,B)
C
***	IDENT	16JN87
***	MODULE	LSG_SET_COLOURS
C
C	Copyright LaserScan Laboratories Ltd., Cambridge, England
C
C Author Clarke Brunt					17-Mar-1986
C
C To set representation for colours 0:N-1 (as GSCR but several colours)
C
C Arguments:
	INTEGER	WKID			! workstation-identifier
	INTEGER	N			! number of colours
	REAL	R(0:*),G(0:*),B(0:*)	! colour values
C
***	COMMON/GKSDAT2/
***	COMMON/GKSESL/
C
C function called
	INTEGER	GETDEV
C
C workspace
	INTEGER	DEV
	INTEGER	CI,NCOL
C
	GKSERR = GETDEV(DEV,WKID)
	IF (GKSERR.NE.0) GOTO 9999
C
	NCOL = MIN(N,MAXCOL(DEV)+1)
C
	DO 10 CI=0,NCOL-1
	   RGB(CI,1,1,DEV) = R(CI)
	   RGB(CI,2,1,DEV) = G(CI)
	   RGB(CI,3,1,DEV) = B(CI)
10	CONTINUE
C
	IF ((PVIS(DEV).AND.USED_PLANESB(1,DEV)).EQ.
     &			   USED_PLANESB(1,DEV)) THEN ! all visible
	   CALL UIS$SET_COLORS(DCB(DEV),0,NCOL,R,G,B)
	ELSE
	   CALL LSG_PLANE_VISIBLE(WKID,PVIS(DEV))
	ENDIF
C
9999	RETURN
C
	END
